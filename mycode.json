[{"_id":"Helper-1608553666230","name":"Helper","type":"script","creation_date":1608553666231,"expressions":[{"_id":"Collage-Script-1608620894986","code":"var run = _ bool: Run Collage immediately ? (Useful to execute from MoCode Editor _;\nvar borderSize = _ number: Border Size _;\nvar fitToComp = _ bool: Fit To Comp? _;\n\t\tif (run) {\n\t\t\trunCollage(borderSize, fitToComp);\n\t\t}\n\n\t\tfunction runCollage(borderSize, fitToComp) {\n\t\t\t// Collage.jsx\n\t\t\t// Copyright (c) 2012 Motion Boutique\n\t\t\t//\n\t\t\t// Photobook layout with selected layers\n      run()\n\t\t\tfunction Node() {\n\t\t\t\tthis.leftNode = null;\n\t\t\t\tthis.rightNode = null;\n\t\t\t\tthis.value = \"\";\n\t\t\t\tthis.bbWidth = \"\";\n\t\t\t\tthis.bbHeight = \"\";\n\t\t\t\tthis.equation = \"\";\n\t\t\t\tthis.upperLeft = [0, 0];\n\t\t\t}\n\n\t\t\tfunction nodeToString(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\ttreeStr += node.value + \" \"; // \"(\" + node.bbWidth + \",\" + node.bbHeight + \") \";\n\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\tvar s = nodeToString(node.leftNode);\n\t\t\t\t\t\tif (s) treeStr += s;\n\t\t\t\t\t}\n\t\t\t\t\tif (node.rightNode) {\n\t\t\t\t\t\tvar s = nodeToString(node.rightNode);\n\t\t\t\t\t\tif (s) treeStr += s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getRandomTree() {\n\t\t\t\tnPrime = 0;\n\t\t\t\tleafs = [];\n\t\t\t\twhile (nPrime < n) {\n\t\t\t\t\tif (leafs.length >= 1) {\n\t\t\t\t\t\tvar j = Math.floor(Math.random() * leafs.length);\n\t\t\t\t\t\tvar node = leafs[j];\n\t\t\t\t\t\tleafs.splice(j, 1);\n\n\t\t\t\t\t\tnode.leftNode = new Node();\n\t\t\t\t\t\tnode.leftNode.value = nPrime + 1;\n\t\t\t\t\t\tleafs.push(node.leftNode);\n\t\t\t\t\t\tnPrime++;\n\n\t\t\t\t\t\tif (nPrime < n) {\n\t\t\t\t\t\t\tnode.rightNode = new Node();\n\t\t\t\t\t\t\tnode.rightNode.value = nPrime + 1;\n\t\t\t\t\t\t\tleafs.push(node.rightNode);\n\t\t\t\t\t\t\tnPrime++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar node = rootNode;\n\t\t\t\t\t\tnode.value = nPrime + 1;\n\t\t\t\t\t\tleafs.push(node);\n\t\t\t\t\t\tnPrime++;\n\t\t\t\t\t}\n\t\t\t\t\t//alert(\"num nodes: \" + nPrime + \"\\rleafs: \" + leafs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar lastCut = \"\";\n\n\t\t\tfunction assignDataToNode(node) {\n\t\t\t\tif (node.leftNode) {\n\t\t\t\t\tif (!isNaN(node.value)) {\n\t\t\t\t\t\t//for (var z = 0; z < 25; z++) var foo = Math.random();\n\t\t\t\t\t\tvar nodeVal = (Math.random() < 0.5) ? \"H\" : \"V\";\n\t\t\t\t\t\tif (nodeVal == lastCut)\n\t\t\t\t\t\t\tnodeVal = (nodeVal == \"H\") ? \"V\" : \"H\";\n\t\t\t\t\t\tif (Math.random() < 0.3)\n\t\t\t\t\t\t\tnodeVal = (nodeVal == \"H\") ? \"V\" : \"H\";\n\t\t\t\t\t\tnode.value = nodeVal;\n\t\t\t\t\t\tlastCut = nodeVal;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!isNaN(node.value)) {\n\t\t\t\t\t\tvar j = Math.floor(Math.random() * leafs.length);\n\t\t\t\t\t\tnode.value = \"\" + (photoCounter + 1);\n\t\t\t\t\t\tphotoCounter++;\n\t\t\t\t\t\tleafs.splice(j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction traverseAndAssignData(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\tassignDataToNode(node);\n\t\t\t\t\ttraverseAndAssignData(node.leftNode);\n\t\t\t\t\ttraverseAndAssignData(node.rightNode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction traverseAndComputeBBPhotoNode(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// terminals\n\t\t\t\t\tif (!node.leftNode) //  !node.rightNode)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar nodeId = parseInt(node.value, 10);\n\t\t\t\t\t\tvar a = photoOriginalSizes[nodeId - 1][1] / photoOriginalSizes[nodeId - 1][0];\n\t\t\t\t\t\tnode.bbWidth = \"w\" + nodeId + \" + b + b\";\n\t\t\t\t\t\tnode.bbHeight = a.toFixed(3) + \" * w\" + nodeId + \" + b + b\";\n\n\t\t\t\t\t\t//alert(node.value + \"\\n\" + node.bbWidth);\n\t\t\t\t\t\t//alert(\"nodeId: \" + nodeId + \"\\nnode.value: \" + node.value);\n\t\t\t\t\t}\n\t\t\t\t\t// interior\n\t\t\t\t\telse {\n\t\t\t\t\t\ttraverseAndComputeBBPhotoNode(node.leftNode);\n\t\t\t\t\t\ttraverseAndComputeBBPhotoNode(node.rightNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction traverseAndComputeBBInteriorNode(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// interior\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\ttraverseAndComputeBBInteriorNode(node.leftNode);\n\t\t\t\t\t\ttraverseAndComputeBBInteriorNode(node.rightNode);\n\n\t\t\t\t\t\tif (node.value == \"H\") {\n\t\t\t\t\t\t\tnode.bbWidth = node.leftNode.bbWidth;\n\t\t\t\t\t\t\tnode.bbHeight = node.leftNode.bbHeight + \" + \" + node.rightNode.bbHeight + \" + s\";\n\n\t\t\t\t\t\t\t//alert(node.value + \"(traverseAndComputeBBInteriorNode)\\n\" + node.bbWidth);\n\t\t\t\t\t\t} else if (node.value == \"V\") {\n\t\t\t\t\t\t\tnode.bbWidth = node.leftNode.bbWidth + \" + \" + node.rightNode.bbWidth + \" + s\";\n\t\t\t\t\t\t\tnode.bbHeight = node.leftNode.bbHeight;\n\n\t\t\t\t\t\t\t//alert(node.value + \"(traverseAndComputeBBInteriorNode)\\n\" + node.bbWidth);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getNodeEquation(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// interior\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\tgetNodeEquation(node.leftNode);\n\t\t\t\t\t\tgetNodeEquation(node.rightNode);\n\n\t\t\t\t\t\tif (node.value == \"H\") {\n\t\t\t\t\t\t\t//alert(node.value + \" (getNodeEquation)\\n\" + node.leftNode.bbWidth);\n\t\t\t\t\t\t\tnode.equation = node.leftNode.bbWidth + \" = \" + node.rightNode.bbWidth;\n\t\t\t\t\t\t} else if (node.value == \"V\") {\n\t\t\t\t\t\t\t//alert(node.value + \" (getNodeEquation)\\n\" + node.leftNode.bbWidth);\n\t\t\t\t\t\t\tnode.equation = node.leftNode.bbHeight + \" = \" + node.rightNode.bbHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//alert(\"node.equation:\\n\" + node.equation);\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction evaluateExpression(expr) {\n\t\t\t\tvar wcoefs = [];\n\t\t\t\tvar betacoef = 0;\n\t\t\t\tvar sigmacoef = 0;\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\twcoefs.push(0);\n\t\t\t\t}\n\n\t\t\t\t//alert(\"expression:\\n\" + expr);\n\n\t\t\t\tfor (var i = 0; i < expr.length; i++) {\n\t\t\t\t\tvar ch = expr.charAt(i);\n\t\t\t\t\tif (ch == \"w\") {\n\t\t\t\t\t\tvar nodeIdStr = \"\";\n\t\t\t\t\t\tvar j = 1;\n\t\t\t\t\t\twhile (!isNaN(expr.charAt(i + j))) // w10 for instance\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnodeIdStr += expr.charAt(i + j);\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar nodeId = parseInt(nodeIdStr) - 1;\n\n\t\t\t\t\t\tvar factor = \"\"; // (1) w1\n\t\t\t\t\t\tif (i != 0 && expr.charAt(i - 2) == \"*\") {\n\t\t\t\t\t\t\tfor (var z = 0; z < 5; z++) // 1.333 * w1\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactor += expr.charAt(i - 8 + z);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else factor = \"1\";\n\n\t\t\t\t\t\twcoefs[nodeId] += parseFloat(factor);\n\t\t\t\t\t} else if (ch == \"b\") {\n\t\t\t\t\t\tbetacoef++;\n\t\t\t\t\t} else if (ch == \"s\") {\n\t\t\t\t\t\tsigmacoef++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//alert(wcoefs);\n\t\t\t\t//alert(betacoef);\n\t\t\t\t//alert(sigmacoef);\n\n\t\t\t\tvar res = 0;\n\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\tres += wcoefs[i] * xVec[i];\n\t\t\t\t}\n\t\t\t\tres += betacoef * beta + sigmacoef * sigma;\n\n\t\t\t\t//alert(\"res: \" + res);\n\n\t\t\t\treturn res;\n\t\t\t}\n\n\n\t\t\tfunction traverseAndComputeUpperLeft(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// interior\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\tif (node.value == \"H\") {\n\t\t\t\t\t\t\tnode.leftNode.upperLeft = node.upperLeft;\n\t\t\t\t\t\t\tvar h = evaluateExpression(node.leftNode.bbHeight);\n\t\t\t\t\t\t\tnode.rightNode.upperLeft = node.upperLeft + [0, h];\n\t\t\t\t\t\t} else if (node.value == \"V\") {\n\t\t\t\t\t\t\tnode.leftNode.upperLeft = node.upperLeft;\n\t\t\t\t\t\t\tvar w = evaluateExpression(node.leftNode.bbWidth);\n\t\t\t\t\t\t\tnode.rightNode.upperLeft = node.upperLeft + [w, 0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttraverseAndComputeUpperLeft(node.leftNode);\n\t\t\t\t\t\ttraverseAndComputeUpperLeft(node.rightNode);\n\t\t\t\t\t}\n\t\t\t\t\t// leafs\n\t\t\t\t\telse {\n\t\t\t\t\t\t// upperleft's have been assigned, store location in global uls array\n\t\t\t\t\t\tvar nodeId = parseInt(node.value) - 1;\n\t\t\t\t\t\tuls[nodeId] = node.upperLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction findAndSolveSytem(node, constrainTypeStr) {\n\t\t\t\tvar matA = new Array(N);\n\t\t\t\tvar bVec = new Array(N);\n\n\t\t\t\tvar wsL = new Array(N);\n\t\t\t\tvar wsR = new Array(N);\n\t\t\t\tvar betasL = new Array(N);\n\t\t\t\tvar betasR = new Array(N);\n\t\t\t\tvar sigmasL = new Array(N);\n\t\t\t\tvar sigmasR = new Array(N);\n\n\t\t\t\t// init buckets\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\tmatA[i] = new Array(N);\n\t\t\t\t\tbVec[i] = 0;\n\n\t\t\t\t\twsL[i] = new Array(N);\n\t\t\t\t\twsR[i] = new Array(N);\n\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\twsL[i][j] = 0;\n\t\t\t\t\t\twsR[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbetasL[i] = 0;\n\t\t\t\t\tbetasR[i] = 0;\n\t\t\t\t\tsigmasL[i] = 0;\n\t\t\t\t\tsigmasR[i] = 0;\n\t\t\t\t}\n\n\t\t\t\tgetNodeEquation(node); // find N*-1* equations (populate '.equation' field of interior nodes)\n\n\n\t\t\t\t// parse N*-1* equations\n\t\t\t\tvar equationId = 0;\n\t\t\t\tparseEquation(node); // populate ws, betas and sigma arrays\n\n\n\t\t\t\t// construct coefs from the N-1 eqs\n\t\t\t\tfor (var i = 0; i < N - 1; i++) {\n\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\tmatA[i][j] = wsL[i][j] - wsR[i][j]; // ws are the unkown, on the left hand side of the eqn\n\t\t\t\t\t}\n\t\t\t\t\tbVec[i] = (betasR[i] - betasL[i]) * beta + (sigmasR[i] - sigmasL[i]) * sigma; // b is to the right hand side\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// add Nth constraint\n\t\t\t\t\tvar str;\n\t\t\t\t\tif (constrainTypeStr == \"constrainWidth\")\n\t\t\t\t\t\tstr = node.bbWidth + \" = 0\";\n\t\t\t\t\telse if (constrainTypeStr == \"constrainHeight\")\n\t\t\t\t\t\tstr = node.bbHeight + \" = 0\";\n\n\t\t\t\t\tparseAndAssign(str);\n\t\t\t\t\tequationId++;\n\n\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\tmatA[N - 1][j] = wsL[N - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (constrainTypeStr == \"constrainWidth\")\n\t\t\t\t\t\tbVec[N - 1] = W - (betasL[N - 1] * beta + sigmasL[N - 1] * sigma);\n\t\t\t\t\telse if (constrainTypeStr == \"constrainHeight\")\n\t\t\t\t\t\tbVec[N - 1] = H - (betasL[N - 1] * beta + sigmasL[N - 1] * sigma);\n\t\t\t\t\t/*\t\n\t\t\t\t\t// debug-------------\n\t\t\t\t\tvar file = new File(Folder.desktop.fsName + \"/Ab.txt\");\n\t\t\t\t\tfile.open(\"w\")\n\t\t\t\t\tvar txt = \"\"\n\t\t\t\t\tfor (var i = 0; i < matA.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var j = 0; j < matA[0].length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttxt += matA[i][j] + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt += \"\\r\\n\";\t\n\t\t\t\t\t}\n\t\t\t\t\tfile.writeln(txt);\n\t\t\t\t\tfile.writeln(\"\");\n\t\t\t\t\tvar txt = \"\";\n\t\t\t\t\tfor (var i = 0; i < bVec.length; i++)\n\t\t\t\t\t\ttxt += bVec[i] + \"\\n\";\n\t\t\t\t\tfile.writeln(txt);\n\n\t\t\t\t\ttreeStr = \"\";\n\t\t\t\t\tnodeToString(rootNode); // populate treeStr\n\t\t\t\t\tfile.writeln(treeStr);\n\n\t\t\t\t\tfile.close();\n\t\t\t\t\t//file.execute();\n\t\t\t\t\t//--------------\n\t\t\t\t\t*/\n\n\t\t\t\t\t// solve using SVD decomposition -------------------------\n\t\t\t\t\tmatA = numeric.svd(matA);\n\n\t\t\t\t\tvar diagInvS = new Array(N);\n\t\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\t\tdiagInvS[i] = new Array(N);\n\t\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\t\tdiagInvS[i][j] = 0;\n\t\t\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\t\t\tif (matA.S[i] != 0)\n\t\t\t\t\t\t\t\t\tdiagInvS[i][j] = 1 / matA.S[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar temp1 = numeric.dot(matA.V, diagInvS);\n\t\t\t\t\tvar temp2 = numeric.dot(numeric.transpose(matA.U), bVec);\n\t\t\t\t\tvar res = numeric.dot(temp1, temp2);\n\t\t\t\t\t//----------------------------------------------------------\n\n\t\t\t\t\t/*\n\t\t\t\t\t// solve using Linear Programming\n\t\t\t\t\t*/\n\t\t\t\t\t//alert(res);\n\t\t\t\t} catch (e) {\n\t\t\t\t\talert(e);\n\t\t\t\t}\n\t\t\t\treturn res;\n\n\t\t\t\t//--utils\n\n\t\t\t\tfunction parseAndAssign(str) {\n\t\t\t\t\tvar strParts = str.split(\" = \");\n\t\t\t\t\tvar leftPart = strParts[0];\n\t\t\t\t\tvar rightPart = strParts[1];\n\n\t\t\t\t\t//alert(\"left part...\\n\" + leftPart);\n\t\t\t\t\t//alert(\"right part...\\n\" + rightPart);\n\n\t\t\t\t\t// parse left side\n\t\t\t\t\tfor (var i = 0; i < leftPart.length; i++) {\n\t\t\t\t\t\tvar ch = leftPart.charAt(i);\n\t\t\t\t\t\tif (ch == \"w\") {\n\t\t\t\t\t\t\tvar nodeIdStr = \"\";\n\t\t\t\t\t\t\tvar j = 1;\n\t\t\t\t\t\t\twhile (!isNaN(leftPart.charAt(i + j))) // w10 for instance\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeIdStr += leftPart.charAt(i + j);\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar nodeId = parseInt(nodeIdStr) - 1;\n\n\t\t\t\t\t\t\tvar factor = \"\"; // (1) w1\n\t\t\t\t\t\t\tif (i != 0 && leftPart.charAt(i - 2) == \"*\") {\n\t\t\t\t\t\t\t\tfor (var z = 0; z < 5; z++) // 1.333 * w1\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfactor += leftPart.charAt(i - 8 + z);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else factor = \"1\";\n\n\t\t\t\t\t\t\twsL[equationId][nodeId] += parseFloat(factor);\n\t\t\t\t\t\t} else if (ch == \"b\") {\n\t\t\t\t\t\t\tbetasL[equationId]++;\n\t\t\t\t\t\t} else if (ch == \"s\") {\n\t\t\t\t\t\t\tsigmasL[equationId]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// parse right side\n\t\t\t\t\tfor (var i = 0; i < rightPart.length; i++) {\n\t\t\t\t\t\tvar ch = rightPart.charAt(i);\n\t\t\t\t\t\tif (ch == \"w\") {\n\t\t\t\t\t\t\tvar nodeIdStr = \"\";\n\t\t\t\t\t\t\tvar j = 1;\n\t\t\t\t\t\t\twhile (!isNaN(rightPart.charAt(i + j))) // w10 for instance\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeIdStr += rightPart.charAt(i + j);\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar nodeId = parseInt(nodeIdStr) - 1;\n\n\t\t\t\t\t\t\tvar factor = \"\"; // (1) w1\n\t\t\t\t\t\t\tif (i != 0 && rightPart.charAt(i - 2) == \"*\") {\n\t\t\t\t\t\t\t\tfor (var z = 0; z < 5; z++) // 1.333 * w1\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfactor += rightPart.charAt(i - 8 + z);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else factor = \"1\";\n\n\t\t\t\t\t\t\twsR[equationId][nodeId] += parseFloat(factor);\n\t\t\t\t\t\t} else if (ch == \"b\") {\n\t\t\t\t\t\t\tbetasR[equationId]++;\n\t\t\t\t\t\t} else if (ch == \"s\") {\n\t\t\t\t\t\t\tsigmasR[equationId]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseEquation(node) {\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\t// interior\n\t\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\t\tparseEquation(node.leftNode);\n\t\t\t\t\t\t\tparseEquation(node.rightNode);\n\n\t\t\t\t\t\t\tvar str = node.equation;\n\t\t\t\t\t\t\tif (str != \"\") {\n\t\t\t\t\t\t\t\t//alert(\"parsing equationId \" + equationId + \"\\n\" + str);\n\t\t\t\t\t\t\t\tparseAndAssign(str);\n\n\t\t\t\t\t\t\t\tequationId++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getOriginalSizes() {\n\t\t\t\tvar sizes = [];\n\n\t\t\t\tvar comp = app.project.activeItem;\n\t\t\t\tif (comp instanceof CompItem) {\n\t\t\t\t\tvar selLayers = comp.selectedLayers;\n\t\t\t\t\tif (selLayers.length < 1) {\n\t\t\t\t\t\talert(\"Select some layers\");\n\t\t\t\t\t\treturn sizes;\n\t\t\t\t\t}\n\n\t\t\t\t\tW = comp.width;\n\t\t\t\t\tH = comp.height;\n\n\t\t\t\t\tfor (var i = 0; i < selLayers.length; i++) {\n\t\t\t\t\t\tif (selLayers[i] instanceof AVLayer) {\n\t\t\t\t\t\t\tsizes.push([selLayers[i].width, selLayers[i].height]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else alert(\"Select some layers\");\n\n\t\t\t\treturn sizes;\n\t\t\t}\n\n\t\t\tfunction scaleAndPositionLayers(xVec, uls) {\n\t\t\t\t//alert(xVec);\n\t\t\t\tvar comp = app.project.activeItem;\n\t\t\t\tvar selLayers = comp.selectedLayers;\n\t\t\t\tvar photoId = 0;\n\t\t\t\tfor (var i = 0; i < selLayers.length; i++) {\n\t\t\t\t\tif (selLayers[i] instanceof AVLayer) {\n\t\t\t\t\t\tvar newW = xVec[photoId];\n\t\t\t\t\t\tvar ratio = newW / photoOriginalSizes[photoId][0];\n\t\t\t\t\t\tvar newH = ratio * photoOriginalSizes[photoId][1];\n\n\t\t\t\t\t\tvar s = 100 * ratio; // newWidth / originalWidth\n\n\t\t\t\t\t\tvar holdTime = 1; // in s\n\n\t\t\t\t\t\tvar hasScaleKeys = selLayers[i].scale.numKeys;\n\t\t\t\t\t\tif (hasScaleKeys) {\n\t\t\t\t\t\t\tselLayers[i].scale.setValueAtTime(comp.time, [s, s]);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].scale.nearestKeyIndex(comp.time);\n\t\t\t\t\t\t\tselLayers[i].scale.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.HOLD);\n\n\t\t\t\t\t\t\tselLayers[i].scale.setValueAtTime(comp.time + holdTime, [s, s]);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].scale.nearestKeyIndex(comp.time + holdTime);\n\t\t\t\t\t\t\tselLayers[i].scale.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.LINEAR);\n\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tselLayers[i].scale.setValue([s, s]);\n\n\t\t\t\t\t\tvar p = uls[photoId] + [newW / 2, newH / 2];\n\n\t\t\t\t\t\tvar hasPosKeys = selLayers[i].position.numKeys;\n\t\t\t\t\t\tif (hasPosKeys) {\n\t\t\t\t\t\t\tselLayers[i].position.setValueAtTime(comp.time, p);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].position.nearestKeyIndex(comp.time);\n\t\t\t\t\t\t\tselLayers[i].position.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.HOLD);\n\n\t\t\t\t\t\t\tselLayers[i].position.setValueAtTime(comp.time + holdTime, p);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].position.nearestKeyIndex(comp.time + holdTime);\n\t\t\t\t\t\t\tselLayers[i].position.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.LINEAR);\n\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tselLayers[i].position.setValue(p);\n\n\n\t\t\t\t\t\tphotoId++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction fitInside() {\n\t\t\t\tvar fitInside = true;\n\t\t\t\tfor (var i = 0; fitInside && i < N; i++) {\n\t\t\t\t\tvar newW = xVec[i];\n\t\t\t\t\tvar ratio = newW / photoOriginalSizes[i][0];\n\t\t\t\t\tvar newH = ratio * photoOriginalSizes[i][1];\n\n\t\t\t\t\tif (uls[i][0] + newW > (W + 0.1) || uls[i][1] + newH > (H + 0.1)) {\n\t\t\t\t\t\t//alert((uls[i][0] + newW) + \" > \" + W + \" || \" + (uls[i][1] + newH) + \" > \" + H);\n\t\t\t\t\t\tfitInside = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//alert(\"fitInside: \" + fitInside);\n\t\t\t\treturn fitInside;\n\t\t\t}\n\n\t\t\tfunction computeCoverage() {\n\t\t\t\tvar coverage = 0; // 1 represents the entire canvas\n\n\t\t\t\tvar totalArea = 0;\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\tvar newW = xVec[i];\n\t\t\t\t\tvar ratio = newW / photoOriginalSizes[i][0];\n\t\t\t\t\tvar newH = ratio * photoOriginalSizes[i][1];\n\t\t\t\t\ttotalArea += (newW * newH);\n\t\t\t\t}\n\t\t\t\tcoverage = totalArea / (W * H);\n\n\t\t\t\treturn coverage;\n\t\t\t}\n\n\t\t\tfunction isScaleAcceptable() {\n\t\t\t\tvar isAcceptable = true;\n\n\t\t\t\tfor (var i = 0; isAcceptable && i < N; i++) {\n\t\t\t\t\tif (xVec[i] > photoOriginalSizes[i][0]) // image scale > 100%\n\t\t\t\t\t{\n\t\t\t\t\t\tisAcceptable = false;\n\t\t\t\t\t\t//alert(\"scale of layer \" + (i+1) + \" is not acceptable\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isAcceptable;\n\t\t\t}\n\n\t\t\tfunction fitCompToCollage(widths, origins) {\n\t\t\t\t//var bbW = evaluateExpression(rootNode.bbWidth);\n\t\t\t\t//var bbH = evaluateExpression(rootNode.bbHeight);\n\t\t\t\t//alert(bbW + \" x \" + bbH);\n\t\t\t\tvar top = 0;\n\t\t\t\tvar left = 0;\n\t\t\t\tvar bottom = 0;\n\t\t\t\tvar right = 0;\n\t\t\t\tfor (var i = 0; i < origins.length; i++) {\n\t\t\t\t\tvar w = widths[i];\n\t\t\t\t\tvar ratio = w / photoOriginalSizes[i][0];\n\t\t\t\t\tvar h = ratio * photoOriginalSizes[i][1];\n\t\t\t\t\tif (origins[i][0] < left) left = origins[i][0];\n\t\t\t\t\tif (origins[i][1] < top) top = origins[i][1];\n\t\t\t\t\tif (origins[i][0] + w > right) right = origins[i][0] + w;\n\t\t\t\t\tif (origins[i][1] + h > bottom) bottom = origins[i][1] + h;\n\t\t\t\t}\n\t\t\t\tcollageW = right - left;\n\t\t\t\tcollageH = bottom - top;\n\t\t\t\t//alert(collageW + \" x \" + collageH);\n\t\t\t\t//app.project.activeItem.width = Math.floor(collageW);\n\t\t\t\tapp.project.activeItem.height = Math.floor(collageH + beta);\n\t\t\t}\n\n\t\t\tfunction run() {\n\t\t\t\tvar startTime = new Date().getTime();\n\n\t\t\t\tphotoOriginalSizes = getOriginalSizes();\n\t\t\t\tif (photoOriginalSizes.length < 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tN = photoOriginalSizes.length;\n\t\t\t\tn = 2 * N - 1;\n\t\t\t\t//\n\t\t\t\tnPrime = 0;\n\t\t\t\tleafs = [];\n\t\t\t\tphotoCounter = 0;\n\t\t\t\trootNode = new Node();\n\n\t\t\t\tgetRandomTree(); // populate rootNode\n\t\t\t\ttraverseAndAssignData(rootNode); // assign data to nodes (H/V, p1,p2...pN)\n\n\t\t\t\t//treeStr = \"\";\n\t\t\t\t//nodeToString(rootNode); // populate treeStr\n\t\t\t\t//alert(treeStr);\n\n\t\t\t\ttraverseAndComputeBBPhotoNode(rootNode); // compute bounding box of terminal nodes (photos)\n\t\t\t\ttraverseAndComputeBBInteriorNode(rootNode); // compute bounding box of interior nodes\n\n\t\t\t\txVec = findAndSolveSytem(rootNode, \"constrainWidth\"); // // display result (solution vector containing the widths of each photos)\n\t\t\t\tif (!xVec) {\n\t\t\t\t\talert(\"no solution found !\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tuls = new Array(N); // upper left corner location of eah photos\n\t\t\t\trootNode.upperLeft = [sigma + beta, sigma + beta];\n\t\t\t\ttraverseAndComputeUpperLeft(rootNode);\n\n\t\t\t\t/*\n\t\t\t\tvar bestCoverage = 0;\n\t\t\t\tvar bestUls;\n\t\t\t\tvar bestXVec;\n\t\t\t\tvar masterIter = 0;\n\t\t\t\tvar mustRerun = false;\n\t\t\t\t\t\n\t\t\t\twhile ((masterIter++) < maxIters)\n\t\t\t\t{\n\t\t\t\t\tnPrime = 0;\n\t\t\t\t\tleafs = [];\n\t\t\t\t\tphotoCounter = 0;\n\t\t\t\t\trootNode = new Node();\n\t\t\t\t\t\t\n\t\t\t\t\tgetRandomTree(); // populate rootNode\n\t\t\t\t\ttraverseAndAssignData(rootNode); // assign data to nodes (H/V, p1,p2...pN)\n\t\t\t\t\t\t\n\t\t\t\t\t//treeStr = \"\";\n\t\t\t\t\t//nodeToString(rootNode); // populate treeStr\n\t\t\t\t\t//alert(treeStr);\n\t\t\t\t\t\n\t\t\t\t\ttraverseAndComputeBBPhotoNode(rootNode); // compute bounding box of terminal nodes (photos)\n\t\t\t\t\ttraverseAndComputeBBInteriorNode(rootNode); // compute bounding box of interior nodes\n\t\t\t\t\t\n\t\t\t\t\txVec = findAndSolveSytem(rootNode, \"constrainWidth\");// // display result (solution vector containing the widths of each photos)\n\t\t\t\t\tif (!xVec)\n\t\t\t\t\t{\n\t\t\t\t\t\talert(\"no sol !\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tuls = new Array(N); // upper left corner location of eah photos\n\t\t\t\t\trootNode.upperLeft = [sigma+beta, sigma+beta];\n\t\t\t\t\ttraverseAndComputeUpperLeft(rootNode);\n\t\t\t\t\t\n\t\t\t\t\tvar coverage = computeCoverage();\n\t\t\t\t\t//alert(\"initial coverage: \" + (100*coverage) + \"%\");\n\t\t\t\t\t\n\t\t\t\t\tvar delta = Math.abs(coverage - 1);\n\t\t\t\t\tvar bestDelta = Math.abs(bestCoverage - 1);\n\t\t\t\t\tif (delta < bestDelta)\n\t\t\t\t\t{\n\t\t\t\t\t\tbestRootNode = rootNode;\n\t\t\t\t\t\tbestCoverage = coverage;\n\t\t\t\t\t\tbestXVec = xVec;\n\t\t\t\t\t\tbestUls = uls;\n\t\t\t\t\t\t\n\t\t\t\t\t\twriteLn(\"masterIter: \" + (masterIter) + \" bestCoverage: \" + (100*coverage).toFixed(2) + \"%\");\n\t\t\t\t\t\n\t\t\t\t\t\tif (bestCoverage > 0.99 && bestCoverage < 1.01) // == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twriteLn(\"iters (break):\" + iter + \" coverage:\" + (100*coverage).toFixed(2) + \"%\");\n\t\t\t\t\t\t\t//alert(\"coverage reached 1, stop at iter \" + iter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//alert(\"masterIter: \" + masterIter + \" coverage: \" + (100*coverage).toFixed(2) + \"%\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\txVec = bestXVec;\n\t\t\t\tuls = bestUls;\n\t\t\t\twriteLn(\"masterIter:\" + masterIter + \" coverage:\" + (100*bestCoverage).toFixed(2) + \"%\");\n\t\t\t\t*/\n\t\t\t\tapp.beginUndoGroup(\"Collage\");\n\t\t\t\tscaleAndPositionLayers(xVec, uls); //(bestXVec,bestUls); \n\t\t\t\tif (fitComp) {\n\t\t\t\t\tfitCompToCollage(xVec, uls);\n\t\t\t\t}\n\t\t\t\tapp.endUndoGroup();\n\n\n\t\t\t\tvar endTime = new Date().getTime();\n\t\t\t\tvar executionTime = (endTime - startTime) / 1000.0;\n\t\t\t\t/*alert*/\n\t\t\t\twriteLn(\"Completed in \" + executionTime + \"s\");\n\t\t\t}\n\n\t\t\tfunction createUI(thisObj) {\n\t\t\t\tvar pal = (thisObj instanceof Panel) ? thisObj : new Window(\"palette\", \"Collage\", undefined, {\n\t\t\t\t\tresizeable: true\n\t\t\t\t});\n\n\t\t\t\tvar res =\n\t\t\t\t\t\"group { orientation:'column', alignment:['fill','fill'], alignChildren:['fill','fill'], \\\ngr1: Group { \\\n\taboutBtn: Button { text:'?', preferredSize:[25,20], alignment:['right','top'] } \\\n}, \\\ngr2: Group { orientation:'row', alignment:['fill','top'], \\\n\tborderSt: StaticText { text:'Border:' }, \\\n\tborderEt: EditText { alignment:['fill','top'], characters:5, text:'\" + beta + \"' } \\\n}, \\\ngr3: Group { alignment:['left','top'], \\\n\tfitCompCb: Checkbox { text:'Fit Comp to Collage', value:true } \\\n}, \\\ngr4: Group { alignment:['fill','top'], \\\n\tcreateBtn: Button { text:'Create', alignment:['fill','top'] } \\\n} \\\n}\";\n\t\t\t\tpal.gr = pal.add(res);\n\n\t\t\t\tvar aboutStr =\n\t\t\t\t\t\"Collage.jsx\\r\" +\n\t\t\t\t\t\"Copyright (c) 2012 Motion Boutique\\r\\r\" +\n\t\t\t\t\t\"Layout selected layers in a collage or photobook style. \" +\n\t\t\t\t\t\"Layers are arranged to fit in a rectangle area (with same width as the comp) while maintainig their aspect ratio. \" +\n\t\t\t\t\t\"You can specify a border in pixels around each layer.\";\n\n\t\t\t\tpal.onResize = pal.onResizing = function() {\n\t\t\t\t\tthis.layout.resize();\n\t\t\t\t};\n\t\t\t\tpal.gr.gr1.aboutBtn.onClick = function() {\n\t\t\t\t\talert(aboutStr);\n\t\t\t\t};\n\t\t\t\tpal.gr.gr2.borderEt.onChange = function() {\n\t\t\t\t\tbeta = parseFloat(this.text);\n\t\t\t\t};\n\t\t\t\tpal.gr.gr3.fitCompCb.onClick = function() {\n\t\t\t\t\tfitComp = this.value;\n\t\t\t\t};\n\t\t\t\tpal.gr.gr4.createBtn.onClick = function() {\n\t\t\t\t\trun();\n\t\t\t\t};\n\n\t\t\t\t// show user interface\n\t\t\t\tif (pal instanceof Window) {\n\t\t\t\t\tpal.center();\n\t\t\t\t\tpal.show();\n\t\t\t\t} else {\n\t\t\t\t\tpal.layout.layout(true);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tvar W;\n\t\t\tvar H;\n\t\t\tvar photoOriginalSizes;\n\t\t\tvar N;\n\t\t\tvar beta = borderSize; //5; // photo border\n\t\t\tvar sigma = 0; //10; // space between photos\n\t\t\t//var maxIters = 10;\n\t\t\tvar fitComp = fitToComp;\n\t\t\tvar n;\n\t\t\tvar leafs;\n\t\t\tvar nPrime;\n\t\t\tvar treeStr;\n\t\t\tvar photoCounter;\n\t\t\tvar rootNode;\n\t\t\tvar xVec;\n\t\t\tvar uls;\n\t\t\tvar collageW;\n\t\t\tvar collageH;\n\n\t\t// \tcreateUI(this);\n\n\n\t\t\t// numericjs\n\t\t\tvar numeric = (typeof exports === \"undefined\") ? (function numeric() {}) : (exports);\n\t\t\tif (typeof global !== \"undefined\") {\n\t\t\t\tglobal.numeric = numeric;\n\t\t\t}\n\n\t\t\tnumeric.version = \"1.2.2\";\n\n\t\t\t// 1. Utility functions\n\t\t\tnumeric.bench = function bench(f, interval) {\n\t\t\t\tvar t1, t2, n, i;\n\t\t\t\tif (typeof interval === \"undefined\") {\n\t\t\t\t\tinterval = 15;\n\t\t\t\t}\n\t\t\t\tn = 1;\n\t\t\t\tt1 = new Date();\n\t\t\t\twhile (1) {\n\t\t\t\t\tn *= 2;\n\t\t\t\t\tfor (i = n; i > 3; i -= 4) {\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tf();\n\t\t\t\t\t}\n\t\t\t\t\twhile (i > 0) {\n\t\t\t\t\t\tf();\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tt2 = new Date();\n\t\t\t\t\tif (t2 - t1 > interval) break;\n\t\t\t\t}\n\t\t\t\tfor (i = n; i > 3; i -= 4) {\n\t\t\t\t\tf();\n\t\t\t\t\tf();\n\t\t\t\t\tf();\n\t\t\t\t\tf();\n\t\t\t\t}\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\tf();\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tt2 = new Date();\n\t\t\t\treturn 1000 * (3 * n - 1) / (t2 - t1);\n\t\t\t};\n\n\t\t\t/* \n\t\t\t * IE doesn't have a global eval that works?\n\t\t\t * This apparently returns nothing: window.execScript('function () {}').            \n\t\t\t * Other things that don't work: window.execScript('foo = eval(\"function () {}\");')\n\t\t\t */\n\t\t\tif (1 || typeof window === \"undefined\" || typeof window.execScript !== \"undefined\") numeric.Function = Function;\n\t\t\telse numeric.Function = function() {\n\t\t\t\tvar foo = '(function (';\n\t\t\t\tfor (var k = 0; k < arguments.length - 1; ++k) {\n\t\t\t\t\tif (k > 0) foo += ',';\n\t\t\t\t\tfoo += arguments[k];\n\t\t\t\t}\n\t\t\t\tfoo += ') { \\n' + arguments[k] + '\\n});';\n\t\t\t\treturn window.eval(foo);\n\t\t\t};\n\n\t\t\tnumeric.precision = 4;\n\t\t\tnumeric.largeArray = 50;\n\n\t\t\tnumeric.prettyPrint = function prettyPrint(x) {\n\t\t\t\tfunction fmtnum(x) {\n\t\t\t\t\tif (x === 0) {\n\t\t\t\t\t\treturn '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\treturn 'NaN';\n\t\t\t\t\t}\n\t\t\t\t\tif (x < 0) {\n\t\t\t\t\t\treturn '-' + fmtnum(-x);\n\t\t\t\t\t}\n\t\t\t\t\tif (isFinite(x)) {\n\t\t\t\t\t\tvar scale = Math.floor(Math.log(x) / Math.log(10));\n\t\t\t\t\t\tvar normalized = x / Math.pow(10, scale);\n\t\t\t\t\t\tvar basic = normalized.toPrecision(numeric.precision);\n\t\t\t\t\t\tif (parseFloat(basic) === 10) {\n\t\t\t\t\t\t\tscale++;\n\t\t\t\t\t\t\tnormalized = 1;\n\t\t\t\t\t\t\tbasic = normalized.toPrecision(numeric.precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn parseFloat(basic).toString() + 'e' + scale.toString();\n\t\t\t\t\t}\n\t\t\t\t\treturn 'Infinity';\n\t\t\t\t}\n\t\t\t\tvar ret = [];\n\n\t\t\t\tfunction foo(x) {\n\t\t\t\t\tvar k;\n\t\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\t\tret.push(Array(numeric.precision + 8).join(' '));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"string\") {\n\t\t\t\t\t\tret.push('\"' + x + '\"');\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"boolean\") {\n\t\t\t\t\t\tret.push(x.toString());\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"number\") {\n\t\t\t\t\t\tvar a = fmtnum(x);\n\t\t\t\t\t\tvar b = x.toPrecision(numeric.precision);\n\t\t\t\t\t\tvar c = parseFloat(x.toString()).toString();\n\t\t\t\t\t\tvar d = [a, b, c, parseFloat(b).toString(), parseFloat(c).toString()];\n\t\t\t\t\t\tfor (k = 1; k < d.length; k++) {\n\t\t\t\t\t\t\tif (d[k].length < a.length) a = d[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret.push(Array(numeric.precision + 8 - a.length).join(' ') + a);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (x === null) {\n\t\t\t\t\t\tret.push(\"null\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"function\") {\n\t\t\t\t\t\tret.push(x.toString());\n\t\t\t\t\t\tvar flag = false;\n\t\t\t\t\t\tfor (k in x) {\n\t\t\t\t\t\t\tif (x.hasOwnProperty(k)) {\n\t\t\t\t\t\t\t\tif (flag) ret.push(',\\n');\n\t\t\t\t\t\t\t\telse ret.push('\\n{');\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tret.push(k);\n\t\t\t\t\t\t\t\tret.push(': \\n');\n\t\t\t\t\t\t\t\tfoo(x[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) ret.push('}\\n');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (x instanceof Array) {\n\t\t\t\t\t\tif (x.length > numeric.largeArray) {\n\t\t\t\t\t\t\tret.push('...Large Array...');\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar flag = false;\n\t\t\t\t\t\tret.push('[');\n\t\t\t\t\t\tfor (k = 0; k < x.length; k++) {\n\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\tret.push(',');\n\t\t\t\t\t\t\t\tif (flag) ret.push('\\n ');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = foo(x[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret.push(']');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tret.push('{');\n\t\t\t\t\tvar flag = false;\n\t\t\t\t\tfor (k in x) {\n\t\t\t\t\t\tif (x.hasOwnProperty(k)) {\n\t\t\t\t\t\t\tif (flag) ret.push(',\\n');\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tret.push(k);\n\t\t\t\t\t\t\tret.push(': \\n');\n\t\t\t\t\t\t\tfoo(x[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret.push('}');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfoo(x);\n\t\t\t\treturn ret.join('');\n\t\t\t};\n\n\t\t\tnumeric.parseDate = function parseDate(d) {\n\t\t\t\tfunction foo(d) {\n\t\t\t\t\tif (typeof d === 'string') {\n\t\t\t\t\t\treturn Date.parse(d.replace(/-/g, '/'));\n\t\t\t\t\t}\n\t\t\t\t\tif (!(d instanceof Array)) {\n\t\t\t\t\t\tthrow new Error(\"parseDate: parameter must be arrays of strings\");\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\tk;\n\t\t\t\t\tfor (k = 0; k < d.length; k++) {\n\t\t\t\t\t\tret[k] = foo(d[k]);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn foo(d);\n\t\t\t};\n\n\t\t\tnumeric.parseFloat = function parseFloat_(d) {\n\t\t\t\tfunction foo(d) {\n\t\t\t\t\tif (typeof d === 'string') {\n\t\t\t\t\t\treturn parseFloat(d);\n\t\t\t\t\t}\n\t\t\t\t\tif (!(d instanceof Array)) {\n\t\t\t\t\t\tthrow new Error(\"parseFloat: parameter must be arrays of strings\");\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\tk;\n\t\t\t\t\tfor (k = 0; k < d.length; k++) {\n\t\t\t\t\t\tret[k] = foo(d[k]);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn foo(d);\n\t\t\t};\n\n\t\t\tnumeric.parseCSV = function parseCSV(t) {\n\t\t\t\tvar foo = t.split('\\n');\n\t\t\t\tvar j, k;\n\t\t\t\tvar ret = [];\n\t\t\t\tvar pat = /(([^'\",]*)|('[^']*')|(\"[^\"]*\")),/g;\n\t\t\t\tvar patnum = /^\\s*(([+-]?[0-9]+(\\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\\.[0-9]+)?(e[+-]?[0-9]+)?))\\s*$/;\n\t\t\t\tvar stripper = function(n) {\n\t\t\t\t\treturn n.substr(0, n.length - 1);\n\t\t\t\t};\n\t\t\t\tvar count = 0;\n\t\t\t\tfor (k = 0; k < foo.length; k++) {\n\t\t\t\t\tvar bar = (foo[k] + \",\").match(pat),\n\t\t\t\t\t\tbaz;\n\t\t\t\t\tif (bar.length > 0) {\n\t\t\t\t\t\tret[count] = [];\n\t\t\t\t\t\tfor (j = 0; j < bar.length; j++) {\n\t\t\t\t\t\t\tbaz = stripper(bar[j]);\n\t\t\t\t\t\t\tif (patnum.test(baz)) {\n\t\t\t\t\t\t\t\tret[count][j] = parseFloat(baz);\n\t\t\t\t\t\t\t} else ret[count][j] = baz;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.toCSV = function toCSV(A) {\n\t\t\t\tvar s = numeric.dim(A);\n\t\t\t\tvar i, j, m, n, row, ret;\n\t\t\t\tm = s[0];\n\t\t\t\tn = s[1];\n\t\t\t\tret = [];\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\trow = [];\n\t\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\t\trow[j] = A[i][j].toString();\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = row.join(', ');\n\t\t\t\t}\n\t\t\t\treturn ret.join('\\n') + '\\n';\n\t\t\t};\n\n\t\t\tnumeric.getURL = function getURL(url) {\n\t\t\t\tvar client = new XMLHttpRequest();\n\t\t\t\tclient.open(\"GET\", url, false);\n\t\t\t\tclient.send();\n\t\t\t\treturn client;\n\t\t\t};\n\n\t\t\tnumeric.imageURL = function imageURL(img) {\n\t\t\t\tfunction base64(A) {\n\t\t\t\t\tvar n = A.length,\n\t\t\t\t\t\ti, x, y, z, p, q, r, s;\n\t\t\t\t\tvar key = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\t\t\t\t\tvar ret = \"\";\n\t\t\t\t\tfor (i = 0; i < n; i += 3) {\n\t\t\t\t\t\tx = A[i];\n\t\t\t\t\t\ty = A[i + 1];\n\t\t\t\t\t\tz = A[i + 2];\n\t\t\t\t\t\tp = x >> 2;\n\t\t\t\t\t\tq = ((x & 3) << 4) + (y >> 4);\n\t\t\t\t\t\tr = ((y & 15) << 2) + (z >> 6);\n\t\t\t\t\t\ts = z & 63;\n\t\t\t\t\t\tif (i + 1 >= n) {\n\t\t\t\t\t\t\tr = s = 64;\n\t\t\t\t\t\t} else if (i + 2 >= n) {\n\t\t\t\t\t\t\ts = 64;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tfunction crc32Array(a, from, to) {\n\t\t\t\t\tif (typeof from === \"undefined\") {\n\t\t\t\t\t\tfrom = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof to === \"undefined\") {\n\t\t\t\t\t\tto = a.length;\n\t\t\t\t\t}\n\t\t\t\t\tvar table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n\t\t\t\t\t\t0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n\t\t\t\t\t\t0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n\t\t\t\t\t\t0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n\t\t\t\t\t\t0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n\t\t\t\t\t\t0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n\t\t\t\t\t\t0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n\t\t\t\t\t\t0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n\t\t\t\t\t\t0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n\t\t\t\t\t\t0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n\t\t\t\t\t\t0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n\t\t\t\t\t\t0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n\t\t\t\t\t\t0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n\t\t\t\t\t\t0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n\t\t\t\t\t\t0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n\t\t\t\t\t\t0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n\t\t\t\t\t\t0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n\t\t\t\t\t\t0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n\t\t\t\t\t\t0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n\t\t\t\t\t\t0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n\t\t\t\t\t\t0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n\t\t\t\t\t\t0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n\t\t\t\t\t\t0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n\t\t\t\t\t\t0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n\t\t\t\t\t\t0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n\t\t\t\t\t\t0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n\t\t\t\t\t\t0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n\t\t\t\t\t\t0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n\t\t\t\t\t\t0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n\t\t\t\t\t\t0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n\t\t\t\t\t\t0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n\t\t\t\t\t\t0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n\t\t\t\t\t];\n\n\t\t\t\t\tvar crc = -1,\n\t\t\t\t\t\ty = 0,\n\t\t\t\t\t\tn = a.length,\n\t\t\t\t\t\ti;\n\n\t\t\t\t\tfor (i = from; i < to; i++) {\n\t\t\t\t\t\ty = (crc ^ a[i]) & 0xFF;\n\t\t\t\t\t\tcrc = (crc >>> 8) ^ table[y];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn crc ^ (-1);\n\t\t\t\t}\n\n\t\t\t\tvar h = img[0].length,\n\t\t\t\t\tw = img[0][0].length,\n\t\t\t\t\ts1, s2, next, k, length, a, b, i, j, adler32, crc32;\n\t\t\t\tvar stream = [\n\t\t\t\t\t137, 80, 78, 71, 13, 10, 26, 10, //  0: PNG signature\n\t\t\t\t\t0, 0, 0, 13, //  8: IHDR Chunk length\n\t\t\t\t\t73, 72, 68, 82, // 12: \"IHDR\" \n\t\t\t\t\t(w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255, // 16: Width\n\t\t\t\t\t(h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h & 255, // 20: Height\n\t\t\t\t\t8, // 24: bit depth\n\t\t\t\t\t2, // 25: RGB\n\t\t\t\t\t0, // 26: deflate\n\t\t\t\t\t0, // 27: no filter\n\t\t\t\t\t0, // 28: no interlace\n\t\t\t\t\t-1, -2, -3, -4, // 29: CRC\n\t\t\t\t\t-5, -6, -7, -8, // 33: IDAT Chunk length\n\t\t\t\t\t73, 68, 65, 84, // 37: \"IDAT\"\n\t\t\t\t\t// RFC 1950 header starts here\n\t\t\t\t\t8, // 41: RFC1950 CMF\n\t\t\t\t\t29 // 42: RFC1950 FLG\n\t\t\t\t];\n\t\t\t\tcrc32 = crc32Array(stream, 12, 29);\n\t\t\t\tstream[29] = (crc32 >> 24) & 255;\n\t\t\t\tstream[30] = (crc32 >> 16) & 255;\n\t\t\t\tstream[31] = (crc32 >> 8) & 255;\n\t\t\t\tstream[32] = (crc32) & 255;\n\t\t\t\ts1 = 1;\n\t\t\t\ts2 = 0;\n\t\t\t\tfor (i = 0; i < h; i++) {\n\t\t\t\t\tif (i < h - 1) {\n\t\t\t\t\t\tstream.push(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstream.push(1);\n\t\t\t\t\t}\n\t\t\t\t\ta = (3 * w + 1 + (i === 0)) & 255;\n\t\t\t\t\tb = ((3 * w + 1 + (i === 0)) >> 8) & 255;\n\t\t\t\t\tstream.push(a);\n\t\t\t\t\tstream.push(b);\n\t\t\t\t\tstream.push((~a) & 255);\n\t\t\t\t\tstream.push((~b) & 255);\n\t\t\t\t\tif (i === 0) stream.push(0);\n\t\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\t\tfor (k = 0; k < 3; k++) {\n\t\t\t\t\t\t\ta = img[k][i][j];\n\t\t\t\t\t\t\tif (a > 255) a = 255;\n\t\t\t\t\t\t\telse if (a < 0) a = 0;\n\t\t\t\t\t\t\telse a = Math.round(a);\n\t\t\t\t\t\t\ts1 = (s1 + a) % 65521;\n\t\t\t\t\t\t\ts2 = (s2 + s1) % 65521;\n\t\t\t\t\t\t\tstream.push(a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstream.push(0);\n\t\t\t\t}\n\t\t\t\tadler32 = (s2 << 16) + s1;\n\t\t\t\tstream.push((adler32 >> 24) & 255);\n\t\t\t\tstream.push((adler32 >> 16) & 255);\n\t\t\t\tstream.push((adler32 >> 8) & 255);\n\t\t\t\tstream.push((adler32) & 255);\n\t\t\t\tlength = stream.length - 41;\n\t\t\t\tstream[33] = (length >> 24) & 255;\n\t\t\t\tstream[34] = (length >> 16) & 255;\n\t\t\t\tstream[35] = (length >> 8) & 255;\n\t\t\t\tstream[36] = (length) & 255;\n\t\t\t\tcrc32 = crc32Array(stream, 37);\n\t\t\t\tstream.push((crc32 >> 24) & 255);\n\t\t\t\tstream.push((crc32 >> 16) & 255);\n\t\t\t\tstream.push((crc32 >> 8) & 255);\n\t\t\t\tstream.push((crc32) & 255);\n\t\t\t\tstream.push(0);\n\t\t\t\tstream.push(0);\n\t\t\t\tstream.push(0);\n\t\t\t\tstream.push(0);\n\t\t\t\t//    a = stream.length;\n\t\t\t\tstream.push(73); // I\n\t\t\t\tstream.push(69); // E\n\t\t\t\tstream.push(78); // N\n\t\t\t\tstream.push(68); // D\n\t\t\t\tstream.push(174); // CRC1\n\t\t\t\tstream.push(66); // CRC2\n\t\t\t\tstream.push(96); // CRC3\n\t\t\t\tstream.push(130); // CRC4\n\t\t\t\treturn 'data:image/png;base64,' + base64(stream);\n\t\t\t};\n\n\t\t\t// 2. Linear algebra with Arrays.\n\t\t\tnumeric._dim = function _dim(x) {\n\t\t\t\tvar ret = [];\n\t\t\t\twhile (typeof x === \"object\") {\n\t\t\t\t\tret.push(x.length);\n\t\t\t\t\tx = x[0];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dim = function dim(x) {\n\t\t\t\tvar y, z;\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\ty = x[0];\n\t\t\t\t\tif (typeof y === \"object\") {\n\t\t\t\t\t\tz = y[0];\n\t\t\t\t\t\tif (typeof z === \"object\") {\n\t\t\t\t\t\t\treturn numeric._dim(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [x.length, y.length];\n\t\t\t\t\t}\n\t\t\t\t\treturn [x.length];\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t};\n\n\t\t\tnumeric.mapreduce = function mapreduce(body, init) {\n\t\t\t\treturn numeric.Function('x', 'accum', '_s', '_k',\n\t\t\t\t\t'if(typeof accum === \"undefined\") accum = ' + init + ';\\n' +\n\t\t\t\t\t'if(typeof x === \"number\") { var xi = x; ' + body + '; return accum; }\\n' +\n\t\t\t\t\t'if(typeof _s === \"undefined\") _s = numeric.dim(x);\\n' +\n\t\t\t\t\t'if(typeof _k === \"undefined\") _k = 0;\\n' +\n\t\t\t\t\t'var _n = _s[_k];\\n' +\n\t\t\t\t\t'var i,xi;\\n' +\n\t\t\t\t\t'if(_k < _s.length-1) {\\n' +\n\t\t\t\t\t'    for(i=_n-1;i>=0;i--) {\\n' +\n\t\t\t\t\t'        accum = arguments.callee(x[i],accum,_s,_k+1);\\n' +\n\t\t\t\t\t'    }' +\n\t\t\t\t\t'    return accum;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'for(i=_n-1;i>=1;i-=2) { \\n' +\n\t\t\t\t\t'    xi = x[i];\\n' +\n\t\t\t\t\t'    ' + body + ';\\n' +\n\t\t\t\t\t'    xi = x[i-1];\\n' +\n\t\t\t\t\t'    ' + body + ';\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'if(i === 0) {\\n' +\n\t\t\t\t\t'    xi = x[i];\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return accum;'\n\t\t\t\t);\n\t\t\t};\n\n\n\t\t\tnumeric.same = function same(x, y) {\n\t\t\t\tvar i, n;\n\t\t\t\tif (!(x instanceof Array) || !(y instanceof Array)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tn = x.length;\n\t\t\t\tif (n !== y.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tif (x[i] === y[i]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x[i] === \"object\") {\n\t\t\t\t\t\tif (!same(x[i], y[i])) return false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tnumeric.rep = function rep(s, v, k) {\n\t\t\t\tif (typeof k === \"undefined\") {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tvar n = s[k],\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\ti;\n\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\tfor (i = n - 2; i >= 0; i -= 2) {\n\t\t\t\t\t\tret[i + 1] = v;\n\t\t\t\t\t\tret[i] = v;\n\t\t\t\t\t}\n\t\t\t\t\tif (i === -1) {\n\t\t\t\t\t\tret[0] = v;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\t\t\tret[i] = numeric.rep(s, v, k + 1);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\n\t\t\tnumeric.dotMMsmall = function dotMMsmall(x, y) {\n\t\t\t\tvar i, j, k, p, q, r, ret, foo, bar, woo, i0, k0, p0, r0;\n\t\t\t\tp = x.length;\n\t\t\t\tq = y.length;\n\t\t\t\tr = y[0].length;\n\t\t\t\tret = Array(p);\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\tfoo = Array(r);\n\t\t\t\t\tbar = x[i];\n\t\t\t\t\tfor (k = r - 1; k >= 0; k--) {\n\t\t\t\t\t\twoo = bar[q - 1] * y[q - 1][k];\n\t\t\t\t\t\tfor (j = q - 2; j >= 1; j -= 2) {\n\t\t\t\t\t\t\ti0 = j - 1;\n\t\t\t\t\t\t\twoo += bar[j] * y[j][k] + bar[i0] * y[i0][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\t\twoo += bar[0] * y[0][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoo[k] = woo;\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = foo;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric._getCol = function _getCol(A, j, x) {\n\t\t\t\tvar n = A.length,\n\t\t\t\t\ti;\n\t\t\t\tfor (i = n - 1; i > 0; --i) {\n\t\t\t\t\tx[i] = A[i][j];\n\t\t\t\t\t--i;\n\t\t\t\t\tx[i] = A[i][j];\n\t\t\t\t}\n\t\t\t\tif (i === 0) x[0] = A[0][j];\n\t\t\t};\n\t\t\tnumeric.dotMMbig = function dotMMbig(x, y) {\n\t\t\t\tvar gc = numeric._getCol,\n\t\t\t\t\tp = y.length,\n\t\t\t\t\tv = Array(p);\n\t\t\t\tvar m = x.length,\n\t\t\t\t\tn = y[0].length,\n\t\t\t\t\tA = new Array(m),\n\t\t\t\t\txj;\n\t\t\t\tvar i, j, k, z;\n\t\t\t\t--p;\n\t\t\t\t--m;\n\t\t\t\tfor (i = m; i !== -1; --i) A[i] = Array(n);\n\t\t\t\t--n;\n\t\t\t\tfor (i = n; i !== -1; --i) {\n\t\t\t\t\tgc(y, i, v);\n\t\t\t\t\tfor (j = m; j !== -1; --j) {\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\txj = x[j];\n\t\t\t\t\t\tfor (k = p; k > 0; --k) {\n\t\t\t\t\t\t\tz += xj[k] * v[k];\n\t\t\t\t\t\t\t--k;\n\t\t\t\t\t\t\tz += xj[k] * v[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k === 0) z += xj[0] * v[0];\n\t\t\t\t\t\tA[j][i] = z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\n\t\t\tnumeric.dotMV = function dotMV(x, y) {\n\t\t\t\tvar p = x.length,\n\t\t\t\t\tq = y.length,\n\t\t\t\t\ti;\n\t\t\t\tvar ret = Array(p),\n\t\t\t\t\tdotVV = numeric.dotVV;\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\tret[i] = dotVV(x[i], y);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dotVM = function dotVM(x, y) {\n\t\t\t\tvar i, j, k, p, q, r, ret, foo, bar, woo, i0, k0, p0, r0, s1, s2, s3, baz, accum;\n\t\t\t\tp = x.length;\n\t\t\t\tq = y[0].length;\n\t\t\t\tret = Array(q);\n\t\t\t\tfor (k = q - 1; k >= 0; k--) {\n\t\t\t\t\twoo = x[p - 1] * y[p - 1][k];\n\t\t\t\t\tfor (j = p - 2; j >= 1; j -= 2) {\n\t\t\t\t\t\ti0 = j - 1;\n\t\t\t\t\t\twoo += x[j] * y[j][k] + x[i0] * y[i0][k];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\twoo += x[0] * y[0][k];\n\t\t\t\t\t}\n\t\t\t\t\tret[k] = woo;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dotVV = function dotVV(x, y) {\n\t\t\t\tvar i, n = x.length,\n\t\t\t\t\ti1, ret = x[n - 1] * y[n - 1];\n\t\t\t\tfor (i = n - 2; i >= 1; i -= 2) {\n\t\t\t\t\ti1 = i - 1;\n\t\t\t\t\tret += x[i] * y[i] + x[i1] * y[i1];\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tret += x[0] * y[0];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dot = function dot(x, y) {\n\t\t\t\tvar d = numeric.dim;\n\t\t\t\tswitch (d(x).length * 1000 + d(y).length) {\n\t\t\t\t\tcase 2002:\n\t\t\t\t\t\tif (y.length < 10) return numeric.dotMMsmall(x, y);\n\t\t\t\t\t\telse return numeric.dotMMbig(x, y);\n\t\t\t\t\tcase 2001:\n\t\t\t\t\t\treturn numeric.dotMV(x, y);\n\t\t\t\t\tcase 1002:\n\t\t\t\t\t\treturn numeric.dotVM(x, y);\n\t\t\t\t\tcase 1001:\n\t\t\t\t\t\treturn numeric.dotVV(x, y);\n\t\t\t\t\tcase 1000:\n\t\t\t\t\t\treturn numeric.mulVS(x, y);\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn numeric.mulSV(x, y);\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn x * y;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('numeric.dot only works on vectors and matrices');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnumeric.diag = function diag(d) {\n\t\t\t\tvar i, i1, j, n = d.length,\n\t\t\t\t\tA = Array(n),\n\t\t\t\t\tAi;\n\t\t\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\t\t\tAi = Array(n);\n\t\t\t\t\ti1 = i + 2;\n\t\t\t\t\tfor (j = n - 1; j >= i1; j -= 2) {\n\t\t\t\t\t\tAi[j] = 0;\n\t\t\t\t\t\tAi[j - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (j > i) {\n\t\t\t\t\t\tAi[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tAi[i] = d[i];\n\t\t\t\t\tfor (j = i - 1; j >= 1; j -= 2) {\n\t\t\t\t\t\tAi[j] = 0;\n\t\t\t\t\t\tAi[j - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tAi[0] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tA[i] = Ai;\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\t\t\tnumeric.getDiag = function(A) {\n\t\t\t\tvar n = Math.min(A.length, A[0].length),\n\t\t\t\t\ti, ret = Array(n);\n\t\t\t\tfor (i = n - 1; i >= 1; --i) {\n\t\t\t\t\tret[i] = A[i][i];\n\t\t\t\t\t--i;\n\t\t\t\t\tret[i] = A[i][i];\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tret[0] = A[0][0];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.identity = function identity(n) {\n\t\t\t\treturn numeric.diag(numeric.rep([n], 1));\n\t\t\t};\n\t\t\tnumeric.pointwise = function pointwise(params, body, setup) {\n\t\t\t\tif (typeof setup === \"undefined\") {\n\t\t\t\t\tsetup = \"\";\n\t\t\t\t}\n\t\t\t\tvar fun = [];\n\t\t\t\tvar k;\n\t\t\t\tvar avec = /\\[i\\]$/,\n\t\t\t\t\tp, thevec = '';\n\t\t\t\tfor (k = 0; k < params.length; k++) {\n\t\t\t\t\tif (avec.test(params[k])) {\n\t\t\t\t\t\tp = params[k].substring(0, params[k].length - 3);\n\t\t\t\t\t\tthevec = p;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = params[k];\n\t\t\t\t\t}\n\t\t\t\t\tfun.push(p);\n\t\t\t\t}\n\t\t\t\tfun[params.length] = '_s';\n\t\t\t\tfun[params.length + 1] = '_k';\n\t\t\t\tfun[params.length + 2] = (\n\t\t\t\t\t'if(typeof _s === \"undefined\") _s = numeric.dim(' + thevec + ');\\n' +\n\t\t\t\t\t'if(typeof _k === \"undefined\") _k = 0;\\n' +\n\t\t\t\t\t'var _n = _s[_k];\\n' +\n\t\t\t\t\t'var i, ret = Array(_n);\\n' +\n\t\t\t\t\t'if(_k < _s.length-1) {\\n' +\n\t\t\t\t\t'    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(' + params.join(',') + ',_s,_k+1);\\n' +\n\t\t\t\t\t'    return ret;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\tsetup + '\\n' +\n\t\t\t\t\t'for(i=_n-1;i>=3;--i) { \\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'while(i>=0) {\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return ret;'\n\t\t\t\t);\n\t\t\t\treturn numeric.Function.apply(null, fun);\n\t\t\t};\n\n\t\t\tnumeric._biforeach = (function _biforeach(x, y, s, k, f) {\n\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\tf(x, y);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar i, n = s[k];\n\t\t\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\t\t\t_biforeach(x[i], y[i], s, k + 1, f);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tnumeric.anyV = numeric.mapreduce('if(xi) return true;', 'false');\n\t\t\tnumeric.allV = numeric.mapreduce('if(!xi) return false;', 'true');\n\t\t\tnumeric.any = function(x) {\n\t\t\t\tif (typeof x.length === \"undefined\") return x;\n\t\t\t\treturn numeric.anyV(x);\n\t\t\t};\n\t\t\tnumeric.all = function(x) {\n\t\t\t\tif (typeof x.length === \"undefined\") return x;\n\t\t\t\treturn numeric.allV(x);\n\t\t\t};\n\n\t\t\tnumeric.ops2 = {\n\t\t\t\tadd: '+',\n\t\t\t\tsub: '-',\n\t\t\t\tmul: '*',\n\t\t\t\tdiv: '/',\n\t\t\t\tmod: '%',\n\t\t\t\tand: '&&',\n\t\t\t\tor: '||',\n\t\t\t\teq: '===',\n\t\t\t\tneq: '!==',\n\t\t\t\tlt: '<',\n\t\t\t\tgt: '>',\n\t\t\t\tleq: '<=',\n\t\t\t\tgeq: '>=',\n\t\t\t\tband: '&',\n\t\t\t\tbor: '|',\n\t\t\t\tbxor: '^',\n\t\t\t\tlshift: '<<',\n\t\t\t\trshift: '>>',\n\t\t\t\trrshift: '>>>'\n\t\t\t};\n\t\t\tnumeric.opseq = {\n\t\t\t\taddeq: '+=',\n\t\t\t\tsubeq: '-=',\n\t\t\t\tmuleq: '*=',\n\t\t\t\tdiveq: '/=',\n\t\t\t\tmodeq: '%=',\n\t\t\t\tlshifteq: '<<=',\n\t\t\t\trshifteq: '>>=',\n\t\t\t\trrshifteq: '>>>=',\n\t\t\t\tandeq: '&=',\n\t\t\t\toreq: '|=',\n\t\t\t\txoreq: '^='\n\t\t\t};\n\t\t\tnumeric.mathfuns = ['abs', 'acos', 'asin', 'atan', 'ceil', 'cos',\n\t\t\t\t'exp', 'floor', 'log', 'round', 'sin', 'sqrt', 'tan'\n\t\t\t];\n\t\t\tnumeric.ops1 = {\n\t\t\t\tneg: '-',\n\t\t\t\tnot: '!',\n\t\t\t\tbnot: '~'\n\t\t\t};\n\n\t\t\t(function() {\n\t\t\t\tvar i, o;\n\t\t\t\tfor (i in numeric.ops2) {\n\t\t\t\t\tif (numeric.ops2.hasOwnProperty(i)) {\n\t\t\t\t\t\to = numeric.ops2[i];\n\t\t\t\t\t\tnumeric[i + 'VV'] = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = x[i] ' + o + ' y[i];');\n\t\t\t\t\t\tnumeric[i + 'SV'] = numeric.pointwise(['x', 'y[i]'], 'ret[i] = x ' + o + ' y[i];');\n\t\t\t\t\t\tnumeric[i + 'VS'] = numeric.pointwise(['x[i]', 'y'], 'ret[i] = x[i] ' + o + ' y;');\n\t\t\t\t\t\tnumeric[i] = numeric.Function(\n\t\t\t\t\t\t\t'var n = arguments.length, i, x = arguments[0], y;\\n' +\n\t\t\t\t\t\t\t'var VV = numeric.' + i + 'VV, VS = numeric.' + i + 'VS, SV = numeric.' + i + 'SV;\\n' +\n\t\t\t\t\t\t\t'for(i=1;i!==n;++i) { \\n' +\n\t\t\t\t\t\t\t'  y = arguments[i];' +\n\t\t\t\t\t\t\t'  if(typeof x === \"object\") {\\n' +\n\t\t\t\t\t\t\t'      if(typeof y === \"object\") x = VV(x,y);\\n' +\n\t\t\t\t\t\t\t'      else x = VS(x,y);\\n' +\n\t\t\t\t\t\t\t'  } else if(typeof y === \"object\") x = SV(x,y);\\n' +\n\t\t\t\t\t\t\t'  else x = x ' + o + ' y;\\n' +\n\t\t\t\t\t\t\t'}\\nreturn x;\\n');\n\t\t\t\t\t\tnumeric[o] = numeric[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i in numeric.ops1) {\n\t\t\t\t\tif (numeric.ops1.hasOwnProperty(i)) {\n\t\t\t\t\t\to = numeric.ops1[i];\n\t\t\t\t\t\tnumeric[i + 'V'] = numeric.pointwise(['x[i]'], 'ret[i] = ' + o + 'x[i];');\n\t\t\t\t\t\tnumeric[i] = numeric.Function('x', 'if(typeof x === \"object\") return numeric.' + i + 'V(x);\\nreturn ' + o + '(x);');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < numeric.mathfuns.length; i++) {\n\t\t\t\t\to = numeric.mathfuns[i];\n\t\t\t\t\tnumeric[o + 'V'] = numeric.pointwise(['x[i]'], 'ret[i] = fun(x[i]);', 'var fun = Math.' + o + ';');\n\t\t\t\t\tnumeric[o] = numeric.Function('x', 'if(typeof x === \"object\") return numeric.' + o + 'V(x);\\nreturn Math.' + o + '(x);');\n\t\t\t\t}\n\t\t\t\tnumeric.isNaNV = numeric.pointwise(['x[i]'], 'ret[i] = isNaN(x[i]);');\n\t\t\t\tnumeric.isNaN = function isNaN(x) {\n\t\t\t\t\tif (typeof x === \"object\") return numeric.isNaNV(x);\n\t\t\t\t\treturn isNaN(x);\n\t\t\t\t};\n\t\t\t\tnumeric.isFiniteV = numeric.pointwise(['x[i]'], 'ret[i] = isFinite(x[i]);');\n\t\t\t\tnumeric.isFinite = function isNaN(x) {\n\t\t\t\t\tif (typeof x === \"object\") return numeric.isFiniteV(x);\n\t\t\t\t\treturn isFinite(x);\n\t\t\t\t};\n\t\t\t\tfor (i in numeric.opseq) {\n\t\t\t\t\tif (numeric.opseq.hasOwnProperty(i)) {\n\t\t\t\t\t\tnumeric[i + 'S'] = numeric.Function('x', 'y',\n\t\t\t\t\t\t\t'var n = x.length, i;\\n' +\n\t\t\t\t\t\t\t'for(i=n-1;i>=0;i--) x[i] ' + numeric.opseq[i] + ' y;');\n\t\t\t\t\t\tnumeric[i + 'V'] = numeric.Function('x', 'y',\n\t\t\t\t\t\t\t'var n = x.length, i;\\n' +\n\t\t\t\t\t\t\t'for(i=n-1;i>=0;i--) x[i] ' + numeric.opseq[i] + ' y[i];');\n\t\t\t\t\t\tnumeric[i] = numeric.Function('x', 'y',\n\t\t\t\t\t\t\t'var s = numeric.dim(x);\\n' +\n\t\t\t\t\t\t\t'if(typeof y === \"number\") { numeric._biforeach(x,y,s,0,numeric.' + i + 'S); return x; }\\n' +\n\t\t\t\t\t\t\t'numeric._biforeach(x,y,s,0,numeric.' + i + 'V);\\n' +\n\t\t\t\t\t\t\t'return x;');\n\t\t\t\t\t\tnumeric[numeric.opseq[i]] = numeric[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}());\n\n\t\t\tnumeric._f2 = ['atan2', 'pow', 'max', 'min'];\n\t\t\t((function() {\n\t\t\t\tvar i, j;\n\t\t\t\tfor (j = 0; j < numeric._f2.length; ++j) {\n\t\t\t\t\ti = numeric._f2[j];\n\t\t\t\t\tnumeric[i + 'VV'] = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = zz(x[i],y[i]);', 'var zz = Math.' + i + ';');\n\t\t\t\t\tnumeric[i + 'VS'] = numeric.pointwise(['x[i]', 'y'], 'ret[i] = zz(x[i],y);', 'var zz = Math.' + i + ';');\n\t\t\t\t\tnumeric[i + 'SV'] = numeric.pointwise(['x', 'y[i]'], 'ret[i] = zz(x,y[i]);', 'var zz = Math.' + i + ';');\n\t\t\t\t\tnumeric[i] = Function('x', 'y',\n\t\t\t\t\t\t'if(typeof x === \"object\") {\\n' +\n\t\t\t\t\t\t'    if(typeof y === \"object\") return numeric.' + i + 'VV(x,y);\\n' +\n\t\t\t\t\t\t'    return numeric.' + i + 'VS(x,y);\\n' +\n\t\t\t\t\t\t'}\\n' +\n\t\t\t\t\t\t'if (typeof y === \"object\") return numeric.' + i + 'SV(x,y);\\n' +\n\t\t\t\t\t\t'return Math.' + i + '(x,y);\\n');\n\t\t\t\t}\n\t\t\t})());\n\n\t\t\tnumeric.atan2VV = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = atan2(x[i],y[i]);', 'var atan2 = Math.atan2;');\n\t\t\tnumeric.atan2VS = numeric.pointwise(['x[i]', 'y'], 'ret[i] = atan2(x[i],y);', 'var atan2 = Math.atan2;');\n\t\t\tnumeric.atan2SV = numeric.pointwise(['x', 'y[i]'], 'ret[i] = atan2(x,y[i]);', 'var atan2 = Math.atan2;');\n\t\t\tnumeric.atan2 = function atan2(x, y) {\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\tif (typeof y === \"object\") return numeric.atan2VV(x, y);\n\t\t\t\t\treturn numeric.atan2VS(x, y);\n\t\t\t\t}\n\t\t\t\tif (typeof y === \"object\") return numeric.atan2SV(x, y);\n\t\t\t\treturn Math.atan2(x, y);\n\t\t\t};\n\n\t\t\tnumeric.truncVV = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = round(x[i]/y[i])*y[i];', 'var round = Math.round;');\n\t\t\tnumeric.truncVS = numeric.pointwise(['x[i]', 'y'], 'ret[i] = round(x[i]/y)*y;', 'var round = Math.round;');\n\t\t\tnumeric.truncSV = numeric.pointwise(['x', 'y[i]'], 'ret[i] = round(x/y[i])*y[i];', 'var round = Math.round;');\n\t\t\tnumeric.trunc = function trunc(x, y) {\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\tif (typeof y === \"object\") return numeric.truncVV(x, y);\n\t\t\t\t\treturn numeric.truncVS(x, y);\n\t\t\t\t}\n\t\t\t\tif (typeof y === \"object\") return numeric.truncSV(x, y);\n\t\t\t\treturn Math.round(x / y) * y;\n\t\t\t};\n\n\t\t\tnumeric.powVV = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = pow(x[i],y[i]);', 'var pow = Math.pow;');\n\t\t\tnumeric.powVS = numeric.pointwise(['x[i]', 'y'], 'ret[i] = pow(x[i],y);', 'var pow = Math.pow;');\n\t\t\tnumeric.powSV = numeric.pointwise(['x', 'y[i]'], 'ret[i] = pow(x,y[i]);', 'var pow = Math.pow;');\n\t\t\tnumeric.pow = function pow(x, y) {\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\tif (typeof y === \"object\") return numeric.powVV(x, y);\n\t\t\t\t\treturn numeric.powVS(x, y);\n\t\t\t\t}\n\t\t\t\tif (typeof y === \"object\") return numeric.powSV(x, y);\n\t\t\t\treturn Math.pow(x, y);\n\t\t\t};\n\n\t\t\tnumeric.clone = numeric.pointwise(['x[i]'], 'ret[i] = x[i];');\n\n\t\t\tnumeric.inv = function inv(x) {\n\t\t\t\tvar s = numeric.dim(x),\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1];\n\t\t\t\tvar A = numeric.clone(x),\n\t\t\t\t\tAi, Aj;\n\t\t\t\tvar I = numeric.identity(m),\n\t\t\t\t\tIi, Ij;\n\t\t\t\tvar i, j, k, x;\n\t\t\t\tfor (j = 0; j < n; ++j) {\n\t\t\t\t\ti0 = -1;\n\t\t\t\t\tv0 = -1;\n\t\t\t\t\tfor (i = j; i !== m; ++i) {\n\t\t\t\t\t\tk = abs(A[i][j]);\n\t\t\t\t\t\tif (k > v0) {\n\t\t\t\t\t\t\ti0 = i;\n\t\t\t\t\t\t\tv0 = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tAj = A[i0];\n\t\t\t\t\tA[i0] = A[j];\n\t\t\t\t\tA[j] = Aj;\n\t\t\t\t\tIj = I[i0];\n\t\t\t\t\tI[i0] = I[j];\n\t\t\t\t\tI[j] = Ij;\n\t\t\t\t\tx = Aj[j];\n\t\t\t\t\tfor (k = j; k !== n; ++k) Aj[k] /= x;\n\t\t\t\t\tfor (k = n - 1; k !== -1; --k) Ij[k] /= x;\n\t\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\t\tif (i !== j) {\n\t\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\t\tIi = I[i];\n\t\t\t\t\t\t\tx = Ai[j];\n\t\t\t\t\t\t\tfor (k = j + 1; k !== n; ++k) Ai[k] -= Aj[k] * x;\n\t\t\t\t\t\t\tfor (k = n - 1; k > 0; --k) {\n\t\t\t\t\t\t\t\tIi[k] -= Ij[k] * x;\n\t\t\t\t\t\t\t\t--k;\n\t\t\t\t\t\t\t\tIi[k] -= Ij[k] * x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k === 0) Ii[0] -= Ij[0] * x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn I;\n\t\t\t};\n\n\t\t\tnumeric.det = function det(x) {\n\t\t\t\tvar s = numeric.dim(x);\n\t\t\t\tif (s.length !== 2 || s[0] !== s[1]) {\n\t\t\t\t\tthrow new Error('numeric: det() only works on square matrices');\n\t\t\t\t}\n\t\t\t\tvar n = s[0],\n\t\t\t\t\tret = 1,\n\t\t\t\t\ti, j, k, A = numeric.clone(x),\n\t\t\t\t\tAj, Ai, alpha, temp, k1, k2, k3;\n\t\t\t\tfor (j = 0; j < n - 1; j++) {\n\t\t\t\t\tk = j;\n\t\t\t\t\tfor (i = j + 1; i < n; i++) {\n\t\t\t\t\t\tif (Math.abs(A[i][j]) > Math.abs(A[k][j])) {\n\t\t\t\t\t\t\tk = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k !== j) {\n\t\t\t\t\t\ttemp = A[k];\n\t\t\t\t\t\tA[k] = A[j];\n\t\t\t\t\t\tA[j] = temp;\n\t\t\t\t\t\tret *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tAj = A[j];\n\t\t\t\t\tfor (i = j + 1; i < n; i++) {\n\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\talpha = Ai[j] / Aj[j];\n\t\t\t\t\t\tfor (k = j + 1; k < n - 1; k += 2) {\n\t\t\t\t\t\t\tk1 = k + 1;\n\t\t\t\t\t\t\tAi[k] -= Aj[k] * alpha;\n\t\t\t\t\t\t\tAi[k1] -= Aj[k1] * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k !== n) {\n\t\t\t\t\t\t\tAi[k] -= Aj[k] * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Aj[j] === 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tret *= Aj[j];\n\t\t\t\t}\n\t\t\t\treturn ret * A[j][j];\n\t\t\t};\n\n\t\t\tnumeric.transpose = function transpose(x) {\n\t\t\t\tvar i, j, m = x.length,\n\t\t\t\t\tn = x[0].length,\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\tA0, A1, Bj;\n\t\t\t\tfor (j = 0; j < n; j++) ret[j] = Array(m);\n\t\t\t\tfor (i = m - 1; i >= 1; i -= 2) {\n\t\t\t\t\tA1 = x[i];\n\t\t\t\t\tA0 = x[i - 1];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = A1[j];\n\t\t\t\t\t\tBj[i - 1] = A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = A1[j];\n\t\t\t\t\t\tBj[i - 1] = A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tBj = ret[0];\n\t\t\t\t\t\tBj[i] = A1[0];\n\t\t\t\t\t\tBj[i - 1] = A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tA0 = x[0];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tret[j][0] = A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tret[j][0] = A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tret[0][0] = A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.negtranspose = function negtranspose(x) {\n\t\t\t\tvar i, j, m = x.length,\n\t\t\t\t\tn = x[0].length,\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\tA0, A1, Bj;\n\t\t\t\tfor (j = 0; j < n; j++) ret[j] = Array(m);\n\t\t\t\tfor (i = m - 1; i >= 1; i -= 2) {\n\t\t\t\t\tA1 = x[i];\n\t\t\t\t\tA0 = x[i - 1];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = -A1[j];\n\t\t\t\t\t\tBj[i - 1] = -A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = -A1[j];\n\t\t\t\t\t\tBj[i - 1] = -A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tBj = ret[0];\n\t\t\t\t\t\tBj[i] = -A1[0];\n\t\t\t\t\t\tBj[i - 1] = -A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tA0 = x[0];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tret[j][0] = -A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tret[j][0] = -A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tret[0][0] = -A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric._random = function _random(s, k) {\n\t\t\t\tvar i, n = s[k],\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\trnd;\n\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\trnd = Math.random;\n\t\t\t\t\tfor (i = n - 1; i >= 1; i -= 2) {\n\t\t\t\t\t\tret[i] = rnd();\n\t\t\t\t\t\tret[i - 1] = rnd();\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tret[0] = rnd();\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfor (i = n - 1; i >= 0; i--) ret[i] = _random(s, k + 1);\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.random = function random(s) {\n\t\t\t\treturn numeric._random(s, 0);\n\t\t\t};\n\n\t\t\tnumeric.norm2Squared = function norm2Squared(x) {};\n\t\t\tnumeric.norm2Squared = numeric.mapreduce('accum += xi*xi;', '0');\n\n\t\t\tnumeric.norm2 = function norm2(x) {\n\t\t\t\treturn Math.sqrt(numeric.norm2Squared(x));\n\t\t\t};\n\t\t\tnumeric.norminf = numeric.mapreduce('accum = max(abs(xi),accum);', '0; var max = Math.max, abs = Math.abs;');\n\t\t\tnumeric.sum = numeric.mapreduce('accum += xi;', '0');\n\t\t\tnumeric.sup = numeric.mapreduce('accum = max(xi,accum);', '-Infinity; var max = Math.max;');\n\t\t\tnumeric.inf = numeric.mapreduce('accum = min(xi,accum);', 'Infinity; var min = Math.min;');\n\n\t\t\tnumeric.linspace = function linspace(a, b, n) {\n\t\t\t\tif (typeof n === \"undefined\") n = Math.max(Math.round(b - a) + 1, 1);\n\t\t\t\tif (n < 2) {\n\t\t\t\t\treturn n === 1 ? [a] : [];\n\t\t\t\t}\n\t\t\t\tvar i, ret = Array(n);\n\t\t\t\tn--;\n\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\tret[i] = (i * b + (n - i) * a) / n;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.getBlock = function getBlock(x, from, to) {\n\t\t\t\tvar s = numeric.dim(x);\n\n\t\t\t\tfunction foo(x, k) {\n\t\t\t\t\tvar i, a = from[k],\n\t\t\t\t\t\tn = to[k] - a,\n\t\t\t\t\t\tret = Array(n);\n\t\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\t\tret[i] = x[i + a];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\tret[i] = foo(x[i + a], k + 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn foo(x, 0);\n\t\t\t};\n\n\t\t\tnumeric.setBlock = function setBlock(x, from, to, B) {\n\t\t\t\tvar s = numeric.dim(x);\n\n\t\t\t\tfunction foo(x, y, k) {\n\t\t\t\t\tvar i, a = from[k],\n\t\t\t\t\t\tn = to[k] - a;\n\t\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\t\tx[i + a] = y[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\tfoo(x[i + a], y[i], k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoo(x, B, 0);\n\t\t\t\treturn x;\n\t\t\t};\n\n\t\t\tnumeric.getRange = function getRange(A, I, J) {\n\t\t\t\tvar m = I.length,\n\t\t\t\t\tn = J.length;\n\t\t\t\tvar i, j;\n\t\t\t\tvar B = Array(m),\n\t\t\t\t\tBi, AI;\n\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\tB[i] = Array(n);\n\t\t\t\t\tBi = B[i];\n\t\t\t\t\tAI = A[I[i]];\n\t\t\t\t\tfor (j = n - 1; j !== -1; --j) Bi[j] = AI[J[j]];\n\t\t\t\t}\n\t\t\t\treturn B;\n\t\t\t};\n\n\t\t\tnumeric.blockMatrix = function blockMatrix(X) {\n\t\t\t\tvar s = numeric.dim(X);\n\t\t\t\tif (s.length < 4) return numeric.blockMatrix([X]);\n\t\t\t\tvar m = s[0],\n\t\t\t\t\tn = s[1],\n\t\t\t\t\tM, N, i, j, Xij;\n\t\t\t\tM = 0;\n\t\t\t\tN = 0;\n\t\t\t\tfor (i = 0; i < m; ++i) M += X[i][0].length;\n\t\t\t\tfor (j = 0; j < n; ++j) N += X[0][j][0].length;\n\t\t\t\tvar Z = Array(M);\n\t\t\t\tfor (i = 0; i < M; ++i) Z[i] = Array(N);\n\t\t\t\tvar I = 0,\n\t\t\t\t\tJ, ZI, k, l, Xijk;\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tJ = N;\n\t\t\t\t\tfor (j = n - 1; j !== -1; --j) {\n\t\t\t\t\t\tXij = X[i][j];\n\t\t\t\t\t\tJ -= Xij[0].length;\n\t\t\t\t\t\tfor (k = Xij.length - 1; k !== -1; --k) {\n\t\t\t\t\t\t\tXijk = Xij[k];\n\t\t\t\t\t\t\tZI = Z[I + k];\n\t\t\t\t\t\t\tfor (l = Xijk.length - 1; l !== -1; --l) ZI[J + l] = Xijk[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tI += X[i][0].length;\n\t\t\t\t}\n\t\t\t\treturn Z;\n\t\t\t};\n\n\t\t\tnumeric.tensor = function tensor(x, y) {\n\t\t\t\tif (typeof x === \"number\" || typeof y === \"number\") return numeric.mul(x, y);\n\t\t\t\tvar s1 = numeric.dim(x),\n\t\t\t\t\ts2 = numeric.dim(y);\n\t\t\t\tif (s1.length !== 1 || s2.length !== 1) {\n\t\t\t\t\tthrow new Error('numeric: tensor product is only defined for vectors');\n\t\t\t\t}\n\t\t\t\tvar m = s1[0],\n\t\t\t\t\tn = s2[0],\n\t\t\t\t\tA = Array(m),\n\t\t\t\t\tAi, i, j, xi;\n\t\t\t\tfor (i = m - 1; i >= 0; i--) {\n\t\t\t\t\tAi = Array(n);\n\t\t\t\t\txi = x[i];\n\t\t\t\t\tfor (j = n - 1; j >= 3; --j) {\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t}\n\t\t\t\t\twhile (j >= 0) {\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t}\n\t\t\t\t\tA[i] = Ai;\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\n\t\t\t// 3. The Tensor type T\n\t\t\tnumeric.T = function T(x, y) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t};\n\t\t\tnumeric.t = function t(x, y) {\n\t\t\t\treturn new numeric.T(x, y);\n\t\t\t};\n\n\t\t\tnumeric.Tbinop = function Tbinop(rr, rc, cr, cc, setup) {\n\t\t\t\tvar io = numeric.indexOf;\n\t\t\t\tif (typeof setup !== \"string\") {\n\t\t\t\t\tvar k;\n\t\t\t\t\tsetup = '';\n\t\t\t\t\tfor (k in numeric) {\n\t\t\t\t\t\tif (numeric.hasOwnProperty(k) && (rr.indexOf(k) >= 0 || rc.indexOf(k) >= 0 || cr.indexOf(k) >= 0 || cc.indexOf(k) >= 0) && k.length > 1) {\n\t\t\t\t\t\t\tsetup += 'var ' + k + ' = numeric.' + k + ';\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn numeric.Function(['y'],\n\t\t\t\t\t'var x = this;\\n' +\n\t\t\t\t\t'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\\n' +\n\t\t\t\t\tsetup + '\\n' +\n\t\t\t\t\t'if(x.y) {' +\n\t\t\t\t\t'  if(y.y) {' +\n\t\t\t\t\t'    return new numeric.T(' + cc + ');\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  return new numeric.T(' + cr + ');\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'if(y.y) {\\n' +\n\t\t\t\t\t'  return new numeric.T(' + rc + ');\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return new numeric.T(' + rr + ');\\n'\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tnumeric.T.prototype.add = numeric.Tbinop(\n\t\t\t\t'add(x.x,y.x)',\n\t\t\t\t'add(x.x,y.x),y.y',\n\t\t\t\t'add(x.x,y.x),x.y',\n\t\t\t\t'add(x.x,y.x),add(x.y,y.y)');\n\t\t\tnumeric.T.prototype.sub = numeric.Tbinop(\n\t\t\t\t'sub(x.x,y.x)',\n\t\t\t\t'sub(x.x,y.x),neg(y.y)',\n\t\t\t\t'sub(x.x,y.x),x.y',\n\t\t\t\t'sub(x.x,y.x),sub(x.y,y.y)');\n\t\t\tnumeric.T.prototype.mul = numeric.Tbinop(\n\t\t\t\t'mul(x.x,y.x)',\n\t\t\t\t'mul(x.x,y.x),mul(x.x,y.y)',\n\t\t\t\t'mul(x.x,y.x),mul(x.y,y.x)',\n\t\t\t\t'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');\n\n\t\t\tnumeric.T.prototype.reciprocal = function reciprocal() {\n\t\t\t\tvar mul = numeric.mul,\n\t\t\t\t\tdiv = numeric.div;\n\t\t\t\tif (this.y) {\n\t\t\t\t\tvar d = numeric.add(mul(this.x, this.x), mul(this.y, this.y));\n\t\t\t\t\treturn new numeric.T(div(this.x, d), div(numeric.neg(this.y), d));\n\t\t\t\t}\n\t\t\t\treturn new T(div(1, this.x));\n\t\t\t};\n\t\t\tnumeric.T.prototype.div = function div(y) {\n\t\t\t\tif (!(y instanceof numeric.T)) y = new numeric.T(y);\n\t\t\t\tif (y.y) {\n\t\t\t\t\treturn this.mul(y.reciprocal());\n\t\t\t\t}\n\t\t\t\tvar div = numeric.div;\n\t\t\t\tif (this.y) {\n\t\t\t\t\treturn new numeric.T(div(this.x, y.x), div(this.y, y.x));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(div(this.x, y.x));\n\t\t\t};\n\t\t\tnumeric.T.prototype.dot = numeric.Tbinop(\n\t\t\t\t'dot(x.x,y.x)',\n\t\t\t\t'dot(x.x,y.x),dot(x.x,y.y)',\n\t\t\t\t'dot(x.x,y.x),dot(x.y,y.x)',\n\t\t\t\t'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'\n\t\t\t);\n\t\t\tnumeric.T.prototype.transpose = function transpose() {\n\t\t\t\tvar t = numeric.transpose,\n\t\t\t\t\tx = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(t(x), t(y));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(t(x));\n\t\t\t};\n\t\t\tnumeric.T.prototype.transjugate = function transjugate() {\n\t\t\t\tvar t = numeric.transpose,\n\t\t\t\t\tx = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(t(x), numeric.negtranspose(y));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(t(x));\n\t\t\t};\n\t\t\tnumeric.Tunop = function Tunop(r, c, s) {\n\t\t\t\tif (typeof s !== \"string\") {\n\t\t\t\t\ts = '';\n\t\t\t\t}\n\t\t\t\treturn numeric.Function(\n\t\t\t\t\t'var x = this;\\n' +\n\t\t\t\t\ts + '\\n' +\n\t\t\t\t\t'if(x.y) {' +\n\t\t\t\t\t'  ' + c + ';\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\tr + ';\\n'\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tnumeric.T.prototype.exp = numeric.Tunop(\n\t\t\t\t'return new numeric.T(ex)',\n\t\t\t\t'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',\n\t\t\t\t'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');\n\t\t\tnumeric.T.prototype.conj = numeric.Tunop(\n\t\t\t\t'return new numeric.T(x.x);',\n\t\t\t\t'return new numeric.T(x.x,numeric.neg(x.y));');\n\t\t\tnumeric.T.prototype.neg = numeric.Tunop(\n\t\t\t\t'return new numeric.T(neg(x.x));',\n\t\t\t\t'return new numeric.T(neg(x.x),neg(x.y));',\n\t\t\t\t'var neg = numeric.neg;');\n\t\t\tnumeric.T.prototype.sin = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.sin(x.x))',\n\t\t\t\t'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');\n\t\t\tnumeric.T.prototype.cos = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.cos(x.x))',\n\t\t\t\t'return x.exp().add(x.neg().exp()).div(2);');\n\t\t\tnumeric.T.prototype.abs = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.abs(x.x));',\n\t\t\t\t'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',\n\t\t\t\t'var mul = numeric.mul;');\n\t\t\tnumeric.T.prototype.log = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.log(x.x));',\n\t\t\t\t'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\\n' +\n\t\t\t\t'return new numeric.T(numeric.log(r.x),theta.x);');\n\t\t\tnumeric.T.prototype.norm2 = numeric.Tunop(\n\t\t\t\t'return numeric.norm2(x.x);',\n\t\t\t\t'var f = numeric.norm2Squared;\\n' +\n\t\t\t\t'return Math.sqrt(f(x.x)+f(x.y));');\n\t\t\tnumeric.T.prototype.inv = function inv() {\n\t\t\t\tvar A = this;\n\t\t\t\tif (typeof A.y === \"undefined\") {\n\t\t\t\t\treturn new numeric.T(numeric.inv(A.x));\n\t\t\t\t}\n\t\t\t\tvar n = A.x.length,\n\t\t\t\t\ti, j, k;\n\t\t\t\tvar Rx = numeric.identity(n),\n\t\t\t\t\tRy = numeric.rep([n, n], 0);\n\t\t\t\tvar Ax = numeric.clone(A.x),\n\t\t\t\t\tAy = numeric.clone(A.y);\n\t\t\t\tvar Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;\n\t\t\t\tvar i, j, k, d, d1, ax, ay, bx, by, temp;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tax = Ax[i][i];\n\t\t\t\t\tay = Ay[i][i];\n\t\t\t\t\td = ax * ax + ay * ay;\n\t\t\t\t\tk = i;\n\t\t\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\t\t\tax = Ax[j][i];\n\t\t\t\t\t\tay = Ay[j][i];\n\t\t\t\t\t\td1 = ax * ax + ay * ay;\n\t\t\t\t\t\tif (d1 > d) {\n\t\t\t\t\t\t\tk = j;\n\t\t\t\t\t\t\td = d1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k !== i) {\n\t\t\t\t\t\ttemp = Ax[i];\n\t\t\t\t\t\tAx[i] = Ax[k];\n\t\t\t\t\t\tAx[k] = temp;\n\t\t\t\t\t\ttemp = Ay[i];\n\t\t\t\t\t\tAy[i] = Ay[k];\n\t\t\t\t\t\tAy[k] = temp;\n\t\t\t\t\t\ttemp = Rx[i];\n\t\t\t\t\t\tRx[i] = Rx[k];\n\t\t\t\t\t\tRx[k] = temp;\n\t\t\t\t\t\ttemp = Ry[i];\n\t\t\t\t\t\tRy[i] = Ry[k];\n\t\t\t\t\t\tRy[k] = temp;\n\t\t\t\t\t}\n\t\t\t\t\tAix = Ax[i];\n\t\t\t\t\tAiy = Ay[i];\n\t\t\t\t\tRix = Rx[i];\n\t\t\t\t\tRiy = Ry[i];\n\t\t\t\t\tax = Aix[i];\n\t\t\t\t\tay = Aiy[i];\n\t\t\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\t\t\tbx = Aix[j];\n\t\t\t\t\t\tby = Aiy[j];\n\t\t\t\t\t\tAix[j] = (bx * ax + by * ay) / d;\n\t\t\t\t\t\tAiy[j] = (by * ax - bx * ay) / d;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\t\tbx = Rix[j];\n\t\t\t\t\t\tby = Riy[j];\n\t\t\t\t\t\tRix[j] = (bx * ax + by * ay) / d;\n\t\t\t\t\t\tRiy[j] = (by * ax - bx * ay) / d;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\t\t\tAjx = Ax[j];\n\t\t\t\t\t\tAjy = Ay[j];\n\t\t\t\t\t\tRjx = Rx[j];\n\t\t\t\t\t\tRjy = Ry[j];\n\t\t\t\t\t\tax = Ajx[i];\n\t\t\t\t\t\tay = Ajy[i];\n\t\t\t\t\t\tfor (k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tbx = Aix[k];\n\t\t\t\t\t\t\tby = Aiy[k];\n\t\t\t\t\t\t\tAjx[k] -= bx * ax - by * ay;\n\t\t\t\t\t\t\tAjy[k] -= by * ax + bx * ay;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\t\t\tbx = Rix[k];\n\t\t\t\t\t\t\tby = Riy[k];\n\t\t\t\t\t\t\tRjx[k] -= bx * ax - by * ay;\n\t\t\t\t\t\t\tRjy[k] -= by * ax + bx * ay;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = n - 1; i > 0; i--) {\n\t\t\t\t\tRix = Rx[i];\n\t\t\t\t\tRiy = Ry[i];\n\t\t\t\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tRjx = Rx[j];\n\t\t\t\t\t\tRjy = Ry[j];\n\t\t\t\t\t\tax = Ax[j][i];\n\t\t\t\t\t\tay = Ay[j][i];\n\t\t\t\t\t\tfor (k = n - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tbx = Rix[k];\n\t\t\t\t\t\t\tby = Riy[k];\n\t\t\t\t\t\t\tRjx[k] -= ax * bx - ay * by;\n\t\t\t\t\t\t\tRjy[k] -= ax * by + ay * bx;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(Rx, Ry);\n\t\t\t};\n\t\t\tnumeric.T.prototype.get = function get(i) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tk = 0,\n\t\t\t\t\tik, n = i.length;\n\t\t\t\tif (y) {\n\t\t\t\t\twhile (k < n) {\n\t\t\t\t\t\tik = i[k];\n\t\t\t\t\t\tx = x[ik];\n\t\t\t\t\t\ty = y[ik];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\treturn new numeric.T(x, y);\n\t\t\t\t}\n\t\t\t\twhile (k < n) {\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx = x[ik];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(x);\n\t\t\t};\n\t\t\tnumeric.T.prototype.set = function set(i, v) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tk = 0,\n\t\t\t\t\tik, n = i.length,\n\t\t\t\t\tvx = v.x,\n\t\t\t\t\tvy = v.y;\n\t\t\t\tif (n === 0) {\n\t\t\t\t\tif (vy) {\n\t\t\t\t\t\tthis.y = vy;\n\t\t\t\t\t} else if (y) {\n\t\t\t\t\t\tthis.y = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x = x;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tif (vy) {\n\t\t\t\t\tif (y) {\n\t\t\t\t\t\t/* ok */\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty = numeric.rep(numeric.dim(x), 0);\n\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t}\n\t\t\t\t\twhile (k < n - 1) {\n\t\t\t\t\t\tik = i[k];\n\t\t\t\t\t\tx = x[ik];\n\t\t\t\t\t\ty = y[ik];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx[ik] = vx;\n\t\t\t\t\ty[ik] = vy;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tif (y) {\n\t\t\t\t\twhile (k < n - 1) {\n\t\t\t\t\t\tik = i[k];\n\t\t\t\t\t\tx = x[ik];\n\t\t\t\t\t\ty = y[ik];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx[ik] = vx;\n\t\t\t\t\tif (vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx), 0);\n\t\t\t\t\telse y[ik] = 0;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\twhile (k < n - 1) {\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx = x[ik];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tik = i[k];\n\t\t\t\tx[ik] = vx;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tnumeric.T.prototype.getRows = function getRows(i0, i1) {\n\t\t\t\tvar n = i1 - i0 + 1,\n\t\t\t\t\tj;\n\t\t\t\tvar rx = Array(n),\n\t\t\t\t\try, x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\trx[j - i0] = x[j];\n\t\t\t\t}\n\t\t\t\tif (y) {\n\t\t\t\t\try = Array(n);\n\t\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\t\try[j - i0] = y[j];\n\t\t\t\t\t}\n\t\t\t\t\treturn new numeric.T(rx, ry);\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(rx);\n\t\t\t};\n\t\t\tnumeric.T.prototype.setRows = function setRows(i0, i1, A) {\n\t\t\t\tvar j;\n\t\t\t\tvar rx = this.x,\n\t\t\t\t\try = this.y,\n\t\t\t\t\tx = A.x,\n\t\t\t\t\ty = A.y;\n\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\trx[j] = x[j - i0];\n\t\t\t\t}\n\t\t\t\tif (y) {\n\t\t\t\t\tif (!ry) {\n\t\t\t\t\t\try = numeric.rep(numeric.dim(rx), 0);\n\t\t\t\t\t\tthis.y = ry;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\t\try[j] = y[j - i0];\n\t\t\t\t\t}\n\t\t\t\t} else if (ry) {\n\t\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\t\try[j] = numeric.rep([x[j - i0].length], 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tnumeric.T.prototype.getRow = function getRow(k) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(x[k], y[k]);\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(x[k]);\n\t\t\t};\n\t\t\tnumeric.T.prototype.setRow = function setRow(i, v) {\n\t\t\t\tvar rx = this.x,\n\t\t\t\t\try = this.y,\n\t\t\t\t\tx = v.x,\n\t\t\t\t\ty = v.y;\n\t\t\t\trx[i] = x;\n\t\t\t\tif (y) {\n\t\t\t\t\tif (!ry) {\n\t\t\t\t\t\try = numeric.rep(numeric.dim(rx), 0);\n\t\t\t\t\t\tthis.y = ry;\n\t\t\t\t\t}\n\t\t\t\t\try[i] = y;\n\t\t\t\t} else if (ry) {\n\t\t\t\t\try = numeric.rep([x.length], 0);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tnumeric.T.prototype.getBlock = function getBlock(from, to) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tb = numeric.getBlock;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(b(x, from, to), b(y, from, to));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(b(x, from, to));\n\t\t\t};\n\t\t\tnumeric.T.prototype.setBlock = function setBlock(from, to, A) {\n\t\t\t\tif (!(A instanceof numeric.T)) A = new numeric.T(A);\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tb = numeric.setBlock,\n\t\t\t\t\tAx = A.x,\n\t\t\t\t\tAy = A.y;\n\t\t\t\tif (Ay) {\n\t\t\t\t\tif (!y) {\n\t\t\t\t\t\tthis.y = numeric.rep(numeric.dim(this), 0);\n\t\t\t\t\t\ty = this.y;\n\t\t\t\t\t}\n\t\t\t\t\tb(x, from, to, Ax);\n\t\t\t\t\tb(y, from, to, Ay);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tb(x, from, to, Ax);\n\t\t\t\tif (y) b(y, from, to, numeric.rep(numeric.dim(Ax), 0));\n\t\t\t};\n\t\t\tnumeric.T.rep = function rep(s, v) {\n\t\t\t\tvar T = numeric.T;\n\t\t\t\tif (!(v instanceof T)) v = new T(v);\n\t\t\t\tvar x = v.x,\n\t\t\t\t\ty = v.y,\n\t\t\t\t\tr = numeric.rep;\n\t\t\t\tif (y) return new T(r(s, x), r(s, y));\n\t\t\t\treturn new T(r(s, x));\n\t\t\t};\n\t\t\tnumeric.T.diag = function diag(d) {\n\t\t\t\tif (!(d instanceof numeric.T)) d = new numeric.T(d);\n\t\t\t\tvar x = d.x,\n\t\t\t\t\ty = d.y,\n\t\t\t\t\tdiag = numeric.diag;\n\t\t\t\tif (y) return new numeric.T(diag(x), diag(y));\n\t\t\t\treturn new numeric.T(diag(x));\n\t\t\t};\n\t\t\tnumeric.T.eig = function eig() {\n\t\t\t\tif (this.y) {\n\t\t\t\t\tthrow new Error('eig: not implemented for complex matrices.');\n\t\t\t\t}\n\t\t\t\treturn numeric.eig(this.x);\n\t\t\t};\n\t\t\tnumeric.T.identity = function identity(n) {\n\t\t\t\treturn new numeric.T(numeric.identity(n));\n\t\t\t};\n\t\t\tnumeric.T.prototype.getDiag = function getDiag() {\n\t\t\t\tvar n = numeric;\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new n.T(n.getDiag(x), n.getDiag(y));\n\t\t\t\t}\n\t\t\t\treturn new n.T(n.getDiag(x));\n\t\t\t};\n\n\t\t\t// 4. Eigenvalues of real matrices\n\n\t\t\tnumeric.house = function house(x) {\n\t\t\t\tvar v = numeric.clone(x);\n\t\t\t\tvar s = x[0] >= 0 ? 1 : -1;\n\t\t\t\tvar alpha = s * numeric.norm2(x);\n\t\t\t\tv[0] += alpha;\n\t\t\t\tvar foo = numeric.norm2(v);\n\t\t\t\tif (foo === 0) {\n\t\t\t\t\t/* this should not happen */\n\t\t\t\t\tthrow new Error('eig: internal error');\n\t\t\t\t}\n\t\t\t\treturn numeric.div(v, foo);\n\t\t\t};\n\n\t\t\tnumeric.toUpperHessenberg = function toUpperHessenberg(me) {\n\t\t\t\tvar s = numeric.dim(me);\n\t\t\t\tif (s.length !== 2 || s[0] !== s[1]) {\n\t\t\t\t\tthrow new Error('numeric: toUpperHessenberg() only works on square matrices');\n\t\t\t\t}\n\t\t\t\tvar m = s[0],\n\t\t\t\t\ti, j, k, x, v, A = numeric.clone(me),\n\t\t\t\t\tB, C, Ai, Ci, Q = numeric.identity(m),\n\t\t\t\t\tQi;\n\t\t\t\tfor (j = 0; j < m - 2; j++) {\n\t\t\t\t\tx = Array(m - j - 1);\n\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\tx[i - j - 1] = A[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (numeric.norm2(x) > 0) {\n\t\t\t\t\t\tv = numeric.house(x);\n\t\t\t\t\t\tB = numeric.getBlock(A, [j + 1, j], [m - 1, m - 1]);\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = j; k < m; k++) Ai[k] -= 2 * Ci[k - j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = numeric.getBlock(A, [0, j + 1], [m - 1, m - 1]);\n\t\t\t\t\t\tC = numeric.tensor(numeric.dot(B, v), v);\n\t\t\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\t\tfor (k = j + 1; k < m; k++) Ai[k] -= 2 * Ci[k - j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = Array(m - j - 1);\n\t\t\t\t\t\tfor (i = j + 1; i < m; i++) B[i - j - 1] = Q[i];\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\tQi = Q[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tH: A,\n\t\t\t\t\tQ: Q\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.epsilon = 2.220446049250313e-16;\n\n\t\t\tnumeric.QRFrancis = function(H, maxiter) {\n\t\t\t\tif (typeof maxiter === \"undefined\") {\n\t\t\t\t\tmaxiter = 10000;\n\t\t\t\t}\n\t\t\t\tH = numeric.clone(H);\n\t\t\t\tvar H0 = numeric.clone(H);\n\t\t\t\tvar s = numeric.dim(H),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tx, v, a, b, c, d, det, tr, Hloc, Q = numeric.identity(m),\n\t\t\t\t\tQi, Hi, B, C, Ci, i, j, k, iter;\n\t\t\t\tif (m < 3) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tQ: Q,\n\t\t\t\t\t\tB: [\n\t\t\t\t\t\t\t[0, m - 1]\n\t\t\t\t\t\t]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar epsilon = numeric.epsilon;\n\t\t\t\tfor (iter = 0; iter < maxiter; iter++) {\n\t\t\t\t\tfor (j = 0; j < m - 1; j++) {\n\t\t\t\t\t\tif (Math.abs(H[j + 1][j]) < epsilon * (Math.abs(H[j][j]) + Math.abs(H[j + 1][j + 1]))) {\n\t\t\t\t\t\t\tvar QH1 = numeric.QRFrancis(numeric.getBlock(H, [0, 0], [j, j]), maxiter);\n\t\t\t\t\t\t\tvar QH2 = numeric.QRFrancis(numeric.getBlock(H, [j + 1, j + 1], [m - 1, m - 1]), maxiter);\n\t\t\t\t\t\t\tB = Array(j + 1);\n\t\t\t\t\t\t\tfor (i = 0; i <= j; i++) {\n\t\t\t\t\t\t\t\tB[i] = Q[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tC = numeric.dot(QH1.Q, B);\n\t\t\t\t\t\t\tfor (i = 0; i <= j; i++) {\n\t\t\t\t\t\t\t\tQ[i] = C[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tB = Array(m - j - 1);\n\t\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\t\tB[i - j - 1] = Q[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tC = numeric.dot(QH2.Q, B);\n\t\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\t\tQ[i] = C[i - j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tQ: Q,\n\t\t\t\t\t\t\t\tB: QH1.B.concat(numeric.add(QH2.B, j + 1))\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = H[m - 2][m - 2];\n\t\t\t\t\tb = H[m - 2][m - 1];\n\t\t\t\t\tc = H[m - 1][m - 2];\n\t\t\t\t\td = H[m - 1][m - 1];\n\t\t\t\t\ttr = a + d;\n\t\t\t\t\tdet = (a * d - b * c);\n\t\t\t\t\tHloc = numeric.getBlock(H, [0, 0], [2, 2]);\n\t\t\t\t\tif (tr * tr >= 4 * det) {\n\t\t\t\t\t\tvar s1, s2;\n\t\t\t\t\t\ts1 = 0.5 * (tr + Math.sqrt(tr * tr - 4 * det));\n\t\t\t\t\t\ts2 = 0.5 * (tr - Math.sqrt(tr * tr - 4 * det));\n\t\t\t\t\t\tHloc = numeric.add(numeric.sub(numeric.dot(Hloc, Hloc),\n\t\t\t\t\t\t\t\tnumeric.mul(Hloc, s1 + s2)),\n\t\t\t\t\t\t\tnumeric.diag(numeric.rep([3], s1 * s2)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tHloc = numeric.add(numeric.sub(numeric.dot(Hloc, Hloc),\n\t\t\t\t\t\t\t\tnumeric.mul(Hloc, tr)),\n\t\t\t\t\t\t\tnumeric.diag(numeric.rep([3], det)));\n\t\t\t\t\t}\n\t\t\t\t\tx = [Hloc[0][0], Hloc[1][0], Hloc[2][0]];\n\t\t\t\t\tv = numeric.house(x);\n\t\t\t\t\tB = [H[0], H[1], H[2]];\n\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\tfor (k = 0; k < m; k++) Hi[k] -= 2 * Ci[k];\n\t\t\t\t\t}\n\t\t\t\t\tB = numeric.getBlock(H, [0, 0], [m - 1, 2]);\n\t\t\t\t\tC = numeric.tensor(numeric.dot(B, v), v);\n\t\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\tfor (k = 0; k < 3; k++) Hi[k] -= 2 * Ci[k];\n\t\t\t\t\t}\n\t\t\t\t\tB = [Q[0], Q[1], Q[2]];\n\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tQi = Q[i];\n\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\tfor (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];\n\t\t\t\t\t}\n\t\t\t\t\tvar J;\n\t\t\t\t\tfor (j = 0; j < m - 2; j++) {\n\t\t\t\t\t\tfor (k = j; k <= j + 1; k++) {\n\t\t\t\t\t\t\tif (Math.abs(H[k + 1][k]) < epsilon * (Math.abs(H[k][k]) + Math.abs(H[k + 1][k + 1]))) {\n\t\t\t\t\t\t\t\tvar QH1 = numeric.QRFrancis(numeric.getBlock(H, [0, 0], [k, k]), maxiter);\n\t\t\t\t\t\t\t\tvar QH2 = numeric.QRFrancis(numeric.getBlock(H, [k + 1, k + 1], [m - 1, m - 1]), maxiter);\n\t\t\t\t\t\t\t\tB = Array(k + 1);\n\t\t\t\t\t\t\t\tfor (i = 0; i <= k; i++) {\n\t\t\t\t\t\t\t\t\tB[i] = Q[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tC = numeric.dot(QH1.Q, B);\n\t\t\t\t\t\t\t\tfor (i = 0; i <= k; i++) {\n\t\t\t\t\t\t\t\t\tQ[i] = C[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tB = Array(m - k - 1);\n\t\t\t\t\t\t\t\tfor (i = k + 1; i < m; i++) {\n\t\t\t\t\t\t\t\t\tB[i - k - 1] = Q[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tC = numeric.dot(QH2.Q, B);\n\t\t\t\t\t\t\t\tfor (i = k + 1; i < m; i++) {\n\t\t\t\t\t\t\t\t\tQ[i] = C[i - k - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tQ: Q,\n\t\t\t\t\t\t\t\t\tB: QH1.B.concat(numeric.add(QH2.B, k + 1))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJ = Math.min(m - 1, j + 3);\n\t\t\t\t\t\tx = Array(J - j);\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) {\n\t\t\t\t\t\t\tx[i - j - 1] = H[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv = numeric.house(x);\n\t\t\t\t\t\tB = numeric.getBlock(H, [j + 1, j], [J, m - 1]);\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) {\n\t\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = j; k < m; k++) Hi[k] -= 2 * Ci[k - j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = numeric.getBlock(H, [0, j + 1], [m - 1, J]);\n\t\t\t\t\t\tC = numeric.tensor(numeric.dot(B, v), v);\n\t\t\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\t\tfor (k = j + 1; k <= J; k++) Hi[k] -= 2 * Ci[k - j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = Array(J - j);\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) B[i - j - 1] = Q[i];\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) {\n\t\t\t\t\t\t\tQi = Q[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');\n\t\t\t};\n\n\t\t\tnumeric.eig = function eig(A, maxiter) {\n\t\t\t\tvar QH = numeric.toUpperHessenberg(A);\n\t\t\t\tvar QB = numeric.QRFrancis(QH.H, maxiter);\n\t\t\t\tvar T = numeric.T;\n\t\t\t\tvar n = A.length,\n\t\t\t\t\ti, k, flag = false,\n\t\t\t\t\tB = QB.B,\n\t\t\t\t\tH = numeric.dot(QB.Q, numeric.dot(QH.H, numeric.transpose(QB.Q)));\n\t\t\t\tvar Q = new T(numeric.dot(QB.Q, QH.Q)),\n\t\t\t\t\tQ0;\n\t\t\t\tvar m = B.length,\n\t\t\t\t\tj;\n\t\t\t\tvar a, b, c, d, p1, p2, disc, x, y, p, q, n1, n2;\n\t\t\t\tvar sqrt = Math.sqrt;\n\t\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\t\ti = B[k][0];\n\t\t\t\t\tif (i === B[k][1]) {\n\t\t\t\t\t\t// nothing\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\ta = H[i][i];\n\t\t\t\t\t\tb = H[i][j];\n\t\t\t\t\t\tc = H[j][i];\n\t\t\t\t\t\td = H[j][j];\n\t\t\t\t\t\tif (b === 0 && c === 0) continue;\n\t\t\t\t\t\tp1 = -a - d;\n\t\t\t\t\t\tp2 = a * d - b * c;\n\t\t\t\t\t\tdisc = p1 * p1 - 4 * p2;\n\t\t\t\t\t\tif (disc >= 0) {\n\t\t\t\t\t\t\tif (p1 < 0) x = -0.5 * (p1 - sqrt(disc));\n\t\t\t\t\t\t\telse x = -0.5 * (p1 + sqrt(disc));\n\t\t\t\t\t\t\tn1 = (a - x) * (a - x) + b * b;\n\t\t\t\t\t\t\tn2 = c * c + (d - x) * (d - x);\n\t\t\t\t\t\t\tif (n1 > n2) {\n\t\t\t\t\t\t\t\tn1 = sqrt(n1);\n\t\t\t\t\t\t\t\tp = (a - x) / n1;\n\t\t\t\t\t\t\t\tq = b / n1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tn2 = sqrt(n2);\n\t\t\t\t\t\t\t\tp = c / n2;\n\t\t\t\t\t\t\t\tq = (d - x) / n2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ0 = new T([\n\t\t\t\t\t\t\t\t[q, -p],\n\t\t\t\t\t\t\t\t[p, q]\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\tQ.setRows(i, j, Q0.dot(Q.getRows(i, j)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tx = -0.5 * p1;\n\t\t\t\t\t\t\ty = 0.5 * sqrt(-disc);\n\t\t\t\t\t\t\tn1 = (a - x) * (a - x) + b * b;\n\t\t\t\t\t\t\tn2 = c * c + (d - x) * (d - x);\n\t\t\t\t\t\t\tif (n1 > n2) {\n\t\t\t\t\t\t\t\tn1 = sqrt(n1 + y * y);\n\t\t\t\t\t\t\t\tp = (a - x) / n1;\n\t\t\t\t\t\t\t\tq = b / n1;\n\t\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\t\ty /= n1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tn2 = sqrt(n2 + y * y);\n\t\t\t\t\t\t\t\tp = c / n2;\n\t\t\t\t\t\t\t\tq = (d - x) / n2;\n\t\t\t\t\t\t\t\tx = y / n2;\n\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ0 = new T([\n\t\t\t\t\t\t\t\t[q, -p],\n\t\t\t\t\t\t\t\t[p, q]\n\t\t\t\t\t\t\t], [\n\t\t\t\t\t\t\t\t[x, y],\n\t\t\t\t\t\t\t\t[y, -x]\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\tQ.setRows(i, j, Q0.dot(Q.getRows(i, j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar R = Q.dot(A).dot(Q.transjugate()),\n\t\t\t\t\tn = A.length,\n\t\t\t\t\tE = numeric.T.identity(n);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tfor (k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tvar Rk = R.get([k, k]),\n\t\t\t\t\t\t\t\tRj = R.get([j, j]);\n\t\t\t\t\t\t\tif (numeric.neq(Rk.x, Rj.x) || numeric.neq(Rk.y, Rj.y)) {\n\t\t\t\t\t\t\t\tx = R.getRow(k).getBlock([k], [j - 1]);\n\t\t\t\t\t\t\t\ty = E.getRow(j).getBlock([k], [j - 1]);\n\t\t\t\t\t\t\t\tE.set([j, k], (R.get([k, j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tE.setRow(j, E.getRow(k));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tx = E.getRow(j);\n\t\t\t\t\tE.setRow(j, x.div(x.norm2()));\n\t\t\t\t}\n\t\t\t\tE = E.transpose();\n\t\t\t\tE = Q.transjugate().dot(E);\n\t\t\t\treturn {\n\t\t\t\t\tlambda: R.getDiag(),\n\t\t\t\t\tE: E\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// 5. Compressed Column Storage matrices\n\t\t\tnumeric.ccsSparse = function ccsSparse(A) {\n\t\t\t\tvar m = A.length,\n\t\t\t\t\tn, foo, i, j, counts = [];\n\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\tfoo = A[i];\n\t\t\t\t\tfor (j in foo) {\n\t\t\t\t\t\tj = parseInt(j);\n\t\t\t\t\t\twhile (j >= counts.length) counts[counts.length] = 0;\n\t\t\t\t\t\tif (foo[j] !== 0) counts[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar n = counts.length;\n\t\t\t\tvar Ai = Array(n + 1);\n\t\t\t\tAi[0] = 0;\n\t\t\t\tfor (i = 0; i < n; ++i) Ai[i + 1] = Ai[i] + counts[i];\n\t\t\t\tvar Aj = Array(Ai[n]),\n\t\t\t\t\tAv = Array(Ai[n]);\n\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\tfoo = A[i];\n\t\t\t\t\tfor (j in foo) {\n\t\t\t\t\t\tif (foo[j] !== 0) {\n\t\t\t\t\t\t\tcounts[j]--;\n\t\t\t\t\t\t\tAj[Ai[j] + counts[j]] = i;\n\t\t\t\t\t\t\tAv[Ai[j] + counts[j]] = foo[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [Ai, Aj, Av];\n\t\t\t};\n\t\t\tnumeric.ccsFull = function ccsFull(A) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\ts = numeric.ccsDim(A),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1],\n\t\t\t\t\ti, j, j0, j1, k;\n\t\t\t\tvar B = numeric.rep([m, n], 0);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tj0 = Ai[i];\n\t\t\t\t\tj1 = Ai[i + 1];\n\t\t\t\t\tfor (j = j0; j < j1; ++j) {\n\t\t\t\t\t\tB[Aj[j]][i] = Av[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn B;\n\t\t\t};\n\t\t\tnumeric.ccsTSolve = function ccsTSolve(A, b, x, bj, xj) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tm = Ai.length - 1,\n\t\t\t\t\tmax = Math.max,\n\t\t\t\t\tn = 0;\n\t\t\t\tif (typeof bj === \"undefined\") x = numeric.rep([m], 0);\n\t\t\t\tif (typeof bj === \"undefined\") bj = numeric.linspace(0, x.length - 1);\n\t\t\t\tif (typeof xj === \"undefined\") xj = [];\n\n\t\t\t\tfunction dfs(j) {\n\t\t\t\t\tvar k;\n\t\t\t\t\tif (x[j] !== 0) return;\n\t\t\t\t\tx[j] = 1;\n\t\t\t\t\tfor (k = Ai[j]; k < Ai[j + 1]; ++k) dfs(Aj[k]);\n\t\t\t\t\txj[n] = j;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\tvar i, j, j0, j1, k, l, l0, l1, a;\n\t\t\t\tfor (i = bj.length - 1; i !== -1; --i) {\n\t\t\t\t\tdfs(bj[i]);\n\t\t\t\t}\n\t\t\t\txj.length = n;\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tx[xj[i]] = 0;\n\t\t\t\t}\n\t\t\t\tfor (i = bj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = bj[i];\n\t\t\t\t\tx[j] = b[j];\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\tj0 = Ai[j];\n\t\t\t\t\tj1 = max(Ai[j + 1], j0);\n\t\t\t\t\tfor (k = j0; k !== j1; ++k) {\n\t\t\t\t\t\tif (Aj[k] === j) {\n\t\t\t\t\t\t\tx[j] /= Av[k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = x[j];\n\t\t\t\t\tfor (k = j0; k !== j1; ++k) {\n\t\t\t\t\t\tl = Aj[k];\n\t\t\t\t\t\tif (l !== j) x[l] -= a * Av[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t};\n\t\t\tnumeric.ccsDFS = function ccsDFS(n) {\n\t\t\t\tthis.k = Array(n);\n\t\t\t\tthis.k1 = Array(n);\n\t\t\t\tthis.j = Array(n);\n\t\t\t};\n\t\t\tnumeric.ccsDFS.prototype.dfs = function dfs(J, Ai, Aj, x, xj, Pinv) {\n\t\t\t\tvar m = 0,\n\t\t\t\t\tfoo, n = xj.length;\n\t\t\t\tvar k = this.k,\n\t\t\t\t\tk1 = this.k1,\n\t\t\t\t\tj = this.j,\n\t\t\t\t\tkm, k11;\n\t\t\t\tif (x[J] !== 0) return;\n\t\t\t\tx[J] = 1;\n\t\t\t\tj[0] = J;\n\t\t\t\tk[0] = km = Ai[J];\n\t\t\t\tk1[0] = k11 = Ai[J + 1];\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (km >= k11) {\n\t\t\t\t\t\txj[n] = j[m];\n\t\t\t\t\t\tif (m === 0) return;\n\t\t\t\t\t\t++n;\n\t\t\t\t\t\t--m;\n\t\t\t\t\t\tkm = k[m];\n\t\t\t\t\t\tk11 = k1[m];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfoo = Pinv[Aj[km]];\n\t\t\t\t\t\tif (x[foo] === 0) {\n\t\t\t\t\t\t\tx[foo] = 1;\n\t\t\t\t\t\t\tk[m] = km;\n\t\t\t\t\t\t\t++m;\n\t\t\t\t\t\t\tj[m] = foo;\n\t\t\t\t\t\t\tkm = Ai[foo];\n\t\t\t\t\t\t\tk1[m] = k11 = Ai[foo + 1];\n\t\t\t\t\t\t} else ++km;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ccsLPSolve = function ccsLPSolve(A, B, x, xj, I, Pinv, dfs) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tm = Ai.length - 1,\n\t\t\t\t\tn = 0;\n\t\t\t\tvar Bi = B[0],\n\t\t\t\t\tBj = B[1],\n\t\t\t\t\tBv = B[2];\n\n\t\t\t\tvar i, i0, i1, j, J, j0, j1, k, l, l0, l1, a;\n\t\t\t\ti0 = Bi[I];\n\t\t\t\ti1 = Bi[I + 1];\n\t\t\t\txj.length = 0;\n\t\t\t\tfor (i = i0; i < i1; ++i) {\n\t\t\t\t\tdfs.dfs(Pinv[Bj[i]], Ai, Aj, x, xj, Pinv);\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tx[xj[i]] = 0;\n\t\t\t\t}\n\t\t\t\tfor (i = i0; i !== i1; ++i) {\n\t\t\t\t\tj = Pinv[Bj[i]];\n\t\t\t\t\tx[j] = Bv[i];\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\tj0 = Ai[j];\n\t\t\t\t\tj1 = Ai[j + 1];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) {\n\t\t\t\t\t\tif (Pinv[Aj[k]] === j) {\n\t\t\t\t\t\t\tx[j] /= Av[k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = x[j];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) {\n\t\t\t\t\t\tl = Pinv[Aj[k]];\n\t\t\t\t\t\tif (l !== j) x[l] -= a * Av[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t};\n\t\t\tnumeric.ccsLUP1 = function ccsLUP1(A, threshold) {\n\t\t\t\tvar m = A[0].length - 1;\n\t\t\t\tvar L = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t],\n\t\t\t\t\tU = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t];\n\t\t\t\tvar Li = L[0],\n\t\t\t\t\tLj = L[1],\n\t\t\t\t\tLv = L[2],\n\t\t\t\t\tUi = U[0],\n\t\t\t\t\tUj = U[1],\n\t\t\t\t\tUv = U[2];\n\t\t\t\tvar x = numeric.rep([m], 0),\n\t\t\t\t\txj = numeric.rep([m], 0);\n\t\t\t\tvar i, j, k, j0, j1, a, e, c, d, K;\n\t\t\t\tvar sol = numeric.ccsLPSolve,\n\t\t\t\t\tmax = Math.max,\n\t\t\t\t\tabs = Math.abs;\n\t\t\t\tvar P = numeric.linspace(0, m - 1),\n\t\t\t\t\tPinv = numeric.linspace(0, m - 1);\n\t\t\t\tvar dfs = new numeric.ccsDFS(m);\n\t\t\t\tif (typeof threshold === \"undefined\") {\n\t\t\t\t\tthreshold = 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tsol(L, A, x, xj, i, Pinv, dfs);\n\t\t\t\t\ta = -1;\n\t\t\t\t\te = -1;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tif (k <= i) continue;\n\t\t\t\t\t\tc = abs(x[k]);\n\t\t\t\t\t\tif (c > a) {\n\t\t\t\t\t\t\te = k;\n\t\t\t\t\t\t\ta = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(x[i]) < threshold * a) {\n\t\t\t\t\t\tj = P[i];\n\t\t\t\t\t\ta = P[e];\n\t\t\t\t\t\tP[i] = a;\n\t\t\t\t\t\tPinv[a] = i;\n\t\t\t\t\t\tP[e] = j;\n\t\t\t\t\t\tPinv[j] = e;\n\t\t\t\t\t\ta = x[i];\n\t\t\t\t\t\tx[i] = x[e];\n\t\t\t\t\t\tx[e] = a;\n\t\t\t\t\t}\n\t\t\t\t\ta = Li[i];\n\t\t\t\t\te = Ui[i];\n\t\t\t\t\td = x[i];\n\t\t\t\t\tLj[a] = P[i];\n\t\t\t\t\tLv[a] = 1;\n\t\t\t\t\t++a;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tc = x[k];\n\t\t\t\t\t\txj[j] = 0;\n\t\t\t\t\t\tx[k] = 0;\n\t\t\t\t\t\tif (k <= i) {\n\t\t\t\t\t\t\tUj[e] = k;\n\t\t\t\t\t\t\tUv[e] = c;\n\t\t\t\t\t\t\t++e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLj[a] = P[k];\n\t\t\t\t\t\t\tLv[a] = c / d;\n\t\t\t\t\t\t\t++a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLi[i + 1] = a;\n\t\t\t\t\tUi[i + 1] = e;\n\t\t\t\t}\n\t\t\t\tfor (j = Lj.length - 1; j !== -1; --j) {\n\t\t\t\t\tLj[j] = Pinv[Lj[j]];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tL: L,\n\t\t\t\t\tU: U,\n\t\t\t\t\tP: P,\n\t\t\t\t\tPinv: Pinv\n\t\t\t\t};\n\t\t\t};\n\t\t\tnumeric.ccsDFS0 = function ccsDFS0(n) {\n\t\t\t\tthis.k = Array(n);\n\t\t\t\tthis.k1 = Array(n);\n\t\t\t\tthis.j = Array(n);\n\t\t\t};\n\t\t\tnumeric.ccsDFS0.prototype.dfs = function dfs(J, Ai, Aj, x, xj, Pinv, P) {\n\t\t\t\tvar m = 0,\n\t\t\t\t\tfoo, n = xj.length;\n\t\t\t\tvar k = this.k,\n\t\t\t\t\tk1 = this.k1,\n\t\t\t\t\tj = this.j,\n\t\t\t\t\tkm, k11;\n\t\t\t\tif (x[J] !== 0) return;\n\t\t\t\tx[J] = 1;\n\t\t\t\tj[0] = J;\n\t\t\t\tk[0] = km = Ai[Pinv[J]];\n\t\t\t\tk1[0] = k11 = Ai[Pinv[J] + 1];\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (isNaN(km)) throw new Error(\"Ow!\");\n\t\t\t\t\tif (km >= k11) {\n\t\t\t\t\t\txj[n] = Pinv[j[m]];\n\t\t\t\t\t\tif (m === 0) return;\n\t\t\t\t\t\t++n;\n\t\t\t\t\t\t--m;\n\t\t\t\t\t\tkm = k[m];\n\t\t\t\t\t\tk11 = k1[m];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfoo = Aj[km];\n\t\t\t\t\t\tif (x[foo] === 0) {\n\t\t\t\t\t\t\tx[foo] = 1;\n\t\t\t\t\t\t\tk[m] = km;\n\t\t\t\t\t\t\t++m;\n\t\t\t\t\t\t\tj[m] = foo;\n\t\t\t\t\t\t\tfoo = Pinv[foo];\n\t\t\t\t\t\t\tkm = Ai[foo];\n\t\t\t\t\t\t\tk1[m] = k11 = Ai[foo + 1];\n\t\t\t\t\t\t} else ++km;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ccsLPSolve0 = function ccsLPSolve0(A, B, y, xj, I, Pinv, P, dfs) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tm = Ai.length - 1,\n\t\t\t\t\tn = 0;\n\t\t\t\tvar Bi = B[0],\n\t\t\t\t\tBj = B[1],\n\t\t\t\t\tBv = B[2];\n\n\t\t\t\tvar i, i0, i1, j, J, j0, j1, k, l, l0, l1, a;\n\t\t\t\ti0 = Bi[I];\n\t\t\t\ti1 = Bi[I + 1];\n\t\t\t\txj.length = 0;\n\t\t\t\tfor (i = i0; i < i1; ++i) {\n\t\t\t\t\tdfs.dfs(Bj[i], Ai, Aj, y, xj, Pinv, P);\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\ty[P[j]] = 0;\n\t\t\t\t}\n\t\t\t\tfor (i = i0; i !== i1; ++i) {\n\t\t\t\t\tj = Bj[i];\n\t\t\t\t\ty[j] = Bv[i];\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\tl = P[j];\n\t\t\t\t\tj0 = Ai[j];\n\t\t\t\t\tj1 = Ai[j + 1];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) {\n\t\t\t\t\t\tif (Aj[k] === l) {\n\t\t\t\t\t\t\ty[l] /= Av[k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = y[l];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) y[Aj[k]] -= a * Av[k];\n\t\t\t\t\ty[l] = a;\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ccsLUP0 = function ccsLUP0(A, threshold) {\n\t\t\t\tvar m = A[0].length - 1;\n\t\t\t\tvar L = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t],\n\t\t\t\t\tU = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t];\n\t\t\t\tvar Li = L[0],\n\t\t\t\t\tLj = L[1],\n\t\t\t\t\tLv = L[2],\n\t\t\t\t\tUi = U[0],\n\t\t\t\t\tUj = U[1],\n\t\t\t\t\tUv = U[2];\n\t\t\t\tvar y = numeric.rep([m], 0),\n\t\t\t\t\txj = numeric.rep([m], 0);\n\t\t\t\tvar i, j, k, j0, j1, a, e, c, d, K;\n\t\t\t\tvar sol = numeric.ccsLPSolve0,\n\t\t\t\t\tmax = Math.max,\n\t\t\t\t\tabs = Math.abs;\n\t\t\t\tvar P = numeric.linspace(0, m - 1),\n\t\t\t\t\tPinv = numeric.linspace(0, m - 1);\n\t\t\t\tvar dfs = new numeric.ccsDFS0(m);\n\t\t\t\tif (typeof threshold === \"undefined\") {\n\t\t\t\t\tthreshold = 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tsol(L, A, y, xj, i, Pinv, P, dfs);\n\t\t\t\t\ta = -1;\n\t\t\t\t\te = -1;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tif (k <= i) continue;\n\t\t\t\t\t\tc = abs(y[P[k]]);\n\t\t\t\t\t\tif (c > a) {\n\t\t\t\t\t\t\te = k;\n\t\t\t\t\t\t\ta = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(y[P[i]]) < threshold * a) {\n\t\t\t\t\t\tj = P[i];\n\t\t\t\t\t\ta = P[e];\n\t\t\t\t\t\tP[i] = a;\n\t\t\t\t\t\tPinv[a] = i;\n\t\t\t\t\t\tP[e] = j;\n\t\t\t\t\t\tPinv[j] = e;\n\t\t\t\t\t}\n\t\t\t\t\ta = Li[i];\n\t\t\t\t\te = Ui[i];\n\t\t\t\t\td = y[P[i]];\n\t\t\t\t\tLj[a] = P[i];\n\t\t\t\t\tLv[a] = 1;\n\t\t\t\t\t++a;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tc = y[P[k]];\n\t\t\t\t\t\txj[j] = 0;\n\t\t\t\t\t\ty[P[k]] = 0;\n\t\t\t\t\t\tif (k <= i) {\n\t\t\t\t\t\t\tUj[e] = k;\n\t\t\t\t\t\t\tUv[e] = c;\n\t\t\t\t\t\t\t++e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLj[a] = P[k];\n\t\t\t\t\t\t\tLv[a] = c / d;\n\t\t\t\t\t\t\t++a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLi[i + 1] = a;\n\t\t\t\t\tUi[i + 1] = e;\n\t\t\t\t}\n\t\t\t\tfor (j = Lj.length - 1; j !== -1; --j) {\n\t\t\t\t\tLj[j] = Pinv[Lj[j]];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tL: L,\n\t\t\t\t\tU: U,\n\t\t\t\t\tP: P,\n\t\t\t\t\tPinv: Pinv\n\t\t\t\t};\n\t\t\t};\n\t\t\tnumeric.ccsLUP = numeric.ccsLUP0;\n\n\t\t\tnumeric.ccsDim = function ccsDim(A) {\n\t\t\t\treturn [numeric.sup(A[1]) + 1, A[0].length - 1];\n\t\t\t};\n\t\t\tnumeric.ccsGetBlock = function ccsGetBlock(A, i, j) {\n\t\t\t\tvar s = numeric.ccsDim(A),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1];\n\t\t\t\tif (typeof i === \"undefined\") {\n\t\t\t\t\ti = numeric.linspace(0, m - 1);\n\t\t\t\t} else if (typeof i === \"number\") {\n\t\t\t\t\ti = [i];\n\t\t\t\t}\n\t\t\t\tif (typeof j === \"undefined\") {\n\t\t\t\t\tj = numeric.linspace(0, n - 1);\n\t\t\t\t} else if (typeof j === \"number\") {\n\t\t\t\t\tj = [j];\n\t\t\t\t}\n\t\t\t\tvar p, p0, p1, P = i.length,\n\t\t\t\t\tq, Q = j.length,\n\t\t\t\t\tr, jq, ip;\n\t\t\t\tvar Bi = numeric.rep([n], 0),\n\t\t\t\t\tBj = [],\n\t\t\t\t\tBv = [],\n\t\t\t\t\tB = [Bi, Bj, Bv];\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar x = numeric.rep([m], 0),\n\t\t\t\t\tcount = 0,\n\t\t\t\t\tflags = numeric.rep([m], 0);\n\t\t\t\tfor (q = 0; q < Q; ++q) {\n\t\t\t\t\tjq = j[q];\n\t\t\t\t\tq0 = Ai[jq];\n\t\t\t\t\tq1 = Ai[jq + 1];\n\t\t\t\t\tfor (p = q0; p < q1; ++p) {\n\t\t\t\t\t\tr = Aj[p];\n\t\t\t\t\t\tflags[r] = 1;\n\t\t\t\t\t\tx[r] = Av[p];\n\t\t\t\t\t}\n\t\t\t\t\tfor (p = 0; p < P; ++p) {\n\t\t\t\t\t\tip = i[p];\n\t\t\t\t\t\tif (flags[ip]) {\n\t\t\t\t\t\t\tBj[count] = p;\n\t\t\t\t\t\t\tBv[count] = x[i[p]];\n\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (p = q0; p < q1; ++p) {\n\t\t\t\t\t\tr = Aj[p];\n\t\t\t\t\t\tflags[r] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tBi[q + 1] = count;\n\t\t\t\t}\n\t\t\t\treturn B;\n\t\t\t};\n\n\t\t\tnumeric.ccsDot = function ccsDot(A, B) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar Bi = B[0],\n\t\t\t\t\tBj = B[1],\n\t\t\t\t\tBv = B[2];\n\t\t\t\tvar sA = numeric.ccsDim(A),\n\t\t\t\t\tsB = numeric.ccsDim(B);\n\t\t\t\tvar m = sA[0],\n\t\t\t\t\tn = sA[1],\n\t\t\t\t\to = sB[1];\n\t\t\t\tvar x = numeric.rep([m], 0),\n\t\t\t\t\tflags = numeric.rep([m], 0),\n\t\t\t\t\txj = Array(m);\n\t\t\t\tvar Ci = numeric.rep([o], 0),\n\t\t\t\t\tCj = [],\n\t\t\t\t\tCv = [],\n\t\t\t\t\tC = [Ci, Cj, Cv];\n\t\t\t\tvar i, j, k, j0, j1, i0, i1, l, p, a, b;\n\t\t\t\tfor (k = 0; k !== o; ++k) {\n\t\t\t\t\tj0 = Bi[k];\n\t\t\t\t\tj1 = Bi[k + 1];\n\t\t\t\t\tp = 0;\n\t\t\t\t\tfor (j = j0; j < j1; ++j) {\n\t\t\t\t\t\ta = Bj[j];\n\t\t\t\t\t\tb = Bv[j];\n\t\t\t\t\t\ti0 = Ai[a];\n\t\t\t\t\t\ti1 = Ai[a + 1];\n\t\t\t\t\t\tfor (i = i0; i < i1; ++i) {\n\t\t\t\t\t\t\tl = Aj[i];\n\t\t\t\t\t\t\tif (flags[l] === 0) {\n\t\t\t\t\t\t\t\txj[p] = l;\n\t\t\t\t\t\t\t\tflags[l] = 1;\n\t\t\t\t\t\t\t\tp = p + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx[l] = x[l] + Av[i] * b;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj0 = Ci[k];\n\t\t\t\t\tj1 = j0 + p;\n\t\t\t\t\tCi[k + 1] = j1;\n\t\t\t\t\tfor (j = p - 1; j !== -1; --j) {\n\t\t\t\t\t\tb = j0 + j;\n\t\t\t\t\t\ti = xj[j];\n\t\t\t\t\t\tCj[b] = i;\n\t\t\t\t\t\tCv[b] = x[i];\n\t\t\t\t\t\tflags[i] = 0;\n\t\t\t\t\t\tx[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tCi[k + 1] = Ci[k] + p;\n\t\t\t\t}\n\t\t\t\treturn C;\n\t\t\t};\n\n\t\t\tnumeric.ccsLUPSolve = function ccsLUPSolve(LUP, B) {\n\t\t\t\tvar L = LUP.L,\n\t\t\t\t\tU = LUP.U,\n\t\t\t\t\tP = LUP.P;\n\t\t\t\tvar Bi = B[0];\n\t\t\t\tvar flag = false;\n\t\t\t\tif (typeof Bi !== \"object\") {\n\t\t\t\t\tB = [\n\t\t\t\t\t\t[0, B.length], numeric.linspace(0, B.length - 1), B\n\t\t\t\t\t];\n\t\t\t\t\tBi = B[0];\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tvar Bj = B[1],\n\t\t\t\t\tBv = B[2];\n\t\t\t\tvar n = L[0].length - 1,\n\t\t\t\t\tm = Bi.length - 1;\n\t\t\t\tvar x = numeric.rep([n], 0),\n\t\t\t\t\txj = Array(n);\n\t\t\t\tvar b = numeric.rep([n], 0),\n\t\t\t\t\tbj = Array(n);\n\t\t\t\tvar Xi = numeric.rep([m + 1], 0),\n\t\t\t\t\tXj = [],\n\t\t\t\t\tXv = [];\n\t\t\t\tvar sol = numeric.ccsTSolve;\n\t\t\t\tvar i, j, j0, j1, k, J, N = 0;\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tk = 0;\n\t\t\t\t\tj0 = Bi[i];\n\t\t\t\t\tj1 = Bi[i + 1];\n\t\t\t\t\tfor (j = j0; j < j1; ++j) {\n\t\t\t\t\t\tJ = LUP.Pinv[Bj[j]];\n\t\t\t\t\t\tbj[k] = J;\n\t\t\t\t\t\tb[J] = Bv[j];\n\t\t\t\t\t\t++k;\n\t\t\t\t\t}\n\t\t\t\t\tbj.length = k;\n\t\t\t\t\tsol(L, b, x, bj, xj);\n\t\t\t\t\tfor (j = bj.length - 1; j !== -1; --j) b[bj[j]] = 0;\n\t\t\t\t\tsol(U, x, b, xj, bj);\n\t\t\t\t\tif (flag) return b;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) x[xj[j]] = 0;\n\t\t\t\t\tfor (j = bj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tJ = bj[j];\n\t\t\t\t\t\tXj[N] = J;\n\t\t\t\t\t\tXv[N] = b[J];\n\t\t\t\t\t\tb[J] = 0;\n\t\t\t\t\t\t++N;\n\t\t\t\t\t}\n\t\t\t\t\tXi[i + 1] = N;\n\t\t\t\t}\n\t\t\t\treturn [Xi, Xj, Xv];\n\t\t\t};\n\n\t\t\tnumeric.ccsbinop = function ccsbinop(body, setup) {\n\t\t\t\tif (typeof setup === \"undefined\") setup = '';\n\t\t\t\treturn numeric.Function('X', 'Y',\n\t\t\t\t\t'var Xi = X[0], Xj = X[1], Xv = X[2];\\n' +\n\t\t\t\t\t'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\\n' +\n\t\t\t\t\t'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\\n' +\n\t\t\t\t\t'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\\n' +\n\t\t\t\t\t'var x = numeric.rep([m],0),y = numeric.rep([m],0);\\n' +\n\t\t\t\t\t'var xk,yk,zk;\\n' +\n\t\t\t\t\t'var i,j,j0,j1,k,p=0;\\n' +\n\t\t\t\t\tsetup +\n\t\t\t\t\t'for(i=0;i<n;++i) {\\n' +\n\t\t\t\t\t'  j0 = Xi[i]; j1 = Xi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) {\\n' +\n\t\t\t\t\t'    k = Xj[j];\\n' +\n\t\t\t\t\t'    x[k] = 1;\\n' +\n\t\t\t\t\t'    Zj[p] = k;\\n' +\n\t\t\t\t\t'    ++p;\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  j0 = Yi[i]; j1 = Yi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) {\\n' +\n\t\t\t\t\t'    k = Yj[j];\\n' +\n\t\t\t\t\t'    y[k] = Yv[j];\\n' +\n\t\t\t\t\t'    if(x[k] === 0) {\\n' +\n\t\t\t\t\t'      Zj[p] = k;\\n' +\n\t\t\t\t\t'      ++p;\\n' +\n\t\t\t\t\t'    }\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  Zi[i+1] = p;\\n' +\n\t\t\t\t\t'  j0 = Xi[i]; j1 = Xi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\\n' +\n\t\t\t\t\t'  j0 = Zi[i]; j1 = Zi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) {\\n' +\n\t\t\t\t\t'    k = Zj[j];\\n' +\n\t\t\t\t\t'    xk = x[k];\\n' +\n\t\t\t\t\t'    yk = y[k];\\n' +\n\t\t\t\t\tbody + '\\n' +\n\t\t\t\t\t'    Zv[j] = zk;\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  j0 = Xi[i]; j1 = Xi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\\n' +\n\t\t\t\t\t'  j0 = Yi[i]; j1 = Yi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return [Zi,Zj,Zv];'\n\t\t\t\t);\n\t\t\t};\n\n\t\t\t(function() {\n\t\t\t\tvar k, A, B, C;\n\t\t\t\tfor (k in numeric.ops2) {\n\t\t\t\t\tif (isFinite(eval('1' + numeric.ops2[k] + '0'))) A = '[Y[0],Y[1],numeric.' + k + '(X,Y[2])]';\n\t\t\t\t\telse A = 'NaN';\n\t\t\t\t\tif (isFinite(eval('0' + numeric.ops2[k] + '1'))) B = '[X[0],X[1],numeric.' + k + '(X[2],Y)]';\n\t\t\t\t\telse B = 'NaN';\n\t\t\t\t\tif (isFinite(eval('1' + numeric.ops2[k] + '0')) && isFinite(eval('0' + numeric.ops2[k] + '1'))) C = 'numeric.ccs' + k + 'MM(X,Y)';\n\t\t\t\t\telse C = 'NaN';\n\t\t\t\t\tnumeric['ccs' + k + 'MM'] = numeric.ccsbinop('zk = xk ' + numeric.ops2[k] + 'yk;');\n\t\t\t\t\tnumeric['ccs' + k] = numeric.Function('X', 'Y',\n\t\t\t\t\t\t'if(typeof X === \"number\") return ' + A + ';\\n' +\n\t\t\t\t\t\t'if(typeof Y === \"number\") return ' + B + ';\\n' +\n\t\t\t\t\t\t'return ' + C + ';\\n'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}());\n\n\t\t\tnumeric.ccsScatter = function ccsScatter(A) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar n = numeric.sup(Aj) + 1,\n\t\t\t\t\tm = Ai.length;\n\t\t\t\tvar Ri = numeric.rep([n], 0),\n\t\t\t\t\tRj = Array(m),\n\t\t\t\t\tRv = Array(m);\n\t\t\t\tvar counts = numeric.rep([n], 0),\n\t\t\t\t\ti;\n\t\t\t\tfor (i = 0; i < m; ++i) counts[Aj[i]]++;\n\t\t\t\tfor (i = 0; i < n; ++i) Ri[i + 1] = Ri[i] + counts[i];\n\t\t\t\tvar ptr = Ri.slice(0),\n\t\t\t\t\tk, Aii;\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tAii = Aj[i];\n\t\t\t\t\tk = ptr[Aii];\n\t\t\t\t\tRj[k] = Ai[i];\n\t\t\t\t\tRv[k] = Av[i];\n\t\t\t\t\tptr[Aii] = ptr[Aii] + 1;\n\t\t\t\t}\n\t\t\t\treturn [Ri, Rj, Rv];\n\t\t\t};\n\n\t\t\tnumeric.ccsGather = function ccsGather(A) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar n = Ai.length - 1,\n\t\t\t\t\tm = Aj.length;\n\t\t\t\tvar Ri = Array(m),\n\t\t\t\t\tRj = Array(m),\n\t\t\t\t\tRv = Array(m);\n\t\t\t\tvar i, j, j0, j1, p;\n\t\t\t\tp = 0;\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tj0 = Ai[i];\n\t\t\t\t\tj1 = Ai[i + 1];\n\t\t\t\t\tfor (j = j0; j !== j1; ++j) {\n\t\t\t\t\t\tRj[p] = i;\n\t\t\t\t\t\tRi[p] = Aj[j];\n\t\t\t\t\t\tRv[p] = Av[j];\n\t\t\t\t\t\t++p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [Ri, Rj, Rv];\n\t\t\t};\n\n\t\t\t// The following sparse linear algebra routines are deprecated.\n\n\t\t\tnumeric.sdim = function dim(A, ret, k) {\n\t\t\t\tif (typeof ret === \"undefined\") {\n\t\t\t\t\tret = [];\n\t\t\t\t}\n\t\t\t\tif (typeof A !== \"object\") return ret;\n\t\t\t\tif (typeof k === \"undefined\") {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tif (!(k in ret)) {\n\t\t\t\t\tret[k] = 0;\n\t\t\t\t}\n\t\t\t\tif (A.length > ret[k]) ret[k] = A.length;\n\t\t\t\tvar i;\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (A.hasOwnProperty(i)) dim(A[i], ret, k + 1);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sclone = function clone(A, k, n) {\n\t\t\t\tif (typeof k === \"undefined\") {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tif (typeof n === \"undefined\") {\n\t\t\t\t\tn = numeric.sdim(A).length;\n\t\t\t\t}\n\t\t\t\tvar i, ret = Array(A.length);\n\t\t\t\tif (k === n - 1) {\n\t\t\t\t\tfor (i in A) {\n\t\t\t\t\t\tif (A.hasOwnProperty(i)) ret[i] = A[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (A.hasOwnProperty(i)) ret[i] = clone(A[i], k + 1, n);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdiag = function diag(d) {\n\t\t\t\tvar n = d.length,\n\t\t\t\t\ti, ret = Array(n),\n\t\t\t\t\ti1, i2, i3;\n\t\t\t\tfor (i = n - 1; i >= 1; i -= 2) {\n\t\t\t\t\ti1 = i - 1;\n\t\t\t\t\tret[i] = [];\n\t\t\t\t\tret[i][i] = d[i];\n\t\t\t\t\tret[i1] = [];\n\t\t\t\t\tret[i1][i1] = d[i1];\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tret[0] = [];\n\t\t\t\t\tret[0][0] = d[i];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sidentity = function identity(n) {\n\t\t\t\treturn numeric.sdiag(numeric.rep([n], 1));\n\t\t\t};\n\n\t\t\tnumeric.stranspose = function transpose(A) {\n\t\t\t\tvar ret = [],\n\t\t\t\t\tn = A.length,\n\t\t\t\t\ti, j, Ai;\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (!(A.hasOwnProperty(i))) continue;\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\tif (!(Ai.hasOwnProperty(j))) continue;\n\t\t\t\t\t\tif (typeof ret[j] !== \"object\") {\n\t\t\t\t\t\t\tret[j] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret[j][i] = Ai[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sLUP = function LUP(A, tol) {\n\t\t\t\tthrow new Error(\"The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.\");\n\t\t\t};\n\n\t\t\tnumeric.sdotMM = function dotMM(A, B) {\n\t\t\t\tvar p = A.length,\n\t\t\t\t\tq = B.length,\n\t\t\t\t\tBT = numeric.stranspose(B),\n\t\t\t\t\tr = BT.length,\n\t\t\t\t\tAi, BTk;\n\t\t\t\tvar i, j, k, accum;\n\t\t\t\tvar ret = Array(p),\n\t\t\t\t\treti;\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\treti = [];\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\tfor (k = r - 1; k >= 0; k--) {\n\t\t\t\t\t\taccum = 0;\n\t\t\t\t\t\tBTk = BT[k];\n\t\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\t\tif (!(Ai.hasOwnProperty(j))) continue;\n\t\t\t\t\t\t\tif (j in BTk) {\n\t\t\t\t\t\t\t\taccum += Ai[j] * BTk[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accum) reti[k] = accum;\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = reti;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdotMV = function dotMV(A, x) {\n\t\t\t\tvar p = A.length,\n\t\t\t\t\tAi, i, j;\n\t\t\t\tvar ret = Array(p),\n\t\t\t\t\taccum;\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\taccum = 0;\n\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\tif (!(Ai.hasOwnProperty(j))) continue;\n\t\t\t\t\t\tif (x[j]) accum += Ai[j] * x[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (accum) ret[i] = accum;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdotVM = function dotMV(x, A) {\n\t\t\t\tvar i, j, Ai, alpha;\n\t\t\t\tvar ret = [],\n\t\t\t\t\taccum;\n\t\t\t\tfor (i in x) {\n\t\t\t\t\tif (!x.hasOwnProperty(i)) continue;\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\talpha = x[i];\n\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\tif (!Ai.hasOwnProperty(j)) continue;\n\t\t\t\t\t\tif (!ret[j]) {\n\t\t\t\t\t\t\tret[j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret[j] += alpha * Ai[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdotVV = function dotVV(x, y) {\n\t\t\t\tvar i, ret = 0;\n\t\t\t\tfor (i in x) {\n\t\t\t\t\tif (x[i] && y[i]) ret += x[i] * y[i];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdot = function dot(A, B) {\n\t\t\t\tvar m = numeric.sdim(A).length,\n\t\t\t\t\tn = numeric.sdim(B).length;\n\t\t\t\tvar k = m * 1000 + n;\n\t\t\t\tswitch (k) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn A * B;\n\t\t\t\t\tcase 1001:\n\t\t\t\t\t\treturn numeric.sdotVV(A, B);\n\t\t\t\t\tcase 2001:\n\t\t\t\t\t\treturn numeric.sdotMV(A, B);\n\t\t\t\t\tcase 1002:\n\t\t\t\t\t\treturn numeric.sdotVM(A, B);\n\t\t\t\t\tcase 2002:\n\t\t\t\t\t\treturn numeric.sdotMM(A, B);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('numeric.sdot not implemented for tensors of order ' + m + ' and ' + n);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnumeric.sscatter = function scatter(V) {\n\t\t\t\tvar n = V[0].length,\n\t\t\t\t\tVij, i, j, m = V.length,\n\t\t\t\t\tA = [],\n\t\t\t\t\tAj;\n\t\t\t\tfor (i = n - 1; i >= 0; --i) {\n\t\t\t\t\tif (!V[m - 1][i]) continue;\n\t\t\t\t\tAj = A;\n\t\t\t\t\tfor (j = 0; j < m - 2; j++) {\n\t\t\t\t\t\tVij = V[j][i];\n\t\t\t\t\t\tif (!Aj[Vij]) Aj[Vij] = [];\n\t\t\t\t\t\tAj = Aj[Vij];\n\t\t\t\t\t}\n\t\t\t\t\tAj[V[j][i]] = V[j + 1][i];\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\n\t\t\tnumeric.sgather = function gather(A, ret, k) {\n\t\t\t\tif (typeof ret === \"undefined\") ret = [];\n\t\t\t\tif (typeof k === \"undefined\") k = [];\n\t\t\t\tvar n, i, Ai;\n\t\t\t\tn = k.length;\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (A.hasOwnProperty(i)) {\n\t\t\t\t\t\tk[n] = parseInt(i);\n\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\tif (typeof Ai === \"number\") {\n\t\t\t\t\t\t\tif (Ai) {\n\t\t\t\t\t\t\t\tif (ret.length === 0) {\n\t\t\t\t\t\t\t\t\tfor (i = n + 1; i >= 0; --i) ret[i] = [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (i = n; i >= 0; --i) ret[i].push(k[i]);\n\t\t\t\t\t\t\t\tret[n + 1].push(Ai);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else gather(Ai, ret, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k.length > n) k.pop();\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\t// 6. Coordinate matrices\n\t\t\tnumeric.cLU = function LU(A) {\n\t\t\t\tvar I = A[0],\n\t\t\t\t\tJ = A[1],\n\t\t\t\t\tV = A[2];\n\t\t\t\tvar p = I.length,\n\t\t\t\t\tm = 0,\n\t\t\t\t\ti, j, k, a, b, c;\n\t\t\t\tfor (i = 0; i < p; i++)\n\t\t\t\t\tif (I[i] > m) m = I[i];\n\t\t\t\tm++;\n\t\t\t\tvar L = Array(m),\n\t\t\t\t\tU = Array(m),\n\t\t\t\t\tleft = numeric.rep([m], Infinity),\n\t\t\t\t\tright = numeric.rep([m], -Infinity);\n\t\t\t\tvar Ui, Uj, alpha;\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\ti = I[k];\n\t\t\t\t\tj = J[k];\n\t\t\t\t\tif (j < left[i]) left[i] = j;\n\t\t\t\t\tif (j > right[i]) right[i] = j;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m - 1; i++) {\n\t\t\t\t\tif (right[i] > right[i + 1]) right[i + 1] = right[i];\n\t\t\t\t}\n\t\t\t\tfor (i = m - 1; i >= 1; i--) {\n\t\t\t\t\tif (left[i] < left[i - 1]) left[i - 1] = left[i];\n\t\t\t\t}\n\t\t\t\tvar countL = 0,\n\t\t\t\t\tcountU = 0;\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\tU[i] = numeric.rep([right[i] - left[i] + 1], 0);\n\t\t\t\t\tL[i] = numeric.rep([i - left[i]], 0);\n\t\t\t\t\tcountL += i - left[i] + 1;\n\t\t\t\t\tcountU += right[i] - i + 1;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\ti = I[k];\n\t\t\t\t\tU[i][J[k] - left[i]] = V[k];\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m - 1; i++) {\n\t\t\t\t\ta = i - left[i];\n\t\t\t\t\tUi = U[i];\n\t\t\t\t\tfor (j = i + 1; left[j] <= i && j < m; j++) {\n\t\t\t\t\t\tb = i - left[j];\n\t\t\t\t\t\tc = right[i] - i;\n\t\t\t\t\t\tUj = U[j];\n\t\t\t\t\t\talpha = Uj[b] / Ui[a];\n\t\t\t\t\t\tif (alpha) {\n\t\t\t\t\t\t\tfor (k = 1; k <= c; k++) {\n\t\t\t\t\t\t\t\tUj[k + b] -= alpha * Ui[k + a];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tL[j][i - left[j]] = alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar Ui = [],\n\t\t\t\t\tUj = [],\n\t\t\t\t\tUv = [],\n\t\t\t\t\tLi = [],\n\t\t\t\t\tLj = [],\n\t\t\t\t\tLv = [];\n\t\t\t\tvar p, q, foo;\n\t\t\t\tp = 0;\n\t\t\t\tq = 0;\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\ta = left[i];\n\t\t\t\t\tb = right[i];\n\t\t\t\t\tfoo = U[i];\n\t\t\t\t\tfor (j = i; j <= b; j++) {\n\t\t\t\t\t\tif (foo[j - a]) {\n\t\t\t\t\t\t\tUi[p] = i;\n\t\t\t\t\t\t\tUj[p] = j;\n\t\t\t\t\t\t\tUv[p] = foo[j - a];\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfoo = L[i];\n\t\t\t\t\tfor (j = a; j < i; j++) {\n\t\t\t\t\t\tif (foo[j - a]) {\n\t\t\t\t\t\t\tLi[q] = i;\n\t\t\t\t\t\t\tLj[q] = j;\n\t\t\t\t\t\t\tLv[q] = foo[j - a];\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLi[q] = i;\n\t\t\t\t\tLj[q] = i;\n\t\t\t\t\tLv[q] = 1;\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tU: [Ui, Uj, Uv],\n\t\t\t\t\tL: [Li, Lj, Lv]\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.cLUsolve = function LUsolve(lu, b) {\n\t\t\t\tvar L = lu.L,\n\t\t\t\t\tU = lu.U,\n\t\t\t\t\tret = numeric.clone(b);\n\t\t\t\tvar Li = L[0],\n\t\t\t\t\tLj = L[1],\n\t\t\t\t\tLv = L[2];\n\t\t\t\tvar Ui = U[0],\n\t\t\t\t\tUj = U[1],\n\t\t\t\t\tUv = U[2];\n\t\t\t\tvar p = Ui.length,\n\t\t\t\t\tq = Li.length;\n\t\t\t\tvar m = ret.length,\n\t\t\t\t\ti, j, k;\n\t\t\t\tk = 0;\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\twhile (Lj[k] < i) {\n\t\t\t\t\t\tret[i] -= Lv[k] * ret[Lj[k]];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tk = p - 1;\n\t\t\t\tfor (i = m - 1; i >= 0; i--) {\n\t\t\t\t\twhile (Uj[k] > i) {\n\t\t\t\t\t\tret[i] -= Uv[k] * ret[Uj[k]];\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t\tret[i] /= Uv[k];\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.cgrid = function grid(n, shape) {\n\t\t\t\tif (typeof n === \"number\") n = [n, n];\n\t\t\t\tvar ret = numeric.rep(n, -1);\n\t\t\t\tvar i, j, count;\n\t\t\t\tif (typeof shape !== \"function\") {\n\t\t\t\t\tswitch (shape) {\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\tshape = function(i, j) {\n\t\t\t\t\t\t\t\treturn (i >= n[0] / 2 || j < n[1] / 2);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tshape = function(i, j) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 1; i < n[0] - 1; i++)\n\t\t\t\t\tfor (j = 1; j < n[1] - 1; j++)\n\t\t\t\t\t\tif (shape(i, j)) {\n\t\t\t\t\t\t\tret[i][j] = count;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.cdelsq = function delsq(g) {\n\t\t\t\tvar dir = [\n\t\t\t\t\t[-1, 0],\n\t\t\t\t\t[0, -1],\n\t\t\t\t\t[0, 1],\n\t\t\t\t\t[1, 0]\n\t\t\t\t];\n\t\t\t\tvar s = numeric.dim(g),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1],\n\t\t\t\t\ti, j, k, p, q;\n\t\t\t\tvar Li = [],\n\t\t\t\t\tLj = [],\n\t\t\t\t\tLv = [];\n\t\t\t\tfor (i = 1; i < m - 1; i++)\n\t\t\t\t\tfor (j = 1; j < n - 1; j++) {\n\t\t\t\t\t\tif (g[i][j] < 0) continue;\n\t\t\t\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tp = i + dir[k][0];\n\t\t\t\t\t\t\tq = j + dir[k][1];\n\t\t\t\t\t\t\tif (g[p][q] < 0) continue;\n\t\t\t\t\t\t\tLi.push(g[i][j]);\n\t\t\t\t\t\t\tLj.push(g[p][q]);\n\t\t\t\t\t\t\tLv.push(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLi.push(g[i][j]);\n\t\t\t\t\t\tLj.push(g[i][j]);\n\t\t\t\t\t\tLv.push(4);\n\t\t\t\t\t}\n\t\t\t\treturn [Li, Lj, Lv];\n\t\t\t};\n\n\t\t\tnumeric.cdotMV = function dotMV(A, x) {\n\t\t\t\tvar ret, Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tk, p = Ai.length,\n\t\t\t\t\tN;\n\t\t\t\tN = 0;\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\tif (Ai[k] > N) N = Ai[k];\n\t\t\t\t}\n\t\t\t\tN++;\n\t\t\t\tret = numeric.rep([N], 0);\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\tret[Ai[k]] += Av[k] * x[Aj[k]];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\t// 7. Splines\n\n\t\t\tnumeric.Spline = function Spline(x, yl, yr, kl, kr) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.yl = yl;\n\t\t\t\tthis.yr = yr;\n\t\t\t\tthis.kl = kl;\n\t\t\t\tthis.kr = kr;\n\t\t\t};\n\t\t\tnumeric.Spline.prototype._at = function _at(x1, p) {\n\t\t\t\tvar x = this.x;\n\t\t\t\tvar yl = this.yl;\n\t\t\t\tvar yr = this.yr;\n\t\t\t\tvar kl = this.kl;\n\t\t\t\tvar kr = this.kr;\n\t\t\t\tvar x1, a, b, t;\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tmul = numeric.mul;\n\t\t\t\ta = sub(mul(kl[p], x[p + 1] - x[p]), sub(yr[p + 1], yl[p]));\n\t\t\t\tb = add(mul(kr[p + 1], x[p] - x[p + 1]), sub(yr[p + 1], yl[p]));\n\t\t\t\tt = (x1 - x[p]) / (x[p + 1] - x[p]);\n\t\t\t\tvar s = t * (1 - t);\n\t\t\t\treturn add(add(add(mul(1 - t, yl[p]), mul(t, yr[p + 1])), mul(a, s * (1 - t))), mul(b, s * t));\n\t\t\t};\n\t\t\tnumeric.Spline.prototype.at = function at(x0) {\n\t\t\t\tif (typeof x0 === \"number\") {\n\t\t\t\t\tvar x = this.x;\n\t\t\t\t\tvar n = x.length;\n\t\t\t\t\tvar p, q, mid, floor = Math.floor,\n\t\t\t\t\t\ta, b, t;\n\t\t\t\t\tp = 0;\n\t\t\t\t\tq = n - 1;\n\t\t\t\t\twhile (q - p > 1) {\n\t\t\t\t\t\tmid = floor((p + q) / 2);\n\t\t\t\t\t\tif (x[mid] <= x0) p = mid;\n\t\t\t\t\t\telse q = mid;\n\t\t\t\t\t}\n\t\t\t\t\treturn this._at(x0, p);\n\t\t\t\t}\n\t\t\t\tvar n = x0.length,\n\t\t\t\t\ti, ret = Array(n);\n\t\t\t\tfor (i = n - 1; i !== -1; --i) ret[i] = this.at(x0[i]);\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.Spline.prototype.diff = function diff() {\n\t\t\t\tvar x = this.x;\n\t\t\t\tvar yl = this.yl;\n\t\t\t\tvar yr = this.yr;\n\t\t\t\tvar kl = this.kl;\n\t\t\t\tvar kr = this.kr;\n\t\t\t\tvar n = yl.length;\n\t\t\t\tvar i, dx, dy;\n\t\t\t\tvar zl = kl,\n\t\t\t\t\tzr = kr,\n\t\t\t\t\tpl = Array(n),\n\t\t\t\t\tpr = Array(n);\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tdiv = numeric.div,\n\t\t\t\t\tsub = numeric.sub;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\tdx = x[i + 1] - x[i];\n\t\t\t\t\tdy = sub(yr[i + 1], yl[i]);\n\t\t\t\t\tpl[i] = div(add(mul(dy, 6), mul(kl[i], -4 * dx), mul(kr[i + 1], -2 * dx)), dx * dx);\n\t\t\t\t\tpr[i + 1] = div(add(mul(dy, -6), mul(kl[i], 2 * dx), mul(kr[i + 1], 4 * dx)), dx * dx);\n\t\t\t\t}\n\t\t\t\treturn new numeric.Spline(x, zl, zr, pl, pr);\n\t\t\t};\n\t\t\tnumeric.Spline.prototype.roots = function roots() {\n\t\t\t\tfunction sqr(x) {\n\t\t\t\t\treturn x * x;\n\t\t\t\t}\n\n\t\t\t\tfunction heval(y0, y1, k0, k1, x) {\n\t\t\t\t\tvar A = k0 * 2 - (y1 - y0);\n\t\t\t\t\tvar B = -k1 * 2 + (y1 - y0);\n\t\t\t\t\tvar t = (x + 1) * 0.5;\n\t\t\t\t\tvar s = t * (1 - t);\n\t\t\t\t\treturn (1 - t) * y0 + t * y1 + A * s * (1 - t) + B * s * t;\n\t\t\t\t}\n\t\t\t\tvar ret = [];\n\t\t\t\tvar x = this.x,\n\t\t\t\t\tyl = this.yl,\n\t\t\t\t\tyr = this.yr,\n\t\t\t\t\tkl = this.kl,\n\t\t\t\t\tkr = this.kr;\n\t\t\t\tif (typeof yl[0] === \"number\") {\n\t\t\t\t\tyl = [yl];\n\t\t\t\t\tyr = [yr];\n\t\t\t\t\tkl = [kl];\n\t\t\t\t\tkr = [kr];\n\t\t\t\t}\n\t\t\t\tvar m = yl.length,\n\t\t\t\t\tn = x.length - 1,\n\t\t\t\t\ti, j, k, y, s, t;\n\t\t\t\tvar ai, bi, ci, di, ret = Array(m),\n\t\t\t\t\tri, k0, k1, y0, y1, A, B, D, dx, cx, stops, z0, z1, zm, t0, t1, tm;\n\t\t\t\tvar sqrt = Math.sqrt;\n\t\t\t\tfor (i = 0; i !== m; ++i) {\n\t\t\t\t\tai = yl[i];\n\t\t\t\t\tbi = yr[i];\n\t\t\t\t\tci = kl[i];\n\t\t\t\t\tdi = kr[i];\n\t\t\t\t\tri = [];\n\t\t\t\t\tfor (j = 0; j !== n; j++) {\n\t\t\t\t\t\tif (j > 0 && bi[j] * ai[j] < 0) ri.push(x[j]);\n\t\t\t\t\t\tdx = (x[j + 1] - x[j]);\n\t\t\t\t\t\tcx = x[j];\n\t\t\t\t\t\ty0 = ai[j];\n\t\t\t\t\t\ty1 = bi[j + 1];\n\t\t\t\t\t\tk0 = ci[j] / dx;\n\t\t\t\t\t\tk1 = di[j + 1] / dx;\n\t\t\t\t\t\tD = sqr(k0 - k1 + 3 * (y0 - y1)) + 12 * k1 * y0;\n\t\t\t\t\t\tA = k1 + 3 * y0 + 2 * k0 - 3 * y1;\n\t\t\t\t\t\tB = 3 * (k1 + k0 + 2 * (y0 - y1));\n\t\t\t\t\t\tif (D <= 0) {\n\t\t\t\t\t\t\tz0 = A / B;\n\t\t\t\t\t\t\tif (z0 > x[j] && z0 < x[j + 1]) stops = [x[j], z0, x[j + 1]];\n\t\t\t\t\t\t\telse stops = [x[j], x[j + 1]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tz0 = (A - sqrt(D)) / B;\n\t\t\t\t\t\t\tz1 = (A + sqrt(D)) / B;\n\t\t\t\t\t\t\tstops = [x[j]];\n\t\t\t\t\t\t\tif (z0 > x[j] && z0 < x[j + 1]) stops.push(z0);\n\t\t\t\t\t\t\tif (z1 > x[j] && z1 < x[j + 1]) stops.push(z1);\n\t\t\t\t\t\t\tstops.push(x[j + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt0 = stops[0];\n\t\t\t\t\t\tz0 = this._at(t0, j);\n\t\t\t\t\t\tfor (k = 0; k < stops.length - 1; k++) {\n\t\t\t\t\t\t\tt1 = stops[k + 1];\n\t\t\t\t\t\t\tz1 = this._at(t1, j);\n\t\t\t\t\t\t\tif (z0 === 0) {\n\t\t\t\t\t\t\t\tri.push(t0);\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tz0 = z1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (z1 === 0 || z0 * z1 > 0) {\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tz0 = z1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar side = 0;\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\ttm = (z0 * t1 - z1 * t0) / (z0 - z1);\n\t\t\t\t\t\t\t\tif (tm <= t0 || tm >= t1) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tzm = this._at(tm, j);\n\t\t\t\t\t\t\t\tif (zm * z1 > 0) {\n\t\t\t\t\t\t\t\t\tt1 = tm;\n\t\t\t\t\t\t\t\t\tz1 = zm;\n\t\t\t\t\t\t\t\t\tif (side === -1) z0 *= 0.5;\n\t\t\t\t\t\t\t\t\tside = -1;\n\t\t\t\t\t\t\t\t} else if (zm * z0 > 0) {\n\t\t\t\t\t\t\t\t\tt0 = tm;\n\t\t\t\t\t\t\t\t\tz0 = zm;\n\t\t\t\t\t\t\t\t\tif (side === 1) z1 *= 0.5;\n\t\t\t\t\t\t\t\t\tside = 1;\n\t\t\t\t\t\t\t\t} else break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tri.push(tm);\n\t\t\t\t\t\t\tt0 = stops[k + 1];\n\t\t\t\t\t\t\tz0 = this._at(t0, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (z1 === 0) ri.push(t1);\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = ri;\n\t\t\t\t}\n\t\t\t\tif (typeof this.yl[0] === \"number\") return ret[0];\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.spline = function spline(x, y, k1, kn) {\n\t\t\t\tvar n = x.length,\n\t\t\t\t\tb = [],\n\t\t\t\t\tdx = [],\n\t\t\t\t\tdy = [];\n\t\t\t\tvar i;\n\t\t\t\tvar sub = numeric.sub,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tadd = numeric.add;\n\t\t\t\tfor (i = n - 2; i >= 0; i--) {\n\t\t\t\t\tdx[i] = x[i + 1] - x[i];\n\t\t\t\t\tdy[i] = sub(y[i + 1], y[i]);\n\t\t\t\t}\n\t\t\t\tif (typeof k1 === \"string\" || typeof kn === \"string\") {\n\t\t\t\t\tk1 = kn = \"periodic\";\n\t\t\t\t}\n\t\t\t\t// Build sparse tridiagonal system\n\t\t\t\tvar T = [\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tswitch (typeof k1) {\n\t\t\t\t\tcase \"undefined\":\n\t\t\t\t\t\tb[0] = mul(3 / (dx[0] * dx[0]), dy[0]);\n\t\t\t\t\t\tT[0].push(0, 0);\n\t\t\t\t\t\tT[1].push(0, 1);\n\t\t\t\t\t\tT[2].push(2 / dx[0], 1 / dx[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\tb[0] = add(mul(3 / (dx[n - 2] * dx[n - 2]), dy[n - 2]), mul(3 / (dx[0] * dx[0]), dy[0]));\n\t\t\t\t\t\tT[0].push(0, 0, 0);\n\t\t\t\t\t\tT[1].push(n - 2, 0, 1);\n\t\t\t\t\t\tT[2].push(1 / dx[n - 2], 2 / dx[n - 2] + 2 / dx[0], 1 / dx[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb[0] = k1;\n\t\t\t\t\t\tT[0].push(0);\n\t\t\t\t\t\tT[1].push(0);\n\t\t\t\t\t\tT[2].push(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i < n - 1; i++) {\n\t\t\t\t\tb[i] = add(mul(3 / (dx[i - 1] * dx[i - 1]), dy[i - 1]), mul(3 / (dx[i] * dx[i]), dy[i]));\n\t\t\t\t\tT[0].push(i, i, i);\n\t\t\t\t\tT[1].push(i - 1, i, i + 1);\n\t\t\t\t\tT[2].push(1 / dx[i - 1], 2 / dx[i - 1] + 2 / dx[i], 1 / dx[i]);\n\t\t\t\t}\n\t\t\t\tswitch (typeof kn) {\n\t\t\t\t\tcase \"undefined\":\n\t\t\t\t\t\tb[n - 1] = mul(3 / (dx[n - 2] * dx[n - 2]), dy[n - 2]);\n\t\t\t\t\t\tT[0].push(n - 1, n - 1);\n\t\t\t\t\t\tT[1].push(n - 2, n - 1);\n\t\t\t\t\t\tT[2].push(1 / dx[n - 2], 2 / dx[n - 2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\tT[1][T[1].length - 1] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb[n - 1] = kn;\n\t\t\t\t\t\tT[0].push(n - 1);\n\t\t\t\t\t\tT[1].push(n - 1);\n\t\t\t\t\t\tT[2].push(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (typeof b[0] !== \"number\") b = numeric.transpose(b);\n\t\t\t\telse b = [b];\n\t\t\t\tvar k = Array(b.length);\n\t\t\t\tif (typeof k1 === \"string\") {\n\t\t\t\t\tfor (i = k.length - 1; i !== -1; --i) {\n\t\t\t\t\t\tk[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)), b[i]);\n\t\t\t\t\t\tk[i][n - 1] = k[i][0];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = k.length - 1; i !== -1; --i) {\n\t\t\t\t\t\tk[i] = numeric.cLUsolve(numeric.cLU(T), b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (typeof y[0] === \"number\") k = k[0];\n\t\t\t\telse k = numeric.transpose(k);\n\t\t\t\treturn new numeric.Spline(x, y, y, k, k);\n\t\t\t};\n\n\t\t\t// 8. FFT\n\t\t\tnumeric.fftpow2 = function fftpow2(x, y) {\n\t\t\t\tvar n = x.length;\n\t\t\t\tif (n === 1) return;\n\t\t\t\tvar cos = Math.cos,\n\t\t\t\t\tsin = Math.sin,\n\t\t\t\t\ti, j;\n\t\t\t\tvar xe = Array(n / 2),\n\t\t\t\t\tye = Array(n / 2),\n\t\t\t\t\txo = Array(n / 2),\n\t\t\t\t\tyo = Array(n / 2);\n\t\t\t\tj = n / 2;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\txo[j] = x[i];\n\t\t\t\t\tyo[j] = y[i];\n\t\t\t\t\t--i;\n\t\t\t\t\txe[j] = x[i];\n\t\t\t\t\tye[j] = y[i];\n\t\t\t\t}\n\t\t\t\tfftpow2(xe, ye);\n\t\t\t\tfftpow2(xo, yo);\n\t\t\t\tj = n / 2;\n\t\t\t\tvar t, k = (-6.2831853071795864769252867665590057683943387987502116419 / n),\n\t\t\t\t\tci, si;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\tif (j === -1) j = n / 2 - 1;\n\t\t\t\t\tt = k * i;\n\t\t\t\t\tci = cos(t);\n\t\t\t\t\tsi = sin(t);\n\t\t\t\t\tx[i] = xe[j] + ci * xo[j] - si * yo[j];\n\t\t\t\t\ty[i] = ye[j] + ci * yo[j] + si * xo[j];\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric._ifftpow2 = function _ifftpow2(x, y) {\n\t\t\t\tvar n = x.length;\n\t\t\t\tif (n === 1) return;\n\t\t\t\tvar cos = Math.cos,\n\t\t\t\t\tsin = Math.sin,\n\t\t\t\t\ti, j;\n\t\t\t\tvar xe = Array(n / 2),\n\t\t\t\t\tye = Array(n / 2),\n\t\t\t\t\txo = Array(n / 2),\n\t\t\t\t\tyo = Array(n / 2);\n\t\t\t\tj = n / 2;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\txo[j] = x[i];\n\t\t\t\t\tyo[j] = y[i];\n\t\t\t\t\t--i;\n\t\t\t\t\txe[j] = x[i];\n\t\t\t\t\tye[j] = y[i];\n\t\t\t\t}\n\t\t\t\t_ifftpow2(xe, ye);\n\t\t\t\t_ifftpow2(xo, yo);\n\t\t\t\tj = n / 2;\n\t\t\t\tvar t, k = (6.2831853071795864769252867665590057683943387987502116419 / n),\n\t\t\t\t\tci, si;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\tif (j === -1) j = n / 2 - 1;\n\t\t\t\t\tt = k * i;\n\t\t\t\t\tci = cos(t);\n\t\t\t\t\tsi = sin(t);\n\t\t\t\t\tx[i] = xe[j] + ci * xo[j] - si * yo[j];\n\t\t\t\t\ty[i] = ye[j] + ci * yo[j] + si * xo[j];\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ifftpow2 = function ifftpow2(x, y) {\n\t\t\t\tnumeric._ifftpow2(x, y);\n\t\t\t\tnumeric.diveq(x, x.length);\n\t\t\t\tnumeric.diveq(y, y.length);\n\t\t\t};\n\t\t\tnumeric.convpow2 = function convpow2(ax, ay, bx, by) {\n\t\t\t\tnumeric.fftpow2(ax, ay);\n\t\t\t\tnumeric.fftpow2(bx, by);\n\t\t\t\tvar i, n = ax.length,\n\t\t\t\t\taxi, bxi, ayi, byi;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\taxi = ax[i];\n\t\t\t\t\tayi = ay[i];\n\t\t\t\t\tbxi = bx[i];\n\t\t\t\t\tbyi = by[i];\n\t\t\t\t\tax[i] = axi * bxi - ayi * byi;\n\t\t\t\t\tay[i] = axi * byi + ayi * bxi;\n\t\t\t\t}\n\t\t\t\tnumeric.ifftpow2(ax, ay);\n\t\t\t};\n\t\t\tnumeric.T.prototype.fft = function fft() {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tvar n = x.length,\n\t\t\t\t\tlog = Math.log,\n\t\t\t\t\tlog2 = log(2),\n\t\t\t\t\tp = Math.ceil(log(2 * n - 1) / log2),\n\t\t\t\t\tm = Math.pow(2, p);\n\t\t\t\tvar cx = numeric.rep([m], 0),\n\t\t\t\t\tcy = numeric.rep([m], 0),\n\t\t\t\t\tcos = Math.cos,\n\t\t\t\t\tsin = Math.sin;\n\t\t\t\tvar k, c = (-3.141592653589793238462643383279502884197169399375105820 / n),\n\t\t\t\t\tt;\n\t\t\t\tvar a = numeric.rep([m], 0),\n\t\t\t\t\tb = numeric.rep([m], 0),\n\t\t\t\t\tnhalf = Math.floor(n / 2);\n\t\t\t\tfor (k = 0; k < n; k++) a[k] = x[k];\n\t\t\t\tif (typeof y !== \"undefined\")\n\t\t\t\t\tfor (k = 0; k < n; k++) b[k] = y[k];\n\t\t\t\tcx[0] = 1;\n\t\t\t\tfor (k = 1; k <= m / 2; k++) {\n\t\t\t\t\tt = c * k * k;\n\t\t\t\t\tcx[k] = cos(t);\n\t\t\t\t\tcy[k] = sin(t);\n\t\t\t\t\tcx[m - k] = cos(t);\n\t\t\t\t\tcy[m - k] = sin(t);\n\t\t\t\t}\n\t\t\t\tvar X = new numeric.T(a, b),\n\t\t\t\t\tY = new numeric.T(cx, cy);\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tnumeric.convpow2(X.x, X.y, numeric.clone(Y.x), numeric.neg(Y.y));\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tX.x.length = n;\n\t\t\t\tX.y.length = n;\n\t\t\t\treturn X;\n\t\t\t};\n\t\t\tnumeric.T.prototype.ifft = function ifft() {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tvar n = x.length,\n\t\t\t\t\tlog = Math.log,\n\t\t\t\t\tlog2 = log(2),\n\t\t\t\t\tp = Math.ceil(log(2 * n - 1) / log2),\n\t\t\t\t\tm = Math.pow(2, p);\n\t\t\t\tvar cx = numeric.rep([m], 0),\n\t\t\t\t\tcy = numeric.rep([m], 0),\n\t\t\t\t\tcos = Math.cos,\n\t\t\t\t\tsin = Math.sin;\n\t\t\t\tvar k, c = (3.141592653589793238462643383279502884197169399375105820 / n),\n\t\t\t\t\tt;\n\t\t\t\tvar a = numeric.rep([m], 0),\n\t\t\t\t\tb = numeric.rep([m], 0),\n\t\t\t\t\tnhalf = Math.floor(n / 2);\n\t\t\t\tfor (k = 0; k < n; k++) a[k] = x[k];\n\t\t\t\tif (typeof y !== \"undefined\")\n\t\t\t\t\tfor (k = 0; k < n; k++) b[k] = y[k];\n\t\t\t\tcx[0] = 1;\n\t\t\t\tfor (k = 1; k <= m / 2; k++) {\n\t\t\t\t\tt = c * k * k;\n\t\t\t\t\tcx[k] = cos(t);\n\t\t\t\t\tcy[k] = sin(t);\n\t\t\t\t\tcx[m - k] = cos(t);\n\t\t\t\t\tcy[m - k] = sin(t);\n\t\t\t\t}\n\t\t\t\tvar X = new numeric.T(a, b),\n\t\t\t\t\tY = new numeric.T(cx, cy);\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tnumeric.convpow2(X.x, X.y, numeric.clone(Y.x), numeric.neg(Y.y));\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tX.x.length = n;\n\t\t\t\tX.y.length = n;\n\t\t\t\treturn X.div(n);\n\t\t\t};\n\n\t\t\t//9. Unconstrained optimization\n\t\t\tnumeric.gradient = function gradient(f, x) {\n\t\t\t\tvar n = x.length;\n\t\t\t\tvar f0 = f(x);\n\t\t\t\tif (isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');\n\t\t\t\tvar max = Math.max;\n\t\t\t\tvar i, x0 = numeric.clone(x),\n\t\t\t\t\tf1, f2, J = Array(n);\n\t\t\t\tvar div = numeric.div,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\terrest, roundoff, max = Math.max,\n\t\t\t\t\teps = 1e-3,\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\tmin = Math.min;\n\t\t\t\tvar t0, t1, t2, it = 0,\n\t\t\t\t\td1, d2, N;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tvar h = max(1e-6 * f0, 1e-8);\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t++it;\n\t\t\t\t\t\tif (it > 20) {\n\t\t\t\t\t\t\tthrow new Error(\"Numerical gradient fails\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx0[i] = x[i] + h;\n\t\t\t\t\t\tf1 = f(x0);\n\t\t\t\t\t\tx0[i] = x[i] - h;\n\t\t\t\t\t\tf2 = f(x0);\n\t\t\t\t\t\tx0[i] = x[i];\n\t\t\t\t\t\tif (isNaN(f1) || isNaN(f2)) {\n\t\t\t\t\t\t\th /= 16;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJ[i] = (f1 - f2) / (2 * h);\n\t\t\t\t\t\tt0 = x[i] - h;\n\t\t\t\t\t\tt1 = x[i];\n\t\t\t\t\t\tt2 = x[i] + h;\n\t\t\t\t\t\td1 = (f1 - f0) / h;\n\t\t\t\t\t\td2 = (f0 - f2) / h;\n\t\t\t\t\t\tN = max(abs(J[i]), abs(f0), abs(f1), abs(f2), abs(t0), abs(t1), abs(t2), 1e-8);\n\t\t\t\t\t\terrest = min(max(abs(d1 - J[i]), abs(d2 - J[i]), abs(d1 - d2)) / N, h / N);\n\t\t\t\t\t\tif (errest > eps) {\n\t\t\t\t\t\t\th /= 16;\n\t\t\t\t\t\t} else break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn J;\n\t\t\t};\n\n\t\t\tnumeric.uncmin = function uncmin(f, x0, tol, gradient, maxit, callback) {\n\t\t\t\tvar grad = numeric.gradient;\n\t\t\t\tif (typeof tol === \"undefined\") {\n\t\t\t\t\ttol = 1e-8;\n\t\t\t\t}\n\t\t\t\tif (typeof gradient === \"undefined\") {\n\t\t\t\t\tgradient = function(x) {\n\t\t\t\t\t\treturn grad(f, x);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof maxit === \"undefined\") maxit = 1000;\n\t\t\t\tx0 = numeric.clone(x0);\n\t\t\t\tvar n = x0.length;\n\t\t\t\tvar f0 = f(x0),\n\t\t\t\t\tf1, df0;\n\t\t\t\tif (isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');\n\t\t\t\tvar max = Math.max,\n\t\t\t\t\tnorm2 = numeric.norm2;\n\t\t\t\ttol = max(tol, numeric.epsilon);\n\t\t\t\tvar step, g0, g1, H1 = numeric.identity(n);\n\t\t\t\tvar dot = numeric.dot,\n\t\t\t\t\tinv = numeric.inv,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tadd = numeric.add,\n\t\t\t\t\tten = numeric.tensor,\n\t\t\t\t\tdiv = numeric.div,\n\t\t\t\t\tmul = numeric.mul;\n\t\t\t\tvar all = numeric.all,\n\t\t\t\t\tisfinite = numeric.isFinite,\n\t\t\t\t\tneg = numeric.neg;\n\t\t\t\tvar it = 0,\n\t\t\t\t\ti, s, x1, y, Hy, Hs, ys, i0, t, nstep, t1, t2;\n\t\t\t\tvar msg = \"\";\n\t\t\t\tg0 = gradient(x0);\n\t\t\t\twhile (it < maxit) {\n\t\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\t\tif (callback(it, x0, f0, g0, H1)) {\n\t\t\t\t\t\t\tmsg = \"Callback returned true\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!all(isfinite(g0))) {\n\t\t\t\t\t\tmsg = \"Gradient has Infinity or NaN\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstep = neg(dot(H1, g0));\n\t\t\t\t\tif (!all(isfinite(step))) {\n\t\t\t\t\t\tmsg = \"Search direction has Infinity or NaN\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnstep = norm2(step);\n\t\t\t\t\tif (nstep < tol) {\n\t\t\t\t\t\tmsg = \"Newton step smaller than tol\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt = 1;\n\t\t\t\t\tdf0 = dot(g0, step);\n\t\t\t\t\t// line search\n\t\t\t\t\tx1 = x0;\n\t\t\t\t\twhile (it < maxit) {\n\t\t\t\t\t\tif (t * nstep < tol) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = mul(step, t);\n\t\t\t\t\t\tx1 = add(x0, s);\n\t\t\t\t\t\tf1 = f(x1);\n\t\t\t\t\t\tif (f1 - f0 >= 0.1 * t * df0 || isNaN(f1)) {\n\t\t\t\t\t\t\tt *= 0.5;\n\t\t\t\t\t\t\t++it;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (t * nstep < tol) {\n\t\t\t\t\t\tmsg = \"Line search step size smaller than tol\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (it === maxit) {\n\t\t\t\t\t\tmsg = \"maxit reached during line search\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tg1 = gradient(x1);\n\t\t\t\t\ty = sub(g1, g0);\n\t\t\t\t\tys = dot(y, s);\n\t\t\t\t\tHy = dot(H1, y);\n\t\t\t\t\tH1 = sub(add(H1,\n\t\t\t\t\t\t\tmul(\n\t\t\t\t\t\t\t\t(ys + dot(y, Hy)) / (ys * ys),\n\t\t\t\t\t\t\t\tten(s, s))),\n\t\t\t\t\t\tdiv(add(ten(Hy, s), ten(s, Hy)), ys));\n\t\t\t\t\tx0 = x1;\n\t\t\t\t\tf0 = f1;\n\t\t\t\t\tg0 = g1;\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tsolution: x0,\n\t\t\t\t\tf: f0,\n\t\t\t\t\tgradient: g0,\n\t\t\t\t\tinvHessian: H1,\n\t\t\t\t\titerations: it,\n\t\t\t\t\tmessage: msg\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// 10. Ode solver (Dormand-Prince)\n\t\t\tnumeric.Dopri = function Dopri(x, y, f, ymid, iterations, msg, events) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.f = f;\n\t\t\t\tthis.ymid = ymid;\n\t\t\t\tthis.iterations = iterations;\n\t\t\t\tthis.events = events;\n\t\t\t\tthis.message = msg;\n\t\t\t};\n\t\t\tnumeric.Dopri.prototype._at = function _at(xi, j) {\n\t\t\t\tfunction sqr(x) {\n\t\t\t\t\treturn x * x;\n\t\t\t\t}\n\t\t\t\tvar sol = this;\n\t\t\t\tvar xs = sol.x;\n\t\t\t\tvar ys = sol.y;\n\t\t\t\tvar k1 = sol.f;\n\t\t\t\tvar ymid = sol.ymid;\n\t\t\t\tvar n = xs.length;\n\t\t\t\tvar x0, x1, xh, y0, y1, yh, xi;\n\t\t\t\tvar floor = Math.floor,\n\t\t\t\t\th;\n\t\t\t\tvar c = 0.5;\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tp, q, w;\n\t\t\t\tx0 = xs[j];\n\t\t\t\tx1 = xs[j + 1];\n\t\t\t\ty0 = ys[j];\n\t\t\t\ty1 = ys[j + 1];\n\t\t\t\th = x1 - x0;\n\t\t\t\txh = x0 + c * h;\n\t\t\t\tyh = ymid[j];\n\t\t\t\tp = sub(k1[j], mul(y0, 1 / (x0 - xh) + 2 / (x0 - x1)));\n\t\t\t\tq = sub(k1[j + 1], mul(y1, 1 / (x1 - xh) + 2 / (x1 - x0)));\n\t\t\t\tw = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),\n\t\t\t\t\tsqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),\n\t\t\t\t\tsqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),\n\t\t\t\t\t(xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),\n\t\t\t\t\t(xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0 - x1) / (x1 - xh)\n\t\t\t\t];\n\t\t\t\treturn add(add(add(add(mul(y0, w[0]),\n\t\t\t\t\t\t\t\tmul(yh, w[1])),\n\t\t\t\t\t\t\tmul(y1, w[2])),\n\t\t\t\t\t\tmul(p, w[3])),\n\t\t\t\t\tmul(q, w[4]));\n\t\t\t};\n\t\t\tnumeric.Dopri.prototype.at = function at(x) {\n\t\t\t\tvar i, j, k, floor = Math.floor;\n\t\t\t\tif (typeof x !== \"number\") {\n\t\t\t\t\tvar n = x.length,\n\t\t\t\t\t\tret = Array(n);\n\t\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t\tret[i] = this.at(x[i]);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tvar x0 = this.x;\n\t\t\t\ti = 0;\n\t\t\t\tj = x0.length - 1;\n\t\t\t\twhile (j - i > 1) {\n\t\t\t\t\tk = floor(0.5 * (i + j));\n\t\t\t\t\tif (x0[k] <= x) i = k;\n\t\t\t\t\telse j = k;\n\t\t\t\t}\n\t\t\t\treturn this._at(x, i);\n\t\t\t};\n\n\t\t\tnumeric.dopri = function dopri(x0, x1, y0, f, tol, maxit, event) {\n\t\t\t\tif (typeof tol === \"undefined\") {\n\t\t\t\t\ttol = 1e-6;\n\t\t\t\t}\n\t\t\t\tif (typeof maxit === \"undefined\") {\n\t\t\t\t\tmaxit = 1000;\n\t\t\t\t}\n\t\t\t\tvar xs = [x0],\n\t\t\t\t\tys = [y0],\n\t\t\t\t\tk1 = [f(x0, y0)],\n\t\t\t\t\tk2, k3, k4, k5, k6, k7, ymid = [];\n\t\t\t\tvar A2 = 1 / 5;\n\t\t\t\tvar A3 = [3 / 40, 9 / 40];\n\t\t\t\tvar A4 = [44 / 45, -56 / 15, 32 / 9];\n\t\t\t\tvar A5 = [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729];\n\t\t\t\tvar A6 = [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656];\n\t\t\t\tvar b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84];\n\t\t\t\tvar bm = [0.5 * 6025192743 / 30085553152,\n\t\t\t\t\t0,\n\t\t\t\t\t0.5 * 51252292925 / 65400821598,\n\t\t\t\t\t0.5 * -2691868925 / 45128329728,\n\t\t\t\t\t0.5 * 187940372067 / 1594534317056,\n\t\t\t\t\t0.5 * -1776094331 / 19743644256,\n\t\t\t\t\t0.5 * 11237099 / 235043384\n\t\t\t\t];\n\t\t\t\tvar c = [1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];\n\t\t\t\tvar e = [-71 / 57600, 0, 71 / 16695, -71 / 1920, 17253 / 339200, -22 / 525, 1 / 40];\n\t\t\t\tvar i = 0,\n\t\t\t\t\ter, j;\n\t\t\t\tvar h = (x1 - x0) / 10;\n\t\t\t\tvar it = 0;\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\ty1, erinf;\n\t\t\t\tvar max = Math.max,\n\t\t\t\t\tmin = Math.min,\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\tnorminf = numeric.norminf,\n\t\t\t\t\tpow = Math.pow;\n\t\t\t\tvar any = numeric.any,\n\t\t\t\t\tlt = numeric.lt,\n\t\t\t\t\tand = numeric.and,\n\t\t\t\t\tsub = numeric.sub;\n\t\t\t\tvar e0, e1, ev;\n\t\t\t\tvar ret = new numeric.Dopri(xs, ys, k1, ymid, -1, \"\");\n\t\t\t\tif (typeof event === \"function\") e0 = event(x0, y0);\n\t\t\t\twhile (x0 < x1 && it < maxit) {\n\t\t\t\t\t++it;\n\t\t\t\t\tif (x0 + h > x1) h = x1 - x0;\n\t\t\t\t\tk2 = f(x0 + c[0] * h, add(y0, mul(A2 * h, k1[i])));\n\t\t\t\t\tk3 = f(x0 + c[1] * h, add(add(y0, mul(A3[0] * h, k1[i])), mul(A3[1] * h, k2)));\n\t\t\t\t\tk4 = f(x0 + c[2] * h, add(add(add(y0, mul(A4[0] * h, k1[i])), mul(A4[1] * h, k2)), mul(A4[2] * h, k3)));\n\t\t\t\t\tk5 = f(x0 + c[3] * h, add(add(add(add(y0, mul(A5[0] * h, k1[i])), mul(A5[1] * h, k2)), mul(A5[2] * h, k3)), mul(A5[3] * h, k4)));\n\t\t\t\t\tk6 = f(x0 + c[4] * h, add(add(add(add(add(y0, mul(A6[0] * h, k1[i])), mul(A6[1] * h, k2)), mul(A6[2] * h, k3)), mul(A6[3] * h, k4)), mul(A6[4] * h, k5)));\n\t\t\t\t\ty1 = add(add(add(add(add(y0, mul(k1[i], h * b[0])), mul(k3, h * b[2])), mul(k4, h * b[3])), mul(k5, h * b[4])), mul(k6, h * b[5]));\n\t\t\t\t\tk7 = f(x0 + h, y1);\n\t\t\t\t\ter = add(add(add(add(add(mul(k1[i], h * e[0]), mul(k3, h * e[2])), mul(k4, h * e[3])), mul(k5, h * e[4])), mul(k6, h * e[5])), mul(k7, h * e[6]));\n\t\t\t\t\tif (typeof er === \"number\") erinf = abs(er);\n\t\t\t\t\telse erinf = norminf(er);\n\t\t\t\t\tif (erinf > tol) { // reject\n\t\t\t\t\t\th = 0.2 * h * pow(tol / erinf, 0.25);\n\t\t\t\t\t\tif (x0 + h === x0) {\n\t\t\t\t\t\t\tret.msg = \"Step size became too small\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tymid[i] = add(add(add(add(add(add(y0,\n\t\t\t\t\t\t\t\t\t\t\tmul(k1[i], h * bm[0])),\n\t\t\t\t\t\t\t\t\t\tmul(k3, h * bm[2])),\n\t\t\t\t\t\t\t\t\tmul(k4, h * bm[3])),\n\t\t\t\t\t\t\t\tmul(k5, h * bm[4])),\n\t\t\t\t\t\t\tmul(k6, h * bm[5])),\n\t\t\t\t\t\tmul(k7, h * bm[6]));\n\t\t\t\t\t++i;\n\t\t\t\t\txs[i] = x0 + h;\n\t\t\t\t\tys[i] = y1;\n\t\t\t\t\tk1[i] = k7;\n\t\t\t\t\tif (typeof event === \"function\") {\n\t\t\t\t\t\tvar yi, xl = x0,\n\t\t\t\t\t\t\txr = x0 + 0.5 * h,\n\t\t\t\t\t\t\txi;\n\t\t\t\t\t\te1 = event(xr, ymid[i - 1]);\n\t\t\t\t\t\tev = and(lt(e0, 0), lt(0, e1));\n\t\t\t\t\t\tif (!any(ev)) {\n\t\t\t\t\t\t\txl = xr;\n\t\t\t\t\t\t\txr = x0 + h;\n\t\t\t\t\t\t\te0 = e1;\n\t\t\t\t\t\t\te1 = event(xr, y1);\n\t\t\t\t\t\t\tev = and(lt(e0, 0), lt(0, e1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (any(ev)) {\n\t\t\t\t\t\t\tvar xc, yc, en, ei;\n\t\t\t\t\t\t\tvar side = 0,\n\t\t\t\t\t\t\t\tsl = 1.0,\n\t\t\t\t\t\t\t\tsr = 1.0;\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tif (typeof e0 === \"number\") xi = (sr * e1 * xl - sl * e0 * xr) / (sr * e1 - sl * e0);\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\txi = xr;\n\t\t\t\t\t\t\t\t\tfor (j = e0.length - 1; j !== -1; --j) {\n\t\t\t\t\t\t\t\t\t\tif (e0[j] < 0 && e1[j] > 0) xi = min(xi, (sr * e1[j] * xl - sl * e0[j] * xr) / (sr * e1[j] - sl * e0[j]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (xi <= xl || xi >= xr) break;\n\t\t\t\t\t\t\t\tyi = ret._at(xi, i - 1);\n\t\t\t\t\t\t\t\tei = event(xi, yi);\n\t\t\t\t\t\t\t\ten = and(lt(e0, 0), lt(0, ei));\n\t\t\t\t\t\t\t\tif (any(en)) {\n\t\t\t\t\t\t\t\t\txr = xi;\n\t\t\t\t\t\t\t\t\te1 = ei;\n\t\t\t\t\t\t\t\t\tev = en;\n\t\t\t\t\t\t\t\t\tsr = 1.0;\n\t\t\t\t\t\t\t\t\tif (side === -1) sl *= 0.5;\n\t\t\t\t\t\t\t\t\telse sl = 1.0;\n\t\t\t\t\t\t\t\t\tside = -1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\txl = xi;\n\t\t\t\t\t\t\t\t\te0 = ei;\n\t\t\t\t\t\t\t\t\tsl = 1.0;\n\t\t\t\t\t\t\t\t\tif (side === 1) sr *= 0.5;\n\t\t\t\t\t\t\t\t\telse sr = 1.0;\n\t\t\t\t\t\t\t\t\tside = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ty1 = ret._at(0.5 * (x0 + xi), i - 1);\n\t\t\t\t\t\t\tret.f[i] = f(xi, yi);\n\t\t\t\t\t\t\tret.x[i] = xi;\n\t\t\t\t\t\t\tret.y[i] = yi;\n\t\t\t\t\t\t\tret.ymid[i - 1] = y1;\n\t\t\t\t\t\t\tret.events = ev;\n\t\t\t\t\t\t\tret.iterations = it;\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx0 += h;\n\t\t\t\t\ty0 = y1;\n\t\t\t\t\te0 = e1;\n\t\t\t\t\th = min(0.8 * h * pow(tol / erinf, 0.25), 4 * h);\n\t\t\t\t}\n\t\t\t\tret.iterations = it;\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\t// 11. Ax = b\n\t\t\tnumeric.LU = function(A, fast) {\n\t\t\t\tfast = fast || false;\n\n\t\t\t\tvar abs = Math.abs;\n\t\t\t\tvar i, j, k, absAjk, Akk, Ak, Pk, Ai;\n\t\t\t\tvar max;\n\t\t\t\tvar n = A.length,\n\t\t\t\t\tn1 = n - 1;\n\t\t\t\tvar P = new Array(n);\n\t\t\t\tif (!fast) A = numeric.clone(A);\n\n\t\t\t\tfor (k = 0; k < n; ++k) {\n\t\t\t\t\tPk = k;\n\t\t\t\t\tAk = A[k];\n\t\t\t\t\tmax = abs(Ak[k]);\n\t\t\t\t\tfor (j = k + 1; j < n; ++j) {\n\t\t\t\t\t\tabsAjk = abs(A[j][k]);\n\t\t\t\t\t\tif (max < absAjk) {\n\t\t\t\t\t\t\tmax = absAjk;\n\t\t\t\t\t\t\tPk = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tP[k] = Pk;\n\n\t\t\t\t\tif (Pk != k) {\n\t\t\t\t\t\tA[k] = A[Pk];\n\t\t\t\t\t\tA[Pk] = Ak;\n\t\t\t\t\t\tAk = A[k];\n\t\t\t\t\t}\n\n\t\t\t\t\tAkk = Ak[k];\n\n\t\t\t\t\tfor (i = k + 1; i < n; ++i) {\n\t\t\t\t\t\tA[i][k] /= Akk;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = k + 1; i < n; ++i) {\n\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\tfor (j = k + 1; j < n1; ++j) {\n\t\t\t\t\t\t\tAi[j] -= Ai[k] * Ak[j];\n\t\t\t\t\t\t\t++j;\n\t\t\t\t\t\t\tAi[j] -= Ai[k] * Ak[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === n1) Ai[j] -= Ai[k] * Ak[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tLU: A,\n\t\t\t\t\tP: P\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.LUsolve = function LUsolve(LUP, b) {\n\t\t\t\tvar i, j;\n\t\t\t\tvar LU = LUP.LU;\n\t\t\t\tvar n = LU.length;\n\t\t\t\tvar x = numeric.clone(b);\n\t\t\t\tvar P = LUP.P;\n\t\t\t\tvar Pi, LUi, LUii;\n\n\t\t\t\tfor (i = n - 1; i !== -1; --i) x[i] = b[i];\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tPi = P[i];\n\t\t\t\t\tif (P[i] !== i) {\n\t\t\t\t\t\ttmp = x[i];\n\t\t\t\t\t\tx[i] = x[Pi];\n\t\t\t\t\t\tx[Pi] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tLUi = LU[i];\n\t\t\t\t\tfor (j = 0; j < i; ++j) {\n\t\t\t\t\t\tx[i] -= x[j] * LUi[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (i = n - 1; i >= 0; --i) {\n\t\t\t\t\tLUi = LU[i];\n\t\t\t\t\tfor (j = i + 1; j < n; ++j) {\n\t\t\t\t\t\tx[i] -= x[j] * LUi[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tx[i] /= LUi[i];\n\t\t\t\t}\n\n\t\t\t\treturn x;\n\t\t\t};\n\n\t\t\tnumeric.solve = function solve(A, b, fast) {\n\t\t\t\treturn numeric.LUsolve(numeric.LU(A, fast), b);\n\t\t\t};\n\n\t\t\t// 12. Linear programming\n\t\t\tnumeric.echelonize = function echelonize(A) {\n\t\t\t\tvar s = numeric.dim(A),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1];\n\t\t\t\tvar I = numeric.identity(m);\n\t\t\t\tvar P = Array(m);\n\t\t\t\tvar i, j, k, l, Ai, Ii, Z, a;\n\t\t\t\tvar abs = Math.abs;\n\t\t\t\tvar diveq = numeric.diveq;\n\t\t\t\tA = numeric.clone(A);\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tk = 0;\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\tIi = I[i];\n\t\t\t\t\tfor (j = 1; j < n; ++j)\n\t\t\t\t\t\tif (abs(Ai[k]) < abs(Ai[j])) k = j;\n\t\t\t\t\tP[i] = k;\n\t\t\t\t\tdiveq(Ii, Ai[k]);\n\t\t\t\t\tdiveq(Ai, Ai[k]);\n\t\t\t\t\tfor (j = 0; j < m; ++j)\n\t\t\t\t\t\tif (j !== i) {\n\t\t\t\t\t\t\tZ = A[j];\n\t\t\t\t\t\t\ta = Z[k];\n\t\t\t\t\t\t\tfor (l = n - 1; l !== -1; --l) Z[l] -= Ai[l] * a;\n\t\t\t\t\t\t\tZ = I[j];\n\t\t\t\t\t\t\tfor (l = m - 1; l !== -1; --l) Z[l] -= Ii[l] * a;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tI: I,\n\t\t\t\t\tA: A,\n\t\t\t\t\tP: P\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric._solveLP = function _solveLP(c, A, b, tol, maxit, x) {\n\t\t\t\tvar sum = numeric.sum,\n\t\t\t\t\tlog = numeric.log,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tdot = numeric.dot,\n\t\t\t\t\tdiv = numeric.div,\n\t\t\t\t\tadd = numeric.add;\n\t\t\t\tvar m = c.length,\n\t\t\t\t\tn = b.length,\n\t\t\t\t\ty;\n\t\t\t\tvar unbounded = false,\n\t\t\t\t\tcb;\n\t\t\t\tif (typeof tol === \"undefined\") tol = numeric.epsilon;\n\t\t\t\tif (typeof maxit === \"undefined\") maxit = 1000;\n\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\tvar c0 = numeric.rep([m], 0).concat([1]);\n\t\t\t\t\tvar J = numeric.rep([n, 1], -1);\n\t\t\t\t\tvar A0 = numeric.blockMatrix([\n\t\t\t\t\t\t[A, J]\n\t\t\t\t\t]);\n\t\t\t\t\tvar b0 = b;\n\t\t\t\t\ty = numeric.rep([m], 0).concat(Math.max(0, numeric.sup(numeric.neg(b))) + 1);\n\t\t\t\t\tvar x0 = _solveLP(c0, A0, b0, tol, maxit, y);\n\t\t\t\t\tx = numeric.clone(x0.solution);\n\t\t\t\t\tx.length = m;\n\t\t\t\t\tvar foo = numeric.inf(sub(b, dot(A, x)));\n\t\t\t\t\tif (foo < 0) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsolution: NaN,\n\t\t\t\t\t\t\tmessage: \"Infeasible\"\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcb = function cb(it, x0, f0, g0, H1) {\n\t\t\t\t\t\tvar s = dot(c, g0),\n\t\t\t\t\t\t\tAg0 = dot(A, g0),\n\t\t\t\t\t\t\ti;\n\t\t\t\t\t\tfor (i = n - 1; i !== -1; --i)\n\t\t\t\t\t\t\tif (s * Ag0[i] < 0) return false;\n\t\t\t\t\t\tunbounded = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcb = function cb(it, x0, f0, g0, H1) {\n\t\t\t\t\t\tif (x0[m - 1] >= 0) return false;\n\t\t\t\t\t\tunbounded = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar alpha = 1.0;\n\t\t\t\tvar f0, df0;\n\t\t\t\twhile (1) {\n\t\t\t\t\tf0 = function(z) {\n\t\t\t\t\t\treturn sub(dot(c, z), mul(alpha, sum(log(sub(b, dot(A, z))))));\n\t\t\t\t\t};\n\t\t\t\t\tdf0 = function(z) {\n\t\t\t\t\t\treturn add(c, mul(alpha, dot(div(1, sub(b, dot(A, z))), A)));\n\t\t\t\t\t};\n\t\t\t\t\ty = numeric.uncmin(f0, x, alpha, df0, maxit, cb).solution;\n\t\t\t\t\tif (unbounded) return {\n\t\t\t\t\t\tsolution: y,\n\t\t\t\t\t\tmessage: \"Unbounded\"\n\t\t\t\t\t};\n\t\t\t\t\tif (alpha < tol) return {\n\t\t\t\t\t\tsolution: y,\n\t\t\t\t\t\tmessage: \"\"\n\t\t\t\t\t};\n\t\t\t\t\tx = y;\n\t\t\t\t\talpha *= 0.01;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnumeric.solveLP = function solveLP(c, A, b, Aeq, beq, tol, maxit) {\n\t\t\t\tif (typeof Aeq === \"undefined\") return numeric._solveLP(c, A, b, tol, maxit, x);\n\t\t\t\tvar m = Aeq.length,\n\t\t\t\t\tn = Aeq[0].length,\n\t\t\t\t\to = A.length;\n\t\t\t\tvar B = numeric.echelonize(Aeq);\n\t\t\t\tvar flags = numeric.rep([n], 0);\n\t\t\t\tvar P = B.P;\n\t\t\t\tvar Q = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = P.length - 1; i !== -1; --i) flags[P[i]] = 1;\n\t\t\t\tfor (i = n - 1; i !== -1; --i)\n\t\t\t\t\tif (flags[i] === 0) Q.push(i);\n\t\t\t\tvar g = numeric.getRange;\n\t\t\t\tvar I = numeric.linspace(0, m - 1),\n\t\t\t\t\tJ = numeric.linspace(0, o - 1);\n\t\t\t\tvar Aeq2 = g(Aeq, I, Q),\n\t\t\t\t\tA1 = g(A, J, P),\n\t\t\t\t\tA2 = g(A, J, Q),\n\t\t\t\t\tdot = numeric.dot,\n\t\t\t\t\tsub = numeric.sub;\n\t\t\t\tvar A3 = dot(A1, B.I);\n\t\t\t\tvar A4 = sub(A2, dot(A3, Aeq2)),\n\t\t\t\t\tb4 = sub(b, dot(A3, beq));\n\t\t\t\tvar c1 = Array(P.length),\n\t\t\t\t\tc2 = Array(Q.length);\n\t\t\t\tfor (i = P.length - 1; i !== -1; --i) c1[i] = c[P[i]];\n\t\t\t\tfor (i = Q.length - 1; i !== -1; --i) c2[i] = c[Q[i]];\n\t\t\t\tvar c4 = sub(c2, dot(c1, dot(B.I, Aeq2)));\n\t\t\t\tvar S = numeric._solveLP(c4, A4, b4, tol, maxit);\n\t\t\t\tvar x2 = S.solution;\n\t\t\t\tvar x1 = dot(B.I, sub(beq, dot(Aeq2, x2)));\n\t\t\t\tvar x = Array(c.length);\n\t\t\t\tfor (i = P.length - 1; i !== -1; --i) x[P[i]] = x1[i];\n\t\t\t\tfor (i = Q.length - 1; i !== -1; --i) x[Q[i]] = x2[i];\n\t\t\t\treturn {\n\t\t\t\t\tsolution: x,\n\t\t\t\t\tmessage: S.message\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.MPStoLP = function MPStoLP(MPS) {\n\t\t\t\tif (MPS instanceof String) {\n\t\t\t\t\tMPS.split('\\n');\n\t\t\t\t}\n\t\t\t\tvar state = 0;\n\t\t\t\tvar states = ['Initial state', 'NAME', 'ROWS', 'COLUMNS', 'RHS', 'BOUNDS', 'ENDATA'];\n\t\t\t\tvar n = MPS.length;\n\t\t\t\tvar i, j, z, N = 0,\n\t\t\t\t\trows = {},\n\t\t\t\t\tsign = [],\n\t\t\t\t\trl = 0,\n\t\t\t\t\tvars = {},\n\t\t\t\t\tnv = 0;\n\t\t\t\tvar name;\n\t\t\t\tvar c = [],\n\t\t\t\t\tA = [],\n\t\t\t\t\tb = [];\n\n\t\t\t\tfunction err(e) {\n\t\t\t\t\tthrow new Error('MPStoLP: ' + e + '\\nLine ' + i + ': ' + MPS[i] + '\\nCurrent state: ' + states[state] + '\\n');\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tz = MPS[i];\n\t\t\t\t\tvar w0 = z.match(/\\S*/g);\n\t\t\t\t\tvar w = [];\n\t\t\t\t\tfor (j = 0; j < w0.length; ++j)\n\t\t\t\t\t\tif (w0[j] !== \"\") w.push(w0[j]);\n\t\t\t\t\tif (w.length === 0) continue;\n\t\t\t\t\tfor (j = 0; j < states.length; ++j)\n\t\t\t\t\t\tif (z.substr(0, states[j].length) === states[j]) break;\n\t\t\t\t\tif (j < states.length) {\n\t\t\t\t\t\tstate = j;\n\t\t\t\t\t\tif (j === 1) {\n\t\t\t\t\t\t\tname = w[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === 6) return {\n\t\t\t\t\t\t\tname: name,\n\t\t\t\t\t\t\tc: c,\n\t\t\t\t\t\t\tA: numeric.transpose(A),\n\t\t\t\t\t\t\tb: b,\n\t\t\t\t\t\t\trows: rows,\n\t\t\t\t\t\t\tvars: vars\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\terr('Unexpected line');\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tswitch (w[0]) {\n\t\t\t\t\t\t\t\tcase 'N':\n\t\t\t\t\t\t\t\t\tif (N === 0) N = w[1];\n\t\t\t\t\t\t\t\t\telse err('Two or more N rows');\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\t\t\trows[w[1]] = rl;\n\t\t\t\t\t\t\t\t\tsign[rl] = 1;\n\t\t\t\t\t\t\t\t\tb[rl] = 0;\n\t\t\t\t\t\t\t\t\t++rl;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'G':\n\t\t\t\t\t\t\t\t\trows[w[1]] = rl;\n\t\t\t\t\t\t\t\t\tsign[rl] = -1;\n\t\t\t\t\t\t\t\t\tb[rl] = 0;\n\t\t\t\t\t\t\t\t\t++rl;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'E':\n\t\t\t\t\t\t\t\t\trows[w[1]] = rl;\n\t\t\t\t\t\t\t\t\tsign[rl] = 0;\n\t\t\t\t\t\t\t\t\tb[rl] = 0;\n\t\t\t\t\t\t\t\t\t++rl;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\terr('Parse error ' + numeric.prettyPrint(w));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tif (!vars.hasOwnProperty(w[0])) {\n\t\t\t\t\t\t\t\tvars[w[0]] = nv;\n\t\t\t\t\t\t\t\tc[nv] = 0;\n\t\t\t\t\t\t\t\tA[nv] = numeric.rep([rl], 0);\n\t\t\t\t\t\t\t\t++nv;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar p = vars[w[0]];\n\t\t\t\t\t\t\tfor (j = 1; j < w.length; j += 2) {\n\t\t\t\t\t\t\t\tif (w[j] === N) {\n\t\t\t\t\t\t\t\t\tc[p] = parseFloat(w[j + 1]);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar q = rows[w[j]];\n\t\t\t\t\t\t\t\tA[p][q] = (sign[q] < 0 ? -1 : 1) * parseFloat(w[j + 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfor (j = 1; j < w.length; j += 2) b[rows[w[j]]] = (sign[rows[w[j]]] < 0 ? -1 : 1) * parseFloat(w[j + 1]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t/*FIXME*/\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\terr('Internal error');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terr('Reached end of file without ENDATA');\n\t\t\t};\n\t\t\t// seedrandom.js version 2.0.\n\t\t\t// Author: David Bau 4/2/2011\n\t\t\t//\n\t\t\t// Defines a method Math.seedrandom() that, when called, substitutes\n\t\t\t// an explicitly seeded RC4-based algorithm for Math.random().  Also\n\t\t\t// supports automatic seeding from local or network sources of entropy.\n\t\t\t//\n\t\t\t// Usage:\n\t\t\t//\n\t\t\t//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>\n\t\t\t//\n\t\t\t//   Math.seedrandom('yipee'); Sets Math.random to a function that is\n\t\t\t//                             initialized using the given explicit seed.\n\t\t\t//\n\t\t\t//   Math.seedrandom();        Sets Math.random to a function that is\n\t\t\t//                             seeded using the current time, dom state,\n\t\t\t//                             and other accumulated local entropy.\n\t\t\t//                             The generated seed string is returned.\n\t\t\t//\n\t\t\t//   Math.seedrandom('yowza', true);\n\t\t\t//                             Seeds using the given explicit seed mixed\n\t\t\t//                             together with accumulated entropy.\n\t\t\t//\n\t\t\t//   <script src=\"http://bit.ly/srandom-512\"></script>\n\t\t\t//                             Seeds using physical random bits downloaded\n\t\t\t//                             from random.org.\n\t\t\t//\n\t\t\t//   <script src=\"https://jsonlib.appspot.com/urandom?callback=Math.seedrandom\">\n\t\t\t//   </script>                 Seeds using urandom bits from call.jsonlib.com,\n\t\t\t//                             which is faster than random.org.\n\t\t\t//\n\t\t\t// Examples:\n\t\t\t//\n\t\t\t//   Math.seedrandom(\"hello\");            // Use \"hello\" as the seed.\n\t\t\t//   document.write(Math.random());       // Always 0.5463663768140734\n\t\t\t//   document.write(Math.random());       // Always 0.43973793770592234\n\t\t\t//   var rng1 = Math.random;              // Remember the current prng.\n\t\t\t//\n\t\t\t//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.\n\t\t\t//   document.write(Math.random());       // Pretty much unpredictable.\n\t\t\t//\n\t\t\t//   Math.random = rng1;                  // Continue \"hello\" prng sequence.\n\t\t\t//   document.write(Math.random());       // Always 0.554769432473455\n\t\t\t//\n\t\t\t//   Math.seedrandom(autoseed);           // Restart at the previous seed.\n\t\t\t//   document.write(Math.random());       // Repeat the 'unpredictable' value.\n\t\t\t//\n\t\t\t// Notes:\n\t\t\t//\n\t\t\t// Each time seedrandom('arg') is called, entropy from the passed seed\n\t\t\t// is accumulated in a pool to help generate future seeds for the\n\t\t\t// zero-argument form of Math.seedrandom, so entropy can be injected over\n\t\t\t// time by calling seedrandom with explicit data repeatedly.\n\t\t\t//\n\t\t\t// On speed - This javascript implementation of Math.random() is about\n\t\t\t// 3-10x slower than the built-in Math.random() because it is not native\n\t\t\t// code, but this is typically fast enough anyway.  Seeding is more expensive,\n\t\t\t// especially if you use auto-seeding.  Some details (timings on Chrome 4):\n\t\t\t//\n\t\t\t// Our Math.random()            - avg less than 0.002 milliseconds per call\n\t\t\t// seedrandom('explicit')       - avg less than 0.5 milliseconds per call\n\t\t\t// seedrandom('explicit', true) - avg less than 2 milliseconds per call\n\t\t\t// seedrandom()                 - avg about 38 milliseconds per call\n\t\t\t//\n\t\t\t// LICENSE (BSD):\n\t\t\t//\n\t\t\t// Copyright 2010 David Bau, all rights reserved.\n\t\t\t//\n\t\t\t// Redistribution and use in source and binary forms, with or without\n\t\t\t// modification, are permitted provided that the following conditions are met:\n\t\t\t// \n\t\t\t//   1. Redistributions of source code must retain the above copyright\n\t\t\t//      notice, this list of conditions and the following disclaimer.\n\t\t\t//\n\t\t\t//   2. Redistributions in binary form must reproduce the above copyright\n\t\t\t//      notice, this list of conditions and the following disclaimer in the\n\t\t\t//      documentation and/or other materials provided with the distribution.\n\t\t\t// \n\t\t\t//   3. Neither the name of this module nor the names of its contributors may\n\t\t\t//      be used to endorse or promote products derived from this software\n\t\t\t//      without specific prior written permission.\n\t\t\t// \n\t\t\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t\t\t// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t\t\t// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t\t\t// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t\t\t// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t\t\t// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t\t\t// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t\t\t// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t\t\t// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t\t\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t\t\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t\t\t//\n\t\t\t/**\n\t\t\t * All code is in an anonymous closure to keep the global namespace clean.\n\t\t\t *\n\t\t\t * @param {number=} overflow \n\t\t\t * @param {number=} startdenom\n\t\t\t */\n\n\t\t\t// Patched by Seb so that seedrandom.js does not pollute the Math object.\n\t\t\t// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%\n\t\t\t// slower.\n\t\t\tnumeric.seedrandom = {\n\t\t\t\tpow: Math.pow,\n\t\t\t\trandom: Math.random\n\t\t\t};\n\n\t\t\t(function(pool, math, width, chunks, significance, overflow, startdenom) {\n\n\n\t\t\t\t//\n\t\t\t\t// seedrandom()\n\t\t\t\t// This is the seedrandom function described above.\n\t\t\t\t//\n\t\t\t\tmath['seedrandom'] = function seedrandom(seed, use_entropy) {\n\t\t\t\t\tvar key = [];\n\t\t\t\t\tvar arc4;\n\n\t\t\t\t\t// Flatten the seed string or build one from local entropy if needed.\n\t\t\t\t\tseed = mixkey(flatten(\n\t\t\t\t\t\tuse_entropy ? [seed, pool] :\n\t\t\t\t\t\targuments.length ? seed : [new Date().getTime(), pool, window], 3), key);\n\n\t\t\t\t\t// Use the seed to initialize an ARC4 generator.\n\t\t\t\t\tarc4 = new ARC4(key);\n\n\t\t\t\t\t// Mix the randomness into accumulated entropy.\n\t\t\t\t\tmixkey(arc4.S, pool);\n\n\t\t\t\t\t// Override Math.random\n\n\t\t\t\t\t// This function returns a random double in [0, 1) that contains\n\t\t\t\t\t// randomness in every bit of the mantissa of the IEEE 754 value.\n\n\t\t\t\t\tmath['random'] = function random() { // Closure to return a random double:\n\t\t\t\t\t\tvar n = arc4.g(chunks); // Start with a numerator n < 2 ^ 48\n\t\t\t\t\t\tvar d = startdenom; //   and denominator d = 2 ^ 48.\n\t\t\t\t\t\tvar x = 0; //   and no 'extra last byte'.\n\t\t\t\t\t\twhile (n < significance) { // Fill up all significant digits by\n\t\t\t\t\t\t\tn = (n + x) * width; //   shifting numerator and\n\t\t\t\t\t\t\td *= width; //   denominator and generating a\n\t\t\t\t\t\t\tx = arc4.g(1); //   new least-significant-byte.\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (n >= overflow) { // To avoid rounding up, before adding\n\t\t\t\t\t\t\tn /= 2; //   last byte, shift everything\n\t\t\t\t\t\t\td /= 2; //   right using integer math until\n\t\t\t\t\t\t\tx >>>= 1; //   we have exactly the desired bits.\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (n + x) / d; // Form the number within [0, 1).\n\t\t\t\t\t};\n\n\t\t\t\t\t// Return the seed that was used\n\t\t\t\t\treturn seed;\n\t\t\t\t};\n\n\t\t\t\t//\n\t\t\t\t// ARC4\n\t\t\t\t//\n\t\t\t\t// An ARC4 implementation.  The constructor takes a key in the form of\n\t\t\t\t// an array of at most (width) integers that should be 0 <= x < (width).\n\t\t\t\t//\n\t\t\t\t// The g(count) method returns a pseudorandom integer that concatenates\n\t\t\t\t// the next (count) outputs from ARC4.  Its return value is a number x\n\t\t\t\t// that is in the range 0 <= x < (width ^ count).\n\t\t\t\t//\n\t\t\t\t/** @constructor */\n\t\t\t\tfunction ARC4(key) {\n\t\t\t\t\tvar t, u, me = this,\n\t\t\t\t\t\tkeylen = key.length;\n\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\tj = me.i = me.j = me.m = 0;\n\t\t\t\t\tme.S = [];\n\t\t\t\t\tme.c = [];\n\n\t\t\t\t\t// The empty key [] is treated as [0].\n\t\t\t\t\tif (!keylen) {\n\t\t\t\t\t\tkey = [keylen++];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set up S using the standard key scheduling algorithm.\n\t\t\t\t\twhile (i < width) {\n\t\t\t\t\t\tme.S[i] = i++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < width; i++) {\n\t\t\t\t\t\tt = me.S[i];\n\t\t\t\t\t\tj = lowbits(j + t + key[i % keylen]);\n\t\t\t\t\t\tu = me.S[j];\n\t\t\t\t\t\tme.S[i] = u;\n\t\t\t\t\t\tme.S[j] = t;\n\t\t\t\t\t}\n\n\t\t\t\t\t// The \"g\" method returns the next (count) outputs as one number.\n\t\t\t\t\tme.g = function getnext(count) {\n\t\t\t\t\t\tvar s = me.S;\n\t\t\t\t\t\tvar i = lowbits(me.i + 1);\n\t\t\t\t\t\tvar t = s[i];\n\t\t\t\t\t\tvar j = lowbits(me.j + t);\n\t\t\t\t\t\tvar u = s[j];\n\t\t\t\t\t\ts[i] = u;\n\t\t\t\t\t\ts[j] = t;\n\t\t\t\t\t\tvar r = s[lowbits(t + u)];\n\t\t\t\t\t\twhile (--count) {\n\t\t\t\t\t\t\ti = lowbits(i + 1);\n\t\t\t\t\t\t\tt = s[i];\n\t\t\t\t\t\t\tj = lowbits(j + t);\n\t\t\t\t\t\t\tu = s[j];\n\t\t\t\t\t\t\ts[i] = u;\n\t\t\t\t\t\t\ts[j] = t;\n\t\t\t\t\t\t\tr = r * width + s[lowbits(t + u)];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tme.i = i;\n\t\t\t\t\t\tme.j = j;\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t};\n\t\t\t\t\t// For robust unpredictability discard an initial batch of values.\n\t\t\t\t\t// See http://www.rsa.com/rsalabs/node.asp?id=2009\n\t\t\t\t\tme.g(width);\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// flatten()\n\t\t\t\t// Converts an object tree to nested arrays of strings.\n\t\t\t\t//\n\t\t\t\t/** @param {Object=} result \n\t\t\t\t * @param {string=} prop\n\t\t\t\t * @param {string=} typ */\n\t\t\t\tfunction flatten(obj, depth, result, prop, typ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t\ttyp = typeof(obj);\n\t\t\t\t\tif (depth && typ == 'object') {\n\t\t\t\t\t\tfor (prop in obj) {\n\t\t\t\t\t\t\tif (prop.indexOf('S') < 5) { // Avoid FF3 bug (local/sessionStorage)\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult.push(flatten(obj[prop], depth - 1));\n\t\t\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn (result.length ? result : obj + (typ != 'string' ? '\\0' : ''));\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// mixkey()\n\t\t\t\t// Mixes a string seed into a key that is an array of integers, and\n\t\t\t\t// returns a shortened string seed that is equivalent to the result key.\n\t\t\t\t//\n\t\t\t\t/** @param {number=} smear \n\t\t\t\t * @param {number=} j */\n\t\t\t\tfunction mixkey(seed, key, smear, j) {\n\t\t\t\t\tseed += ''; // Ensure the seed is a string\n\t\t\t\t\tsmear = 0;\n\t\t\t\t\tfor (j = 0; j < seed.length; j++) {\n\t\t\t\t\t\tkey[lowbits(j)] =\n\t\t\t\t\t\t\tlowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));\n\t\t\t\t\t}\n\t\t\t\t\tseed = '';\n\t\t\t\t\tfor (j in key) {\n\t\t\t\t\t\tseed += String.fromCharCode(key[j]);\n\t\t\t\t\t}\n\t\t\t\t\treturn seed;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// lowbits()\n\t\t\t\t// A quick \"n mod width\" for width a power of 2.\n\t\t\t\t//\n\t\t\t\tfunction lowbits(n) {\n\t\t\t\t\treturn n & (width - 1);\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// The following constants are related to IEEE 754 limits.\n\t\t\t\t//\n\t\t\t\tstartdenom = math.pow(width, chunks);\n\t\t\t\tsignificance = math.pow(2, significance);\n\t\t\t\toverflow = significance * 2;\n\n\t\t\t\t//\n\t\t\t\t// When seedrandom.js is loaded, we immediately mix a few bits\n\t\t\t\t// from the built-in RNG into the entropy pool.  Because we do\n\t\t\t\t// not want to intefere with determinstic PRNG state later,\n\t\t\t\t// seedrandom will not call math.random on its own again after\n\t\t\t\t// initialization.\n\t\t\t\t//\n\t\t\t\tmixkey(math.random(), pool);\n\n\t\t\t\t// End anonymous scope, and pass initial values.\n\t\t\t}(\n\t\t\t\t[], // pool: entropy pool starts empty\n\t\t\t\tnumeric.seedrandom, // math: package containing random, pow, and seedrandom\n\t\t\t\t256, // width: each RC4 output is 0 <= x < 256\n\t\t\t\t6, // chunks: at least six RC4 outputs for each double\n\t\t\t\t52 // significance: there are 52 significant digits in a double\n\t\t\t));\n\t\t\t/* This file is a slightly modified version of quadprog.js from Alberto Santini.\n\t\t\t * It has been slightly modified by Sbastien Loisel to make sure that it handles\n\t\t\t * 0-based Arrays instead of 1-based Arrays.\n\t\t\t * License is in resources/LICENSE.quadprog */\n\t\t\t(function(exports) {\n\n\t\t\t\tfunction base0to1(A) {\n\t\t\t\t\tif (typeof A !== \"object\") {\n\t\t\t\t\t\treturn A;\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\ti, n = A.length;\n\t\t\t\t\tfor (i = 0; i < n; i++) ret[i + 1] = base0to1(A[i]);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tfunction base1to0(A) {\n\t\t\t\t\tif (typeof A !== \"object\") {\n\t\t\t\t\t\treturn A;\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\ti, n = A.length;\n\t\t\t\t\tfor (i = 1; i < n; i++) ret[i - 1] = base1to0(A[i]);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tfunction dpori(a, lda, n) {\n\t\t\t\t\tvar i, j, k, kp1, t;\n\n\t\t\t\t\tfor (k = 1; k <= n; k = k + 1) {\n\t\t\t\t\t\ta[k][k] = 1 / a[k][k];\n\t\t\t\t\t\tt = -a[k][k];\n\t\t\t\t\t\t//~ dscal(k - 1, t, a[1][k], 1);\n\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\ta[i][k] = t * a[i][k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tkp1 = k + 1;\n\t\t\t\t\t\tif (n < kp1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = kp1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tt = a[k][j];\n\t\t\t\t\t\t\ta[k][j] = 0;\n\t\t\t\t\t\t\t//~ daxpy(k, t, a[1][k], 1, a[1][j], 1);\n\t\t\t\t\t\t\tfor (i = 1; i <= k; i = i + 1) {\n\t\t\t\t\t\t\t\ta[i][j] = a[i][j] + (t * a[i][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction dposl(a, lda, n, b) {\n\t\t\t\t\tvar i, k, kb, t;\n\n\t\t\t\t\tfor (k = 1; k <= n; k = k + 1) {\n\t\t\t\t\t\t//~ t = ddot(k - 1, a[1][k], 1, b[1], 1);\n\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\tt = t + (a[i][k] * b[i]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tb[k] = (b[k] - t) / a[k][k];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (kb = 1; kb <= n; kb = kb + 1) {\n\t\t\t\t\t\tk = n + 1 - kb;\n\t\t\t\t\t\tb[k] = b[k] / a[k][k];\n\t\t\t\t\t\tt = -b[k];\n\t\t\t\t\t\t//~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);\n\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\tb[i] = b[i] + (t * a[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction dpofa(a, lda, n, info) {\n\t\t\t\t\tvar i, j, jm1, k, t, s;\n\n\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\tinfo[1] = j;\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t\tjm1 = j - 1;\n\t\t\t\t\t\tif (jm1 < 1) {\n\t\t\t\t\t\t\ts = a[j][j] - s;\n\t\t\t\t\t\t\tif (s <= 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ta[j][j] = Math.sqrt(s);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (k = 1; k <= jm1; k = k + 1) {\n\t\t\t\t\t\t\t\t//~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);\n\t\t\t\t\t\t\t\tt = a[k][j];\n\t\t\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\t\t\tt = t - (a[i][j] * a[i][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt = t / a[k][k];\n\t\t\t\t\t\t\t\ta[k][j] = t;\n\t\t\t\t\t\t\t\ts = s + t * t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = a[j][j] - s;\n\t\t\t\t\t\t\tif (s <= 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ta[j][j] = Math.sqrt(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo[1] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,\n\t\t\t\t\tbvec, fdamat, q, meq, iact, nact, iter, work, ierr) {\n\n\t\t\t\t\tvar i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,\n\t\t\t\t\t\ttemp, sum, t1, tt, gc, gs, nu,\n\t\t\t\t\t\tt1inf, t2min,\n\t\t\t\t\t\tvsmall, tmpa, tmpb,\n\t\t\t\t\t\tgo;\n\n\t\t\t\t\tr = Math.min(n, q);\n\t\t\t\t\tl = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;\n\n\t\t\t\t\tvsmall = 1.0e-60;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tvsmall = vsmall + vsmall;\n\t\t\t\t\t\ttmpa = 1 + 0.1 * vsmall;\n\t\t\t\t\t\ttmpb = 1 + 0.2 * vsmall;\n\t\t\t\t\t} while (tmpa <= 1 || tmpb <= 1);\n\n\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\twork[i] = dvec[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = n + 1; i <= l; i = i + 1) {\n\t\t\t\t\t\twork[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\tiact[i] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo = [];\n\n\t\t\t\t\tif (ierr[1] === 0) {\n\t\t\t\t\t\tdpofa(dmat, fddmat, n, info);\n\t\t\t\t\t\tif (info[1] !== 0) {\n\t\t\t\t\t\t\tierr[1] = 2;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdposl(dmat, fddmat, n, dvec);\n\t\t\t\t\t\tdpori(dmat, fddmat, n);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tsol[j] = 0;\n\t\t\t\t\t\t\tfor (i = 1; i <= j; i = i + 1) {\n\t\t\t\t\t\t\t\tsol[j] = sol[j] + dmat[i][j] * dvec[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tdvec[j] = 0;\n\t\t\t\t\t\t\tfor (i = j; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\tdvec[j] = dvec[j] + dmat[j][i] * sol[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcrval[1] = 0;\n\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\tsol[j] = dvec[j];\n\t\t\t\t\t\tcrval[1] = crval[1] + work[j] * sol[j];\n\t\t\t\t\t\twork[j] = 0;\n\t\t\t\t\t\tfor (i = j + 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\tdmat[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcrval[1] = -crval[1] / 2;\n\t\t\t\t\tierr[1] = 0;\n\n\t\t\t\t\tiwzv = n;\n\t\t\t\t\tiwrv = iwzv + n;\n\t\t\t\t\tiwuv = iwrv + r;\n\t\t\t\t\tiwrm = iwuv + r + 1;\n\t\t\t\t\tiwsv = iwrm + (r * (r + 1)) / 2;\n\t\t\t\t\tiwnbv = iwsv + q;\n\n\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tsum = sum + amat[j][i] * amat[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[iwnbv + i] = Math.sqrt(sum);\n\t\t\t\t\t}\n\t\t\t\t\tnact = 0;\n\t\t\t\t\titer[1] = 0;\n\t\t\t\t\titer[2] = 0;\n\n\t\t\t\t\tfunction fn_goto_50() {\n\t\t\t\t\t\titer[1] = iter[1] + 1;\n\n\t\t\t\t\t\tl = iwsv;\n\t\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\t\tl = l + 1;\n\t\t\t\t\t\t\tsum = -bvec[i];\n\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\tsum = sum + amat[j][i] * sol[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (Math.abs(sum) < vsmall) {\n\t\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i > meq) {\n\t\t\t\t\t\t\t\twork[l] = sum;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twork[l] = -Math.abs(sum);\n\t\t\t\t\t\t\t\tif (sum > 0) {\n\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\tamat[j][i] = -amat[j][i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbvec[i] = -bvec[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\twork[iwsv + iact[i]] = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnvl = 0;\n\t\t\t\t\t\ttemp = 0;\n\t\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\t\tif (work[iwsv + i] < temp * work[iwnbv + i]) {\n\t\t\t\t\t\t\t\tnvl = i;\n\t\t\t\t\t\t\t\ttemp = work[iwsv + i] / work[iwnbv + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nvl === 0) {\n\t\t\t\t\t\t\treturn 999;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_55() {\n\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\tsum = sum + dmat[j][i] * amat[j][nvl];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork[i] = sum;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tl1 = iwzv;\n\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\twork[l1 + i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = nact + 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\twork[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt1inf = true;\n\t\t\t\t\t\tfor (i = nact; i >= 1; i = i - 1) {\n\t\t\t\t\t\t\tsum = work[i];\n\t\t\t\t\t\t\tl = iwrm + (i * (i + 3)) / 2;\n\t\t\t\t\t\t\tl1 = l - i;\n\t\t\t\t\t\t\tfor (j = i + 1; j <= nact; j = j + 1) {\n\t\t\t\t\t\t\t\tsum = sum - work[l] * work[iwrv + j];\n\t\t\t\t\t\t\t\tl = l + j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum = sum / work[l1];\n\t\t\t\t\t\t\twork[iwrv + i] = sum;\n\t\t\t\t\t\t\tif (iact[i] < meq) {\n\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (sum < 0) {\n\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt1inf = false;\n\t\t\t\t\t\t\tit1 = i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!t1inf) {\n\t\t\t\t\t\t\tt1 = work[iwuv + it1] / work[iwrv + it1];\n\t\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\tif (iact[i] < meq) {\n\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (work[iwrv + i] < 0) {\n\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttemp = work[iwuv + i] / work[iwrv + i];\n\t\t\t\t\t\t\t\tif (temp < t1) {\n\t\t\t\t\t\t\t\t\tt1 = temp;\n\t\t\t\t\t\t\t\t\tit1 = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor (i = iwzv + 1; i <= iwzv + n; i = i + 1) {\n\t\t\t\t\t\t\tsum = sum + work[i] * work[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Math.abs(sum) <= vsmall) {\n\t\t\t\t\t\t\tif (t1inf) {\n\t\t\t\t\t\t\t\tierr[1] = 1;\n\t\t\t\t\t\t\t\t// GOTO 999\n\t\t\t\t\t\t\t\treturn 999;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\t\twork[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twork[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;\n\t\t\t\t\t\t\t\t// GOTO 700\n\t\t\t\t\t\t\t\treturn 700;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\tsum = sum + work[iwzv + i] * amat[i][nvl];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttt = -work[iwsv + nvl] / sum;\n\t\t\t\t\t\t\tt2min = true;\n\t\t\t\t\t\t\tif (!t1inf) {\n\t\t\t\t\t\t\t\tif (t1 < tt) {\n\t\t\t\t\t\t\t\t\ttt = t1;\n\t\t\t\t\t\t\t\t\tt2min = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\tsol[i] = sol[i] + tt * work[iwzv + i];\n\t\t\t\t\t\t\t\tif (Math.abs(sol[i]) < vsmall) {\n\t\t\t\t\t\t\t\t\tsol[i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcrval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);\n\t\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\twork[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;\n\n\t\t\t\t\t\t\tif (t2min) {\n\t\t\t\t\t\t\t\tnact = nact + 1;\n\t\t\t\t\t\t\t\tiact[nact] = nvl;\n\n\t\t\t\t\t\t\t\tl = iwrm + ((nact - 1) * nact) / 2 + 1;\n\t\t\t\t\t\t\t\tfor (i = 1; i <= nact - 1; i = i + 1) {\n\t\t\t\t\t\t\t\t\twork[l] = work[i];\n\t\t\t\t\t\t\t\t\tl = l + 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (nact === n) {\n\t\t\t\t\t\t\t\t\twork[l] = work[n];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (i = n; i >= nact + 1; i = i - 1) {\n\t\t\t\t\t\t\t\t\t\tif (work[i] === 0) {\n\t\t\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tgc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));\n\t\t\t\t\t\t\t\t\t\tgs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));\n\t\t\t\t\t\t\t\t\t\tif (work[i - 1] >= 0) {\n\t\t\t\t\t\t\t\t\t\t\ttemp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ttemp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tgc = work[i - 1] / temp;\n\t\t\t\t\t\t\t\t\t\tgs = work[i] / temp;\n\n\t\t\t\t\t\t\t\t\t\tif (gc === 1) {\n\t\t\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (gc === 0) {\n\t\t\t\t\t\t\t\t\t\t\twork[i - 1] = gs * temp;\n\t\t\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\t\t\ttemp = dmat[j][i - 1];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i - 1] = dmat[j][i];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i] = temp;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twork[i - 1] = temp;\n\t\t\t\t\t\t\t\t\t\t\tnu = gs / (1 + gc);\n\t\t\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\t\t\ttemp = gc * dmat[j][i - 1] + gs * dmat[j][i];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i - 1] = temp;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twork[l] = work[nact];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsum = -bvec[nvl];\n\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\tsum = sum + sol[j] * amat[j][nvl];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nvl > meq) {\n\t\t\t\t\t\t\t\t\twork[iwsv + nvl] = sum;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twork[iwsv + nvl] = -Math.abs(sum);\n\t\t\t\t\t\t\t\t\tif (sum > 0) {\n\t\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\t\tamat[j][nvl] = -amat[j][nvl];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbvec[nvl] = -bvec[nvl];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// GOTO 700\n\t\t\t\t\t\t\t\treturn 700;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_797() {\n\t\t\t\t\t\tl = iwrm + (it1 * (it1 + 1)) / 2 + 1;\n\t\t\t\t\t\tl1 = l + it1;\n\t\t\t\t\t\tif (work[l1] === 0) {\n\t\t\t\t\t\t\t// GOTO 798\n\t\t\t\t\t\t\treturn 798;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));\n\t\t\t\t\t\tgs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));\n\t\t\t\t\t\tif (work[l1 - 1] >= 0) {\n\t\t\t\t\t\t\ttemp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgc = work[l1 - 1] / temp;\n\t\t\t\t\t\tgs = work[l1] / temp;\n\n\t\t\t\t\t\tif (gc === 1) {\n\t\t\t\t\t\t\t// GOTO 798\n\t\t\t\t\t\t\treturn 798;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gc === 0) {\n\t\t\t\t\t\t\tfor (i = it1 + 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = work[l1 - 1];\n\t\t\t\t\t\t\t\twork[l1 - 1] = work[l1];\n\t\t\t\t\t\t\t\twork[l1] = temp;\n\t\t\t\t\t\t\t\tl1 = l1 + i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = dmat[i][it1];\n\t\t\t\t\t\t\t\tdmat[i][it1] = dmat[i][it1 + 1];\n\t\t\t\t\t\t\t\tdmat[i][it1 + 1] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnu = gs / (1 + gc);\n\t\t\t\t\t\t\tfor (i = it1 + 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = gc * work[l1 - 1] + gs * work[l1];\n\t\t\t\t\t\t\t\twork[l1] = nu * (work[l1 - 1] + temp) - work[l1];\n\t\t\t\t\t\t\t\twork[l1 - 1] = temp;\n\t\t\t\t\t\t\t\tl1 = l1 + i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];\n\t\t\t\t\t\t\t\tdmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];\n\t\t\t\t\t\t\t\tdmat[i][it1] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_798() {\n\t\t\t\t\t\tl1 = l - it1;\n\t\t\t\t\t\tfor (i = 1; i <= it1; i = i + 1) {\n\t\t\t\t\t\t\twork[l1] = work[l];\n\t\t\t\t\t\t\tl = l + 1;\n\t\t\t\t\t\t\tl1 = l1 + 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork[iwuv + it1] = work[iwuv + it1 + 1];\n\t\t\t\t\t\tiact[it1] = iact[it1 + 1];\n\t\t\t\t\t\tit1 = it1 + 1;\n\t\t\t\t\t\tif (it1 < nact) {\n\t\t\t\t\t\t\t// GOTO 797\n\t\t\t\t\t\t\treturn 797;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_799() {\n\t\t\t\t\t\twork[iwuv + nact] = work[iwuv + nact + 1];\n\t\t\t\t\t\twork[iwuv + nact + 1] = 0;\n\t\t\t\t\t\tiact[nact] = 0;\n\t\t\t\t\t\tnact = nact - 1;\n\t\t\t\t\t\titer[2] = iter[2] + 1;\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tgo = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tgo = fn_goto_50();\n\t\t\t\t\t\tif (go === 999) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tgo = fn_goto_55();\n\t\t\t\t\t\t\tif (go === 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (go === 999) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (go === 700) {\n\t\t\t\t\t\t\t\tif (it1 === nact) {\n\t\t\t\t\t\t\t\t\tfn_goto_799();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\t\tfn_goto_797();\n\t\t\t\t\t\t\t\t\t\tgo = fn_goto_798();\n\t\t\t\t\t\t\t\t\t\tif (go !== 797) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfn_goto_799();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {\n\t\t\t\t\tDmat = base0to1(Dmat);\n\t\t\t\t\tdvec = base0to1(dvec);\n\t\t\t\t\tAmat = base0to1(Amat);\n\t\t\t\t\tvar i, n, q,\n\t\t\t\t\t\tnact, r,\n\t\t\t\t\t\tcrval = [],\n\t\t\t\t\t\tiact = [],\n\t\t\t\t\t\tsol = [],\n\t\t\t\t\t\twork = [],\n\t\t\t\t\t\titer = [],\n\t\t\t\t\t\tmessage;\n\n\t\t\t\t\tmeq = meq || 0;\n\t\t\t\t\tfactorized = factorized ? base0to1(factorized) : [undefined, 0];\n\t\t\t\t\tbvec = bvec ? base0to1(bvec) : [];\n\n\t\t\t\t\t// In Fortran the array index starts from 1\n\t\t\t\t\tn = Dmat.length - 1;\n\t\t\t\t\tq = Amat[1].length - 1;\n\n\t\t\t\t\tif (!bvec) {\n\t\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\t\tbvec[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\tiact[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tnact = 0;\n\t\t\t\t\tr = Math.min(n, q);\n\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\tsol[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcrval[1] = 0;\n\t\t\t\t\tfor (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {\n\t\t\t\t\t\twork[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 1; i <= 2; i = i + 1) {\n\t\t\t\t\t\titer[i] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tqpgen2(Dmat, dvec, n, n, sol, crval, Amat,\n\t\t\t\t\t\tbvec, n, q, meq, iact, nact, iter, work, factorized);\n\n\t\t\t\t\tmessage = \"\";\n\t\t\t\t\tif (factorized[1] === 1) {\n\t\t\t\t\t\tmessage = \"constraints are inconsistent, no solution!\";\n\t\t\t\t\t}\n\t\t\t\t\tif (factorized[1] === 2) {\n\t\t\t\t\t\tmessage = \"matrix D in quadratic function is not positive definite!\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsolution: base1to0(sol),\n\t\t\t\t\t\tvalue: base1to0(crval),\n\t\t\t\t\t\tunconstrained_solution: base1to0(dvec),\n\t\t\t\t\t\titerations: base1to0(iter),\n\t\t\t\t\t\tiact: base1to0(iact),\n\t\t\t\t\t\tmessage: message\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\texports.solveQP = solveQP;\n\t\t\t}(numeric));\n\t\t\t/*\n\t\t\tShanti Rao sent me this routine by private email. I had to modify it\n\t\t\tslightly to work on Arrays instead of using a Matrix object.\n\t\t\tIt is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py\n\t\t\t*/\n\n\t\t\tnumeric.svd = function svd(A) {\n\t\t\t\tvar temp;\n\t\t\t\t//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)\n\t\t\t\tvar prec = numeric.epsilon; //Math.pow(2,-52) // assumes double prec\n\t\t\t\tvar tolerance = 1.e-64 / prec;\n\t\t\t\tvar itmax = 50;\n\t\t\t\tvar c = 0;\n\t\t\t\tvar i = 0;\n\t\t\t\tvar j = 0;\n\t\t\t\tvar k = 0;\n\t\t\t\tvar l = 0;\n\n\t\t\t\tvar u = numeric.clone(A);\n\t\t\t\tvar m = u.length;\n\n\t\t\t\tvar n = u[0].length;\n\n\t\t\t\tif (m < n) throw \"Need more rows than columns\";\n\n\t\t\t\tvar e = new Array(n);\n\t\t\t\tvar q = new Array(n);\n\t\t\t\tfor (i = 0; i < n; i++) e[i] = q[i] = 0.0;\n\t\t\t\tvar v = numeric.rep([n, n], 0);\n\t\t\t\t//\tv.zero();\n\n\t\t\t\tfunction pythag(a, b) {\n\t\t\t\t\ta = Math.abs(a);\n\t\t\t\t\tb = Math.abs(b);\n\t\t\t\t\tif (a > b)\n\t\t\t\t\t\treturn a * Math.sqrt(1.0 + (b * b / a / a));\n\t\t\t\t\telse if (b == 0.0)\n\t\t\t\t\t\treturn a;\n\t\t\t\t\treturn b * Math.sqrt(1.0 + (a * a / b / b));\n\t\t\t\t}\n\n\t\t\t\t//Householder's reduction to bidiagonal form\n\n\t\t\t\tvar f = 0.0;\n\t\t\t\tvar g = 0.0;\n\t\t\t\tvar h = 0.0;\n\t\t\t\tvar x = 0.0;\n\t\t\t\tvar y = 0.0;\n\t\t\t\tvar z = 0.0;\n\t\t\t\tvar s = 0.0;\n\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\te[i] = g;\n\t\t\t\t\ts = 0.0;\n\t\t\t\t\tl = i + 1;\n\t\t\t\t\tfor (j = i; j < m; j++)\n\t\t\t\t\t\ts += (u[j][i] * u[j][i]);\n\t\t\t\t\tif (s <= tolerance)\n\t\t\t\t\t\tg = 0.0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tf = u[i][i];\n\t\t\t\t\t\tg = Math.sqrt(s);\n\t\t\t\t\t\tif (f >= 0.0) g = -g;\n\t\t\t\t\t\th = f * g - s;\n\t\t\t\t\t\tu[i][i] = f - g;\n\t\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = i; k < m; k++)\n\t\t\t\t\t\t\t\ts += u[k][i] * u[k][j];\n\t\t\t\t\t\t\tf = s / h;\n\t\t\t\t\t\t\tfor (k = i; k < m; k++)\n\t\t\t\t\t\t\t\tu[k][j] += f * u[k][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq[i] = g;\n\t\t\t\t\ts = 0.0;\n\t\t\t\t\tfor (j = l; j < n; j++)\n\t\t\t\t\t\ts = s + u[i][j] * u[i][j];\n\t\t\t\t\tif (s <= tolerance)\n\t\t\t\t\t\tg = 0.0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tf = u[i][i + 1];\n\t\t\t\t\t\tg = Math.sqrt(s);\n\t\t\t\t\t\tif (f >= 0.0) g = -g;\n\t\t\t\t\t\th = f * g - s;\n\t\t\t\t\t\tu[i][i + 1] = f - g;\n\t\t\t\t\t\tfor (j = l; j < n; j++) e[j] = u[i][j] / h;\n\t\t\t\t\t\tfor (j = l; j < m; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\ts += (u[j][k] * u[i][k]);\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\tu[j][k] += s * e[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ty = Math.abs(q[i]) + Math.abs(e[i]);\n\t\t\t\t\tif (y > x)\n\t\t\t\t\t\tx = y;\n\t\t\t\t}\n\n\t\t\t\t// accumulation of right hand gtransformations\n\t\t\t\tfor (i = n - 1; i != -1; i += -1) {\n\t\t\t\t\tif (g != 0.0) {\n\t\t\t\t\t\th = g * u[i][i + 1];\n\t\t\t\t\t\tfor (j = l; j < n; j++)\n\t\t\t\t\t\t\tv[j][i] = u[i][j] / h;\n\t\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\ts += u[i][k] * v[k][j];\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\tv[k][j] += (s * v[k][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\tv[i][j] = 0;\n\t\t\t\t\t\tv[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tv[i][i] = 1;\n\t\t\t\t\tg = e[i];\n\t\t\t\t\tl = i;\n\t\t\t\t}\n\n\t\t\t\t// accumulation of left hand transformations\n\t\t\t\tfor (i = n - 1; i != -1; i += -1) {\n\t\t\t\t\tl = i + 1;\n\t\t\t\t\tg = q[i];\n\t\t\t\t\tfor (j = l; j < n; j++)\n\t\t\t\t\t\tu[i][j] = 0;\n\t\t\t\t\tif (g != 0.0) {\n\t\t\t\t\t\th = u[i][i] * g;\n\t\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = l; k < m; k++) s += u[k][i] * u[k][j];\n\t\t\t\t\t\t\tf = s / h;\n\t\t\t\t\t\t\tfor (k = i; k < m; k++) u[k][j] += f * u[k][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = i; j < m; j++) u[j][i] = u[j][i] / g;\n\t\t\t\t\t} else\n\t\t\t\t\t\tfor (j = i; j < m; j++) u[j][i] = 0;\n\t\t\t\t\tu[i][i] += 1;\n\t\t\t\t}\n\n\t\t\t\t// diagonalization of the bidiagonal form\n\t\t\t\tprec = prec * x;\n\t\t\t\tfor (k = n - 1; k != -1; k += -1) {\n\t\t\t\t\tfor (var iteration = 0; iteration < itmax; iteration++) { // test f splitting\n\t\t\t\t\t\tvar test_convergence = false;\n\t\t\t\t\t\tfor (l = k; l != -1; l += -1) {\n\t\t\t\t\t\t\tif (Math.abs(e[l]) <= prec) {\n\t\t\t\t\t\t\t\ttest_convergence = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (Math.abs(q[l - 1]) <= prec)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!test_convergence) { // cancellation of e[l] if l>0\n\t\t\t\t\t\t\tc = 0.0;\n\t\t\t\t\t\t\ts = 1.0;\n\t\t\t\t\t\t\tvar l1 = l - 1;\n\t\t\t\t\t\t\tfor (i = l; i < k + 1; i++) {\n\t\t\t\t\t\t\t\tf = s * e[i];\n\t\t\t\t\t\t\t\te[i] = c * e[i];\n\t\t\t\t\t\t\t\tif (Math.abs(f) <= prec)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tg = q[i];\n\t\t\t\t\t\t\t\th = pythag(f, g);\n\t\t\t\t\t\t\t\tq[i] = h;\n\t\t\t\t\t\t\t\tc = g / h;\n\t\t\t\t\t\t\t\ts = -f / h;\n\t\t\t\t\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\t\t\t\t\ty = u[j][l1];\n\t\t\t\t\t\t\t\t\tz = u[j][i];\n\t\t\t\t\t\t\t\t\tu[j][l1] = y * c + (z * s);\n\t\t\t\t\t\t\t\t\tu[j][i] = -y * s + (z * c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// test f convergence\n\t\t\t\t\t\tz = q[k];\n\t\t\t\t\t\tif (l == k) { //convergence\n\t\t\t\t\t\t\tif (z < 0.0) { //q[k] is made non-negative\n\t\t\t\t\t\t\t\tq[k] = -z;\n\t\t\t\t\t\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\t\t\t\t\t\tv[j][k] = -v[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak; //break out of iteration loop and move on to next k value\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (iteration >= itmax - 1)\n\t\t\t\t\t\t\tthrow 'Error: no convergence.';\n\t\t\t\t\t\t// shift from bottom 2x2 minor\n\t\t\t\t\t\tx = q[l];\n\t\t\t\t\t\ty = q[k - 1];\n\t\t\t\t\t\tg = e[k - 1];\n\t\t\t\t\t\th = e[k];\n\t\t\t\t\t\tf = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n\t\t\t\t\t\tg = pythag(f, 1.0);\n\t\t\t\t\t\tif (f < 0.0)\n\t\t\t\t\t\t\tf = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tf = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\n\t\t\t\t\t\t// next QR transformation\n\t\t\t\t\t\tc = 1.0;\n\t\t\t\t\t\ts = 1.0;\n\t\t\t\t\t\tfor (i = l + 1; i < k + 1; i++) {\n\t\t\t\t\t\t\tg = e[i];\n\t\t\t\t\t\t\ty = q[i];\n\t\t\t\t\t\t\th = s * g;\n\t\t\t\t\t\t\tg = c * g;\n\t\t\t\t\t\t\tz = pythag(f, h);\n\t\t\t\t\t\t\te[i - 1] = z;\n\t\t\t\t\t\t\tc = f / z;\n\t\t\t\t\t\t\ts = h / z;\n\t\t\t\t\t\t\tf = x * c + g * s;\n\t\t\t\t\t\t\tg = -x * s + g * c;\n\t\t\t\t\t\t\th = y * s;\n\t\t\t\t\t\t\ty = y * c;\n\t\t\t\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tx = v[j][i - 1];\n\t\t\t\t\t\t\t\tz = v[j][i];\n\t\t\t\t\t\t\t\tv[j][i - 1] = x * c + z * s;\n\t\t\t\t\t\t\t\tv[j][i] = -x * s + z * c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tz = pythag(f, h);\n\t\t\t\t\t\t\tq[i - 1] = z;\n\t\t\t\t\t\t\tc = f / z;\n\t\t\t\t\t\t\ts = h / z;\n\t\t\t\t\t\t\tf = c * g + s * y;\n\t\t\t\t\t\t\tx = -s * g + c * y;\n\t\t\t\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\t\t\t\ty = u[j][i - 1];\n\t\t\t\t\t\t\t\tz = u[j][i];\n\t\t\t\t\t\t\t\tu[j][i - 1] = y * c + z * s;\n\t\t\t\t\t\t\t\tu[j][i] = -y * s + z * c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\te[l] = 0.0;\n\t\t\t\t\t\te[k] = f;\n\t\t\t\t\t\tq[k] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//vt= transpose(v)\n\t\t\t\t//return (u,q,vt)\n\t\t\t\tfor (i = 0; i < q.length; i++)\n\t\t\t\t\tif (q[i] < prec) q[i] = 0;\n\n\t\t\t\t//sort eigenvalues\t\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\t//writeln(q)\n\t\t\t\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (q[j] < q[i]) {\n\t\t\t\t\t\t\t//  writeln(i,'-',j)\n\t\t\t\t\t\t\tc = q[j];\n\t\t\t\t\t\t\tq[j] = q[i];\n\t\t\t\t\t\t\tq[i] = c;\n\t\t\t\t\t\t\tfor (k = 0; k < u.length; k++) {\n\t\t\t\t\t\t\t\ttemp = u[k][i];\n\t\t\t\t\t\t\t\tu[k][i] = u[k][j];\n\t\t\t\t\t\t\t\tu[k][j] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (k = 0; k < v.length; k++) {\n\t\t\t\t\t\t\t\ttemp = v[k][i];\n\t\t\t\t\t\t\t\tv[k][i] = v[k][j];\n\t\t\t\t\t\t\t\tv[k][j] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\t   u.swapCols(i,j)\n\t\t\t\t\t\t\t//\t   v.swapCols(i,j)\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tU: u,\n\t\t\t\t\tS: q,\n\t\t\t\t\tV: v\n\t\t\t\t};\n\t\t\t};\n\t\t}","name":"Collage Script","documentation":"Use method:\n```\nrunCollage()\n```\n\n\nCollage.jsx\nCopyright (c) 2012 Motion Boutique\n\nPhotobook layout with selected layers","tags":["Compositions","Collage"],"snippet_prefix":"collage","is_snippet":false,"include_id":"collage","is_include":true,"last_update":1608623677156},{"_id":"Color-Management--Apple-Issue-1613922910572","code":"require(\"composition\");\nvar currentSpace = app.project.workingSpace;\nvar currentGamma = app.project.workingGamma;\nvar colorProfileConverterEffect = \"ADBE ProfileToProfile\";\nvar changeSpace = \"\";\nvar originalSpace = \"HDTV (Rec. 709)\";\nvar changeGamma = 2.4;\nvar originalGamma = 2.2;\nvar outputProfileValue = 93;\nvar revert = _ bool: Fix color space on selected layer? (Uncheck this to revert color space to original) _;\n\nif(revert && app.project.activeItem.selectedLayers.length > 0){\n  startColorSpace()\n} else if(!revert){\n  revertColorSpace()\n}\n\nfunction startColorSpace(){\n  app.beginUndoGroup(\"Change Color Space\");\n  if(currentSpace !== changeSpace){\n    app.project.workingSpace = changeSpace;\n  }\n  \n  if(app.project.linearizeWorkingSpace){\n    app.project.linearizeWorkingSpace = false;\n  }\n  \n  if(currentGamma !== changeGamma){\n    app.project.workingGamma = changeGamma;\n  }\n  \n  for(var layer = 0; layer < app.project.activeItem.selectedLayers.length; layer++){\n    var selectedLayer = app.project.activeItem.selectedLayers[layer];\n    // loop on all possible effects and break\n    if(!selectedLayer.property(\"Effects\").property(colorProfileConverterEffect) && selectedLayer.property(\"Effects\").canAddProperty(colorProfileConverterEffect)){\n      selectedLayer.property(\"Effects\").addProperty(colorProfileConverterEffect)\n      selectedLayer.property(\"Effects\").property(colorProfileConverterEffect).property(\"Output Profile\").setValue(outputProfileValue);\n    }\n  }\n  \n  app.endUndoGroup()\n}\n\nfunction revertColorSpace(){\n  app.beginUndoGroup(\"Revert Color Space\");\n  if(currentSpace !== originalSpace){\n    app.project.workingSpace = originalSpace;\n  }\n  \n  if(!app.project.linearizeWorkingSpace){\n    app.project.linearizeWorkingSpace = true;\n  }\n  \n  if(currentGamma !== originalGamma){\n    app.project.workingGamma = originalGamma;\n  }\n  app.endUndoGroup()\n}","name":"Color Management (Apple Issue)","documentation":"Some compositions does not export color management correctly when rendering to AME (Adobe Media Encoder).\n\nSo for a solution that we have right now, is to change color space on Project Settings to None & make Gamma to 2.4. Then apply \"Color Profile Converter\" on the Composition that is affected. It is done! Simple as that!\n\nBy using this helper, you could revert your settings back to normal or apply the color management to selected compositions. That's it!","last_update":1613966255567},{"_id":"Composition-Helper-1608555333201","code":"function findComp(compName){\n  var myComp;\n  for (var i = 1; i <= app.project.numItems; i++) {\n    if ((app.project.item(i) instanceof CompItem) && (app.project.item(i).name === compName)) {\n        if(myComp){\n          alert(\"ERROR: Duplicate Composition Found!\\nPlease change your composition name into something unique for \" + myComp.name + \" so that it will be able to find uniquely.\");\n          myComp = undefined;\n          break;\n        }\n        myComp = app.project.item(i);\n      }\n  }\n  \n  return myComp;\n}\n\nfunction addFolder(name){\n  return app.project.items.addFolder(name);\n}\n\nfunction addCompFromFolder(folder,name,width,height,pixelAspect,duration,frameRate){\n  return folder.items.addComp(name, width, height, pixelAspect, duration, frameRate);\n}\n\nfunction addCompFromActiveComp(name, width, height, pixelAspect, duration, frameRate){\n  var currentComp, newComp;\n  currentComp = findComp(app.project.activeItem.name);\n  newComp = app.project.items.addComp(name, width, height, pixelAspect, duration, frameRate);\n  return currentComp.layers.add(newComp);\n}\n\nfunction addCompFromSelectedComp(comp, name, width, height, pixelAspect, duration, frameRate){\n  var newComp = app.project.items.addComp(name, width, height, pixelAspect, duration, frameRate);\n  return comp.layers.add(newComp);\n}\n\nfunction addSolid(comp, name, width, height, pixelAspect, duration) {\n\tvar solid = comp.layers.addSolid([1, 1, 1], name, width, height, pixelAspect, duration);\n\treturn solid;\n}\n\nfunction addNullLayer(comp, layerName) {\n\tvar NULL_LAYER = comp.layers.addNull();\n\tNULL_LAYER.name = layerName;\n\treturn NULL_LAYER;\n}","name":"Composition Helper","documentation":"### Compositions Helper\n\n`findComp(compName)` - Returns Composition\n\n`addFolder(name)` - Returns Folder Object\n\n`addCompFromFolder(folder, name, width, height, pixelAspect, duration, frameRate)` - Returns New Composition\n\n`addCompFromActiveComp(name, width, height, pixelAspect, duration, frameRate)` - Returns New Composition\n\n`addCompFromSelectedComp(comp, name, width, height, pixelAspect, duration, frameRate)` - Returns Passed Composition\n\n`addSolid(comp, name, width, height, pixelAspect, duration)` - Returns Solid Layer\n\n`addNullLayer(comp, layerName)` - Returns Null Layer","snippet_prefix":"","is_snippet":false,"include_id":"composition","is_include":true,"last_update":1611483506982},{"_id":"Composition-Ratio-Calculator-1608553692810","code":"function calculateRatio(num_1, num_2){\n    for(num=num_2; num>1; num--) {\n        if((num_1 % num) == 0 && (num_2 % num) == 0) {\n            num_1=num_1/num;\n            num_2=num_2/num;\n        }\n    }\n    var ratio = num_1+\":\"+num_2;\n    return ratio;\n}\n\nfunction getRectangleWidthHeight(aspectRatio, area){\n  if(typeof aspectRatio === \"string\"){\n    aspectRatio = aspectRatio.split(\":\");\n  }\n  \n  var convert = (area * aspectRatio[1]) / aspectRatio[0];\n  var height = Math.round(Math.sqrt(convert));\n  var width = Math.round(area/height);\n  return [width, height];\n}","name":"Composition Ratio Calculator","documentation":"[Reference Formula](http://mathcentral.uregina.ca/QQ/database/QQ.09.15/h/colum1.html)\n\nThis is a composition ratio calculator to determine the ratio of your composition size.\n\nAttributes:\n\ncalculateRatio(`num_1`, `num_2`)\n\ngetRectangleWidthHeight(`aspectRatio`, `area`)","snippet_prefix":"ratio","is_snippet":true,"include_id":"ratio_calculator","is_include":true,"last_update":1608553744703},{"_id":"Controller-Helper-1608554320479","code":"function findControllerName(name) {\n\tvar layerName = \"\";\n\tvar controller = {\n\t\tpoint3D: \"ADBE Point3D Control\",\n\t\tangle: \"ADBE Angle Control\",\n\t\tcheckbox: \"ADBE Checkbox Control\",\n\t\tcolor: \"ADBE Color Control\",\n\t\tlayer: \"ADBE Layer Control\",\n\t\tpoint: \"ADBE Point Control\",\n\t\tslider: \"ADBE Slider Control\"\n\t};\n\n\tfor (var control in controller) {\n\t\tvar sanitize = control.replace(/ADBE/g).replace(/Control/g).trim();\n\t\tvar nameReg = new RegExp(name, \"g\");\n\t\tif (sanitize.match(nameReg)) {\n\t\t\tlayerName = controller[control];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn layerName;\n}\n\nfunction addController(controlLayer, targerLayer, effect, controller) {\n\tvar AE_Controller = findControllerName(controller.controllerType);\n\t// Get Value from target layer\n\tif (effect.effectName){\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(effect.effectName).value;\n\t} else {\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(1).value;\n\t}\n\t\n\tvar slider_control = controlLayer.Effects.addProperty(AE_Controller);\n\tif (controller.controllerName && controller.controllerName.length > 0) {\n\t\tslider_control.name = controller.controllerName;\n\t}\n\t\n\t// Apply value on slider controller\n\tslider_control.property(1).setValue(getValue);\n\t\n\t// Set expression on targetLayer\n\tif (effect.effectName) {\n\t\ttargerLayer.Effects.property(effect.effectType)(effect.effectName).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t} else {\n\t\ttargerLayer.Effects.property(effect.effectType)(1).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t}\n}","name":"Controller Helper","documentation":"## Find Controller Name\n`findControllerName(**Controller Name : string**)` -> Returns Controller Name\n\n## Add Controller Method\n> [Effect Names](https://after-effects-scripting-guide.readthedocs.io/matchnames/effects/firstparty/)\n```\naddController(controlLayer, targetLayer, {\n\teffectType: <Effect Name : string>,\n        effectName: <Rename Effect : string>\n}, {\n\tcontrollerType: <Controller Type : 'slider' , 'point3d', 'angle', 'color', 'checkbox', 'layer'>,\n\tcontrollerName: <Rename Controller : string>\n});\n```\n-> Returns Controller","snippet_prefix":"controllerHelper","is_snippet":true,"include_id":"controller","is_include":true,"last_update":1608558584650},{"_id":"Insert-Multiple-Videos-to-Compositions-1610870162057","code":"require(\"composition\");\nvar project = app.project;\nvar projectSelection = project.selection ? project.selection : [];\nvar selectedComps = project.activeItem ? project.activeItem.selectedLayers : [];\nvar projectVideoErrTxt = \"You must select any videos in your Project Panel\";\nvar selectedCompsErrTxt = \"You must select any compositions in your current comp\";\nvar random = _ bool: Random Selection to Selected Compositions? _;\nvar quickRun = _ bool: Run from Visual Mode? _;\n\nfunction insertVidsToComps(error){\n  if(error){\n      try{\n        // Did not select any layers compositions in Comp\n        if(selectedComps.length == 0 && projectSelection.length > 0){\n          throw Error(selectedCompsErrTxt + \" to get started.\");\n        }\n        \n        // Did not select any videos in Project Panel\n        if(projectSelection.length == 0 && selectedComps.length > 0) {\n            throw Error(projectVideoErrTxt + \" to get started.\");\n        }\n        \n        // Did not select both videos in Project Panel & Compositions in current Composition\n        if(projectSelection.length == 0 && selectedComps.length == 0){\n          throw Error(projectVideoErrTxt + \" & \" + selectedCompsErrTxt + \" to get started.\");\n        }\n        \n        start();\n    }catch(e){\n      alert(e);\n    }\n  }else {\n    start();\n  }\n}\n\nfunction start(random){\n  app.beginUndoGroup(\"insertVidsToComps\");\n  var projectSelectionRand = [];\n  var projectSelectionNorm = 0;\n  for(var comps = 0; comps < selectedComps.length; comps++){\n    var theComp = findComp(selectedComps[comps].name);\n    if(random){\n      var total = projectSelection.length;\n      while(true){\n          if(projectSelectionRand.length === total && comps === selectedComps.length){\n              break;\n          }\n          var generator = Math.round(Math.random() * total);\n          if(projectSelectionRand.indexOf(generator) > -1){\n              continue;\n          }\n          \n          // Begins Code\n          if(projectSelection[generator]){\n            theComp.layers.add(projectSelection[generator]); \n            projectSelectionRand.push(generator);\n            break; \n          }else{\n            projectSelectionRand = []\n            continue;\n          }\n      }\n    }else if(!random) {\n      if(projectSelection[projectSelectionNorm]){\n        theComp.layers.add(projectSelection[projectSelectionNorm]);\n        projectSelectionNorm++ \n      }else{\n        projectSelectionNorm = 0;\n        theComp.layers.add(projectSelection[projectSelectionNorm]);\n      }\n    }\n  }\n  \n  app.endUndoGroup();\n}\n\nif(quickRun){\n  start(random); \n}","name":"Insert Multiple Videos into Compositions","documentation":"This is to fasten your workflow by selecting multiple compositions AND multiple videos in Project Panel to insert all videos into selected compositions.\n## Attributes:\n`random` -> True/False\n\n## Function:\n`start(random)` - Returns nothing","tags":["Compositions","Multiple","Videos"],"include_id":"multiple_videos_into_comp","is_include":true,"last_update":1611479324957},{"_id":"Remove-All-Layers-inside-Composition-1611550153222","code":"require(\"composition\");\nvar run = _ bool: Running from visual mode? _;\nvar totalComps = 0;\nvar totalLayers = 0;\nvar totalCompString = \"\\nTotal Comp that has been running: \\n\";\nvar totalLayersString = \"\\nTotal Layers that has been deleted: \\n\";\napp.beginUndoGroup(\"Remove All Layers inside Comp\");\ntry{\n  if(run){\n    if(app.project.selection.length > 0){\n      removeAllProjectSelection(); \n    }\n    if(app.project.activeItem.selectedLayers.length > 0){\n      removeAllLayerSelection();  \n    }\n    \n    if(totalLayers > 0 || totalComp > 0){\n      alert(\"Report!\" + totalCompString + totalComps + \" compositions.\" + totalLayersString + totalLayers + \" layers.\" );\n    }\n  } \n}catch(e){\n  alert(e)\n}\napp.endUndoGroup();\n\nfunction removeAllProjectSelection(customProjectSelection){\n  var projectSelection = customProjectSelection ? customProjectSelection : app.project.selection;\n  for(var project = 0; project < projectSelection.length; project++){\n    var myComp = findComp(projectSelection[project].name)\n    for(var projectLayers = myComp.numLayers; projectLayers >= 1; projectLayers--){\n      try{\n        myComp.layers[projectLayers].remove();\n        totalLayers++; \n      }catch(e){\n        throw Error(\"Unable to remove layer: \" + myComp.layers[projectLayers].name);\n      }\n    }\n    totalComps++;\n  }\n}\n\nfunction removeAllLayerSelection(customSelectedLayers){\n  var layerSelection = customSelectedLayers ? customSelectedLayers : app.project.activeItem.selectedLayers;\n  for(var layer = 0; layer < layerSelection.length; layer++){\n    var myComp = findComp(layerSelection[layer].name);\n    for(var compLayers = myComp.numLayers; compLayers >= 1; compLayers--){\n      try{\n        myComp.layers[compLayers].remove();\n        totalLayers++;\n      }catch(e){\n        throw Error(\"Unable to remove layer: \" + myComp.layers[compLayers].name);\n      }\n    }\n    totalComps++;\n  }\n}","name":"Remove All Layers inside Composition","documentation":"This is to remove all layers inside comp:\n# Method:\n`removeAllProjectSelection(customProjectSelection)` -> Remove Project Selection\n`removeAllLayerSelection(customSelectedLayers)` -> Remove Layer Selection\n\n## Attributes:\n`customProjectSelection` -> Array of `app.project.selection`. You can pass your own array of selected projects as attribute.\n`customSelectedLayers` -> Array of `app.project.activeItem.selectedLayers`. You can pass your own array of selected layers as attribute.","tags":["Compositions","Layer","Multiple"],"include_id":"remove_all_layers","is_include":true,"last_update":1611565039477}]},{"_id":"Default-1588045113736","name":"My Code","type":"script","expressions":[{"_id":"AI-to-AE-1595922381748","code":"var docRef=activeDocument;\r\nalert(Object.stringify(docRef));\r\nvar layerCount=docRef.layers.length;\r\nvar currentComp = app.project.activeItem;\r\nalert(\"Current Comp\" + currentComp);\r\nfor(i=layerCount-1;i>=0;i--)\r\n{\r\n\tvar currLayer=docRef.layers[i]; \r\n\tif(currLayer.layers.length>0){\r\n\r\n\t\tfor(j=currLayer.layers.length-1;j>=0;j--){\r\n  \t  currLayer.layers[j].move(currLayer,ElementPlacement.PLACEAFTER);\r\n  \t}\r\n  \ttry{\r\n  \t  currentComp.layers.add(currLayer); \r\n  \t}catch(e){\r\n  \t  alert(e);\r\n  \t}\r\n  }\r\n}\r\n","name":"AI to AE","documentation":"This is for transform complicated AI vector files to AE instantly. Like Overload AXE plugin.","tags":["Import","Adobe Illustrator"],"last_update":1595924733620},{"_id":"Divide-Compositions-1590999177068","code":"var comp = app.project.selection;\nvar MUTEAUDIO = _ bool: Mute Audio ? _;\nvar compSec = _ number *: Number of seconds on each Divide Compositions _;\nvar fastForward = _ bool: Enable fast forward ? _;\nvar fastForwardDifference = _ number: Time in seconds to fast forward _;\nvar rotateValue = _ number: Rotate Compositions ? (HINTS: 90, 180, 270) _;\nvar timeRemappingPropertyName = \"ADBE Time Remapping\";\n\nvar ROTATION = {\n\tVERTICAL: 90,\n\tHORIZONTAL: 180,\n\tINVERTVERTICAL: 270\n}\n\nif (comp.length === 0) {\n\talert(\"You didn't select any compositions in Project Panel. Please select atleast one\");\n} else {\n\tapp.beginUndoGroup(\"Divide Compositions\");\n\tmain();\n\tapp.endUndoGroup();\n}\n\nfunction rotation(comp, layer, rotation) {\n\tvar width = comp.width;\n\tvar height = comp.height;\n\tvar posX = layer.Transform.property(\"Position\").value[0];\n\tvar posY = layer.Transform.property(\"Position\").value[1];\n\tif (ROTATION.VERTICAL == rotation) {\n\t\tcomp.width = height;\n\t\tcomp.height = width;\n\t\tlayer.Transform.property(\"Rotation\").setValue(rotation);\n\t\tlayer.Transform.property(\"Position\").setValue([posY, posX]);\n\t\treturn;\n\t} else if (ROTATION.INVERTVERTICAL == rotation) {\n\t\tcomp.width = height;\n\t\tcomp.height = width;\n\t\tlayer.Transform.property(\"Rotation\").setValue(rotation);\n\t\tlayer.Transform.property(\"Position\").setValue([posY, posX]);\n\t\treturn;\n\t} else if (ROTATION.HORIZONTAL == rotation) {\n\t\tlayer.Transform.property(\"Rotation\").setValue(rotation);\n\t\treturn;\n\t} else {\n\t\twrite(\"ERROR ROTATE: \" + comp.name);\n\t}\n}\n\nfunction rotateName(compName, rotation) {\n\tif (ROTATION.VERTICAL == rotation) {\n\t\treturn compName + \" - ROTATE \" + rotation + \"\";\n\t} else if (ROTATION.INVERTVERTICAL == rotation) {\n\t\treturn compName + \" - ROTATE \" + rotation + \"\";\n\t} else if (ROTATION.HORIZONTAL == rotation) {\n\t\treturn compName + \" - ROTATE \" + rotation + \"\";\n\t} else {\n\t\treturn compName;\n\t}\n}\n\nfunction main() {\n\tfor (var i = 0; i < comp.length; i++) {\n\t\tvar compName = comp[i].name.replace(/\\.[^\\/\\.]+$/, \"\");\n\t\tif (rotateValue) {\n\t\t\tcompName = rotateName(compName, rotateValue);\n\t\t}\n\t\tvar folder = app.project.items.addFolder(compName);\n\t\tvar remaining = calculateDivide(fastForward, compSec, fastForwardDifference);\n\t\tvar compTimeDivide = comp[i].duration / remaining;\n\t\tvar startTime = 0;\n\t\tvar lastTime = comp[i].duration;\n\t\tfor (var numComp = 0; numComp < compTimeDivide; numComp++) {\n\t\t\t// If it reaches limit, reset fastForwardStart & fastForwardEnd value\n\t\t\tif (lastTime < 0) {\n\t\t\t\tfastForwardStart = undefined;\n\t\t\t\tfastForwardEnd = undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Adding new comp in a folder\n\t\t\tvar newComp = folder.items.addComp(compName + \"-\" + numComp, comp[i].width, comp[i].height, comp[i].pixelAspect, compSec, comp[i].frameRate);\n\t\t\tnewComp.layers.add(comp[i]);\n\t\t\tvar layer = newComp.layer(comp[i].name);\n\t\t\tlayer.startTime -= startTime;\n\n\t\t\tif (rotateValue) {\n\t\t\t\trotation(newComp, layer, rotateValue);\n\t\t\t}\n\n\t\t\t// If user wants to mute audio\n\t\t\tif (MUTEAUDIO) {\n\t\t\t\tlayer.audioEnabled = false;\n\t\t\t}\n\n\t\t\t// If fast forward enabled\n\t\t\tif (fastForward && layer.canSetTimeRemapEnabled) {\n\t\t\t\tvar fastForwardStart = fastForwardEnd ? fastForwardEnd : startTime;\n\n\t\t\t\t// Calculate at the end of fastForwardEnd value\n\t\t\t\tif (numComp > 1 && fastForwardEnd) {\n\t\t\t\t\tfastForwardEnd = fastForwardEnd + fastForwardDifference;\n\t\t\t\t} else {\n\t\t\t\t\tvar fastForwardEnd = startTime + compSec + fastForwardDifference;\n\t\t\t\t}\n\n\t\t\t\t// If it reaches the maximum of compositions duration\n\t\t\t\tif (fastForwardEnd > comp[i].duration) {\n\t\t\t\t\tfastForwardEnd = comp[i].duration;\n\t\t\t\t}\n\n\n\t\t\t\t// Time remapping starts\n\t\t\t\tlayer.timeRemapEnabled = true;\n\t\t\t\tvar newFirstKeyIndex = layer.property(timeRemappingPropertyName).addKey(newComp.displayStartTime);\n\t\t\t\tvar newLastKeyIndex = layer.property(timeRemappingPropertyName).addKey(newComp.displayStartTime + newComp.duration);\n\t\t\t\tlayer.property(timeRemappingPropertyName).setValueAtKey(newFirstKeyIndex, fastForwardStart);\n\t\t\t\tlayer.property(timeRemappingPropertyName).setValueAtKey(newLastKeyIndex, fastForwardEnd);\n\n\t\t\t\t// Will decrease it lastTime to exit the loop\n\t\t\t\tlastTime -= fastForwardDifference;\n\t\t\t}\n\n\t\t\t// Will increase startTime to continue doing adding newComp at the number of seconds input\n\t\t\tstartTime += compSec;\n\t\t}\n\t}\n}\n\n\n// Function to calculate remaining of time based on number of compositions set.\nfunction calculateDivide(enable, compSec, difference) {\n\tif (enable) {\n\t\tvar remaining = compSec - difference;\n\t\tif (remaining > 0) {\n\t\t\treturn remaining\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\treturn compSec;\n\t}\n}","name":"Divide Compositions","documentation":"Ever wonder to divide your lengthy compositions into a specific number of seconds? Try to figuring out how to post on Instagram Story or whatsoever? Try this script!\n\nP/s : You can also fast forward video in number of seconds. Try it out!","tags":["Compositions","Duration","Divide"],"last_update":1608636253288},{"_id":"Motion-Trail-1588228261142","code":"app.beginUndoGroup(\"Undo Motion Trail\");\n\nvar targetLayer = _ layer: Target Layer _;\nvar renameLayer = _ string: Rename Layer _;\nvar labelColor = _ number: Label Color(Option: 1 - 16) _;\nvar numOfFramesDelay = _ number: Number of Frames Delay _;\nvar opacityFactor = _ number: Opacity Factor(Try 0.75) _;\nvar numOfRepeatLayer = _ number: Number of Repeat Layer(Optional) _;\n\nclearOutput();\n\nif (targetLayer) {\n\tvar layer = app.project.activeItem.layer(targetLayer.name);\n\tvar nullLayer = app.project.activeItem.layers.addNull();\n\tnullLayer.name = renameLayer.length > 0 ? renameLayer + \" Controller\" : layer.name + \" Controller\";\n\tlayer.label = labelColor;\n\tnullLayer.label = labelColor;\n\n\tif (renameLayer.length > 0) {\n\t\tlayer.name = renameLayer;\n\t}\n\n\t// Add slider control\n\tvar sliderFrame = nullLayer.Effects.addProperty(\"ADBE Slider Control\");\n\tsliderFrame.name = \"Number of Frames Delay\";\n\tsliderFrame.property(\"Slider\").setValue(numOfFramesDelay);\n\t//Apply to position\n\tvar posExpression = \"var delay = thisComp.layer(\\\"\" + nullLayer.name + \"\\\").effect(\\\"\" + sliderFrame.name + \"\\\")(1); //number of frames to delay \\nvar d = delay*thisComp.frameDuration*(index - 1); \\nthisComp.layer(1).position.valueAtTime(time - d);\";\n\n\tvar sliderOpac = nullLayer.Effects.addProperty(\"ADBE Slider Control\");\n\tsliderOpac.name = \"Opacity Factor\";\n\tsliderOpac.property(\"Slider\").setValue(opacityFactor);\n\t//Apply to Opacity\n\tvar opacExpression = \"var opacityFactor = thisComp.layer(\\\"\" + nullLayer.name + \"\\\").effect(\\\"\" + sliderOpac.name + \"\\\")(1); \\nMath.pow(opacityFactor,index - 1)*100;\";\n\n\ttry {\n\t\t// Add expression\n\t\tlayer.property(\"Transform\").property(\"Position\").expression = posExpression;\n\t\tlayer.property(\"Transform\").property(\"Opacity\").expression = opacExpression;\n\t} catch (e) {\n\t\talert(e);\n\t}\n\n\t// Parent all layer to null layer so that it can animate position property and all\n\t// \tapp.project.activeItem.layer(layer.name).parent = nullLayer;\n\n\tif (numOfRepeatLayer > 0) {\n\t\tfor (var i = 0; i < numOfRepeatLayer; i++) {\n\t\t\tvar duplicateLayer = layer.duplicate();\n\t\t}\n\t}\n}\n\nwriteLn(\"Script successful added to layer name:\\n'\" + layer.name + \"'.\")\napp.endUndoGroup();","name":"Motion Trail","documentation":"You can apply this to any layer! It will do motion trail for you when you had set keyframe on Position property.","tags":["Motion Trail","Trail"],"last_update":1591380434089},{"_id":"RAW-Beautify-1591342857540","code":"require(\"stringReplace\");\nrequire(\"controller\");\nvar selections = app.project.selection;\nvar customName = _ string: Custom Compositions Name Prefix _;\nvar postfix = _ bool: Enable custom name as postfix ? _;\nvar nobeColorRemap =  _ bool: Use Nobe Color Remap Plugin? (You must have Nobe Color Remap plugin to work, if not Hue/Saturation effect will be use) _;\nvar nullController = _ bool: Need Controller ? (NULL layer) _;\nvar DARK_MaskRadius = _ number *: Dark Mask Radius(Minimum = 1) _;\nvar DARK_MaskAmount = _ number *: Dark Mask Amount(Minimum = 50) _;\nvar LIGHT_MaskRadius = _ number *: Light Mask Radius(Minimum = 0.5) _;\nvar LIGHT_MaskAmount = _ number *: Light Mask Amount(Minimum = 50) _;\nvar BRIGHTNESS_CONTROL = _ bool: Need Brightness Control ? _;\nvar BRIGHTNESS_VALUE = _ number: Brightness Value _;\nvar CONTRAST_VALUE = _ number: Contrast Value _;\nvar SOFT_LIGHT = BlendingMode.SOFT_LIGHT;\nvar LIGHTEN = BlendingMode.LIGHTEN;\nvar unsharpMask = \"ADBE Unsharp Mask2\";\nvar hue = \"ADBE HUE SATURATION\";\nvar brightness = \"ADBE Brightness & Contrast 2\";\nvar nobeColorRemapEffect = \"Nobe Color Remap\";\nvar status = \"\";\n\nif (selections.length === 0) {\n\talert(\"You did not select any compositions in Project Panel\");\n} else {\n\tapp.beginUndoGroup(\"RAW Color Compositions\");\n\tmain();\n\tif(status.length > 0){\n\t  alert(status);\n\t}\n\tapp.endUndoGroup();\n}\n\n\nfunction addController(controlLayer, targerLayer, effect, controller) {\n\tvar AE_Controller = findControllerName(controller.controllerType);\n\t// Get Value from target layer\n\tif (effect.effectName){\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(effect.effectName).value;\n\t} else {\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(1).value;\n\t}\n\t\n\tvar slider_control = controlLayer.Effects.addProperty(AE_Controller);\n\tif (controller.controllerName && controller.controllerName.length > 0) {\n\t\tslider_control.name = controller.controllerName;\n\t}\n\t\n\t// Apply value on slider controller\n\tslider_control.property(1).setValue(getValue);\n\t\n\t// Set expression on targetLayer\n\tif (effect.effectName) {\n\t\ttargerLayer.Effects.property(effect.effectType)(effect.effectName).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t} else {\n\t\ttargerLayer.Effects.property(effect.effectType)(1).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t}\n\t\n\ttargerLayer.shy = true;\n}\n\nfunction main() {\n\tfor (var numComp = 0; numComp < selections.length; numComp++) {\n\t\tvar naming = removeExtensionName(selections[numComp].name);\n\t\tif (customName && customName.length > 0) {\n\t\t\tnaming = !postfix ? customName + \" - \" + removeExtensionName(selections[numComp].name) : removeExtensionName(selections[numComp].name) + \" - \" + customName;\n\t\t}\n\t\tvar newComp = app.project.items.addComp(naming, selections[numComp].width, selections[numComp].height, selections[numComp].pixelAspect, selections[numComp].duration, selections[numComp].frameRate);\n\t\tnewComp.layers.add(selections[numComp]);\n\t\tvar layer = newComp.layer(selections[numComp].name);\n\t\tvar secondLayer = layer.duplicate();\n\t\tsecondLayer.blendingMode = SOFT_LIGHT;\n\n\t\tif (nullController) {\n\t\t\tvar NULL_LAYER = addNullLayer(newComp, \"CONTROLLER\");\n\t\t}\n\n\t\ttry {\n\t\t\tvar DARK = addAdjustmentLayer(newComp, selections[numComp], \"DARK\");\n\t\t\tvar DARK_MASK1 = DARK.Effects.addProperty(unsharpMask);\n\t\t\tDARK_MASK1.property(\"radius\").setValue(DARK_MaskRadius);\n\t\t\tDARK_MASK1.property(\"amount\").setValue(DARK_MaskAmount);\n\n\t\t\tvar LIGHT = addAdjustmentLayer(newComp, selections[numComp], \"LIGHT\");\n\t\t\tLIGHT.blendingMode = LIGHTEN;\n\n\t\t\t// Start with mask 2 first because my format is always like that\n\t\t\tvar LIGHT_MASK2 = LIGHT.Effects.addProperty(unsharpMask);\n\t\t\tLIGHT_MASK2.property(\"radius\").setValue(LIGHT_MaskRadius * 2);\n\t\t\tLIGHT_MASK2.property(\"amount\").setValue(LIGHT_MaskAmount * 2);\n\n\t\t\tvar LIGHT_MASK1 = LIGHT.Effects.addProperty(unsharpMask);\n\t\t\tLIGHT_MASK1.property(\"radius\").setValue(LIGHT_MaskRadius);\n\t\t\tLIGHT_MASK1.property(\"amount\").setValue(LIGHT_MaskAmount);\n\n\t\t\tvar HUE = addAdjustmentLayer(newComp, selections[numComp], \"HUE\");\n\t\t\t\n\t\t\t// Apply Color Effect to adjustment layer\n\t\t\tif(nobeColorRemap){\n\t\t\t  if(HUE.Effects.canAddProperty(nobeColorRemapEffect)){\n\t\t\t    var HUE_EFFECT = HUE.Effects.addProperty(nobeColorRemapEffect);\n\t\t\t  } else {\n\t\t\t    var HUE_EFFECT = HUE.Effects.addProperty(hue);\n\t\t\t    status = nobeColorRemapEffect + \" Plugin is not available\";\n\t\t\t  }\n\t\t\t} else {\n\t\t\t  var HUE_EFFECT = HUE.Effects.addProperty(hue);\n\t\t\t}\n\n\t\t\tif (NULL_LAYER) {\n\t\t\t\t// 1\n\t\t\t\taddController(NULL_LAYER, DARK, {\n\t\t\t\t\teffectType: unsharpMask\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask (Dark)\"\n\t\t\t\t});\n\t\t\t\taddController(NULL_LAYER, DARK, {\n\t\t\t\t  effectType:\"Unsharp Mask\",\n\t\t\t\t  effectName:\"Radius\"\n\t\t\t\t}, {\n\t\t\t\t  controllerType: \"slider\",\n\t\t\t\t  controllerName: \"Unsharp Mask Radius (Dark)\"\n\t\t\t\t})\n\t\t\t\t// 2\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask\",\n\t\t\t\t\teffectName: \"Amount\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask (High Light)\"\n\t\t\t\t});\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask\",\n\t\t\t\t\teffectName: \"Radius\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask Radius (High Light)\"\n\t\t\t\t});\n\t\t\t\t// 3\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask 2\",\n\t\t\t\t\teffectName: \"Amount\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask (Low Light)\"\n\t\t\t\t});\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask 2\",\n\t\t\t\t\teffectName: \"Radius\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask Radius (Low Light)\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (BRIGHTNESS_CONTROL) {\n\t\t\t\tvar BRIGHTNESS_LAYER = addBrightnessControl(newComp, selections[numComp], \"BRIGHTNESS\");\n\t\t\t\tBRIGHTNESS_LAYER.blendingMode = LIGHTEN;\n\t\t\t\tBRIGHTNESS_LAYER.Effects.property(brightness).property(\"Brightness\").setValue(BRIGHTNESS_VALUE ? BRIGHTNESS_VALUE : 0);\n\t\t\t\tBRIGHTNESS_LAYER.Effects.property(brightness).property(\"Contrast\").setValue(CONTRAST_VALUE ? CONTRAST_VALUE : 0);\n\n\t\t\t\tif (NULL_LAYER) {\n\t\t\t\t\t// 1\n\t\t\t\t\taddController(NULL_LAYER, BRIGHTNESS_LAYER, {\n\t\t\t\t\t\teffectType: \"Brightness & Contrast\",\n\t\t\t\t\t\teffectName: \"Brightness\"\n\t\t\t\t\t}, {\n\t\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\t\tcontrollerName: \"Brightness\"\n\t\t\t\t\t})\n\t\t\t\t\t// 2\n\t\t\t\t\taddController(NULL_LAYER, BRIGHTNESS_LAYER, {\n\t\t\t\t\t\teffectType: \"Brightness & Contrast\",\n\t\t\t\t\t\teffectName: \"Contrast\"\n\t\t\t\t\t}, {\n\t\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\t\tcontrollerName: \"Contrast\"\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnewComp.hideShyLayers = true;\n\t\t} catch (e) {\n\t\t\talert(e);\n\t\t}\n\t\t\n  \tif (NULL_LAYER) {\n  \t\tNULL_LAYER.moveToBeginning()\n  \t}\n\t}\n}\n\nfunction addBrightnessControl(comp, selectionComp, layerName) {\n\tvar BRIGHTNESS_ADJUSTMENT = addAdjustmentLayer(comp, selectionComp, layerName);\n\tBRIGHTNESS_ADJUSTMENT.Effects.addProperty(brightness);\n\treturn BRIGHTNESS_ADJUSTMENT;\n}\n\nfunction addAdjustmentLayer(comp, selectionComp, layerName) {\n\tvar ADJUSTMENTLAYER = comp.layers.addSolid([1, 1, 1], layerName, selectionComp.width, selectionComp.height, selectionComp.pixelAspect, selectionComp.duration);\n\t// Enable Adjustment layer\n\tADJUSTMENTLAYER.adjustmentLayer = true;\n\treturn ADJUSTMENTLAYER;\n}\n\nfunction addNullLayer(comp, layerName) {\n\tvar NULL_LAYER = comp.layers.addNull();\n\tNULL_LAYER.name = layerName\n\treturn NULL_LAYER;\n}","name":"RAW Beautify","documentation":"My custom beautify from RAW Canon video intake.","is_snippet":false,"is_include":false,"last_update":1614505766771},{"_id":"Remove-Extension-Name-1591343769822","code":"function removeExtensionName(theString) {\n\treturn theString.replace(/\\.[^\\/\\.]+$/, \"\");\n}","name":"Remove Extension Name","documentation":"removeExtensionName(**string**)\n__Returns:__\n**string**","tags":["Remove","Extension","File Type"],"include_id":"stringReplace","is_include":true,"last_update":1591344603474},{"_id":"Rename-Composition-Layer-1611492467513","code":"var selectedLayers = app.project.activeItem.selectedLayers;\nvar makeItSourceName = _ bool: Make it source name ? _;\nvar prefixOrSuffix = _ bool: Prefix / Suffix(Checked: Prefix) _;\nvar preAndSuf = _ string: Prefix / Suffix _;\nvar rename = _ string *: Name _;\nvar serializeType = _ bool: Serialize: BEFORE / AFTER(Checked: Before) _;\nvar separator = _ string: Separator _;\nvar report = \"\";\n\n// Serialize\nif (!preAndSuf) {\n\tpreAndSuf = \"\"\n}\n\nif (!separator) {\n\tseparator = \"\"\n}\n\napp.beginUndoGroup(\"Renaming Layer\");\nstart();\napp.endUndoGroup();\n\nfunction start() {\n  var num = 1;\n\tfor (var i = 0; i < selectedLayers.length; i++) {\n\t\tvar renameSerialized = \"\"\n\t\tswitch (true) {\n\t\t\tcase serializeType === true && prefixOrSuffix === true:\n\t\t\t\trenameSerialized = separator.length > 0 ? num + separator + preAndSuf + separator + rename : num + preAndSuf + rename;\n\t\t\t\tbreak;\n\n\t\t\tcase serializeType === false && prefixOrSuffix === false:\n\t\t\t\trenameSerialized = separator.length > 0 ? rename + separator + preAndSuf + separator + num : rename + preAndSuf + num;\n\t\t\t\tbreak;\n\n\t\t\tcase serializeType === true && prefixOrSuffix === false:\n\t\t\t\trenameSerialized = separator.length > 0 ? num + separator + preAndSuf + separator + rename : num + preAndSuf + rename;\n\t\t\t\tbreak;\n\n\t\t\tcase serializeType === false && prefixOrSuffix === true:\n\t\t\t\trenameSerialized = separator.length > 0 ? rename + separator + preAndSuf + separator + num : rename + preAndSuf + num;\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttry {\n\t\t\tif (makeItSourceName) {\n\n\t\t\t\tif (selectedLayers[i] instanceof AVLayer) {\n\t\t\t\t\tselectedLayers[i].source.name = renameSerialized;\n\t\t\t\t\tif (selectedLayers[i].isNameFromSource === false) {\n\t\t\t\t\t\tselectedLayers[i].name = \"\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\"Not a valid AVLayer for: \" + selectedLayers[i].name)\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif (selectedLayers[i] instanceof AVLayer) {\n\t\t\t\t\tselectedLayers[i].name = renameSerialized;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\"Not a valid AVLayer for: \" + selectedLayers[i].name)\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (e) {\n\t\t\treport += \"\\n Error renaming Comp :\" + selectedLayers[i].name;\n\t\t}\n\t\t\n\t\t// increment starts\n\t\tnum++;\n\t}\n\tif (report.length > 0) {\n\t\talert(\"ERROR!\" + report);\n\t}\n}","name":"Rename Composition Layer","last_update":1611549611876},{"_id":"Text-Background-1588114280542","code":"app.beginUndoGroup(\"Add Background Text\");\n\nfunction truncateString(str, num) {\n  if (str.length <= num) {\n    return str\n  }\n  return str.slice(0, num) + ' ...'\n}\n\nvar curComp = app.project.activeItem;\n\n// Text Layer\nvar addTextBool = _ bool: Create Text? _;\nvar curText = _ layer: Text Layer _;\n\nif(curComp && addTextBool) {\n  curText = curComp.layers.addText(_ string: Your Text _);\n}\n\n// Padding\nvar paddingTopBottom = _ number: Padding Top & Bottom _;\nvar paddingLeftRight = _ number: Padding Left & Right _;\n\n// Color\nvar fillColor = _ color: Fill Color _;\nvar strokeColor = _ color: Stroke Color _;\n\nvar sliderControl = \"ADBE Slider Control\";\n\nvar groupName = \"Rectangle Box\";\nvar effectsName = \"Effects\";\nvar rectanglePathName = \"Rectangle Path 1\";\n\nif (curComp && curText) {\n\tvar shapeLayer = curComp.layers.addShape();\n\tshapeLayer.name = \"Text Box\";\n\tvar shapeGroup = shapeLayer.property(\"Contents\").addProperty(\"ADBE Vector Group\");\n\tshapeGroup.name = groupName;\n  shapeGroup.property(\"Contents\").addProperty(\"ADBE Vector Shape - Rect\");\n\n\tvar fill = shapeGroup.property(\"Contents\").addProperty(\"ADBE Vector Graphic - Fill\");\n\tfill.Color.setValue(fillColor);\n\tvar stroke = shapeGroup.property(\"Contents\").addProperty(\"ADBE Vector Graphic - Stroke\");\n\tstroke.Color.setValue(strokeColor);\n\t\n\t// Slider Control\n\tvar controllerTotalPad = shapeLayer.Effects.addProperty(sliderControl);\n  controllerTotalPad.name = \"Total Padding\";\n  shapeLayer.property(effectsName).property(controllerTotalPad.name)(1).expression = \"effect(\\\"Padding Top & Bottom\\\")(1) + effect(\\\"Padding Left & Right\\\")(1)\";\n  \n  var controllerPadTopBottom = shapeLayer.Effects.addProperty(sliderControl);\n  controllerPadTopBottom.name = \"Padding Top & Bottom\";\n  controllerPadTopBottom.Slider.setValue(paddingTopBottom);\n  \n  var controllerPadLeftRight = shapeLayer.Effects.addProperty(sliderControl);\n  controllerPadLeftRight.name = \"Padding Left & Right\";\n  controllerPadLeftRight.Slider.setValue(paddingLeftRight);\n  \n  var totalPaddingHeight = \"effect(\\\"Padding Top & Bottom\\\")(1)\";\n  var totalPaddingWidth = \"effect(\\\"Padding Left & Right\\\")(1)\";\n\t\n\t\n\t// Expression Sizes & Position\n\tvar expressionSize = \"x = thisComp.layer(\\\"\" + curText.name + \"\\\").sourceRectAtTime().width\" + \n\t\";y = thisComp.layer(\\\"\" + curText.name + \"\\\").sourceRectAtTime().height;\" + \n\t\"[x + \" + totalPaddingWidth + \", y + \" + totalPaddingHeight + \"];\";\n\t\n\tvar expressionPos = \"s=thisComp.layer(\\\"\" + curText.name + \"\\\");\" +\n                      \"w=s.sourceRectAtTime().width/2;\" +\n                      \"h=s.sourceRectAtTime().height/2;\" + \n                      \"l=s.sourceRectAtTime().left;\" +\n                      \"t=s.sourceRectAtTime().top;\" +\n                      \"[w+l,h+t];\";\n\t\n\t// Set expression to shapeLayer\n\tshapeLayer.content(groupName).content(rectanglePathName).size.expression = expressionSize;\n\tshapeLayer.content(groupName).content(rectanglePathName).position.expression = expressionPos;\n\t\n\t\n\t// If Using existing text layer\n\tif(!addTextBool){\n\t  var posText = curComp.layer(curText.name).property(\"Position\").value;\n\t  shapeLayer.property(\"Position\").setValue([posText[0], posText[1]]);\n\t}\n\t\n\t// Name Shape layer based on text\n\tshapeLayer.name += \" - \" + truncateString(curText.name, 10);\n\t\t\n\t// Set parent shape layer to text layer\n\tcurComp.layer(shapeLayer.name).parent = curText;\n\t\n\t// Set Position of Text to be center of comp\n\tcurText.property(\"position\").setValue([curComp.width/2, curComp.height/2]);\n\t\n\t// Move to last index\n\tshapeLayer.moveToEnd();\n}\n\n// Deselect All Layers\napp.executeCommand(2004);\n\napp.endUndoGroup();","name":"Text Background","documentation":"Text Background that always expand with the sourceText.\n\nIf you have your existing text layer, **uncheck \"Create Text\"** to use your own text layer. And **make sure your text layer is selected**.","tags":["Text","Background","Layer","Button"],"last_update":1588139172725}]},{"_id":"Temp-Code-1608268242175","name":"Temp Code","type":"script","creation_date":1608268242175,"expressions":[{"_id":"Temporary-3D-Footage-Montage-Compositions-1608268258663","code":"require(\"ratio_calculator\");\nrequire(\"composition\");\n\nvar comp = app.project.activeItem;\nvar width = comp.width;\nvar height = comp.height;\nvar currentComp = _ bool: Do it in current active composition ? _;\nvar currentPixelAspect = _ bool: Follow selected/current \"Pixel Aspect\" Composiion? _;\nvar folderOrNot = _ bool: Add Collage Comp to folder ? _;\nvar createSolid = _ bool: Create Sold inside the new composition created? _;\nvar compWidthHeight = _ number * - 2: Width & Height _;\nvar customFrameRate = _ number * : Frame Rate _;\nvar numOfComps = _ number * : How many compositios to duplicate? _;\nvar compSize = _ number: Size of Compositions(0 - 100) - Default: 100 _;\nvar compSizeConvert = compSize / 100;\n\n\ntry {\n\tif (!compSize) {\n\t\tthrow Error(\"Please enter your size of compositions\");\n\t}\n\n\tif (!currentComp && (app.project.selection.length > 0)) {\n\t\tthrow Error(\"Select any compositions from your project to begin\");\n\t}\n\trunMultiCompose();\n} catch (e) {\n\talert(e);\n}\n\nfunction runMultiCompose() {\n\tapp.beginUndoGroup(\"GridCompose\");\n\tvar totalActiveComp = width * height;\n\tvar totalNewComp = compWidthHeight[0] * compWidthHeight[1];\n\tvar ratioNewComp = calculateRatio(compWidthHeight[0], compWidthHeight[1]);\n\tvar resizeNewComp = totalNewComp * compSizeConvert;\n\tvar newWidth = getRectangleWidthHeight(ratioNewComp, resizeNewComp)[0];\n\tvar newHeight = getRectangleWidthHeight(ratioNewComp, resizeNewComp)[1];\n\tvar compCount = Math.round(totalActiveComp / resizeNewComp);\n\tvar pixelAspect = currentPixelAspect ? comp.pixelAspect : ratioNewComp.split(\":\")[0]/ratioNewComp.split(\":\")[1];\n\n\t// alert(\"Total Active Comp = \" + totalActiveComp + \". Total new Comp = \" + totalNewComp + \". Resize New Comp = \" + resizeNewComp + \". Ratio New Comp = \" + ratioNewComp + \", Total of new comp = \" + resizeNewComp + \". Comp Count = \" + compCount);\n\n\t// Build grid from top left to top right, then repeat to second line & repeat until at the end of the compositions.\n\tvar myComp;\n\tif(folderOrNot){\n\t  \tvar folder = addFolder(comp.name + \" (COLLAGES)\");\n\t}\n  arrayComp = [];\n\tfor (var addComp = 0; addComp < numOfComps; addComp++) {\n\t  if(!folderOrNot){\n\t    try{\n  \t\t  myComp = addCompFromActiveComp(\"Collage-\" + addComp, compWidthHeight[0], compWidthHeight[1], pixelAspect, Math.round(comp.duration), customFrameRate);\n  \t\t  comp.layer(\"Collage-\"+addComp).scale.setValue([compSize ? compSize : 100, compSize ? compSize : 100]);\n  \t\t  arrayComp.push(myComp);\n  \t\t}catch(e){\n  \t\t  alert(\"Error on Comp number = Collage-\" + addComp + \". \\n\" + e)\n  \t\t}\n\t  }else{\n\t    try{\n  \t\t  myComp = addCompFromFolder(folder, \"Collage-\" + addComp, compWidthHeight[0], compWidthHeight[1], pixelAspect, Math.round(comp.duration), customFrameRate);\n  \t\t  comp.layers.add(myComp);\n  \t\t  comp.layer(\"Collage-\"+addComp).scale.setValue([compSize ? compSize : 100, compSize ? compSize : 100]);\n  \t\t  arrayComp.push(myComp);\n  \t\t}catch(e){\n  \t\t  alert(\"Error on Comp number = Collage-\" + addComp + \". \\n\" + e)\n  \t\t}\n\t  }\n\t  \n\t  addSolid(myComp, \"Solid\", compWidthHeight[0], compWidthHeight[1], pixelAspect, 10)\n\t}\n  \n  // Select Created Comp\n  for(var select = 0; select < arrayComp.length; select++){\n    arrayComp[select].selected = true;\n  }\n\n\tapp.endUndoGroup();\n}","name":"Multi Composition","documentation":"Multi Compositions Script","last_update":1609649744298}]},{"_id":"Useful-Expression-1588219431839","name":"Useful Expression","type":"expression","expressions":[{"_id":"Automatic-Fade-1588224794770","code":"var transition = _ slider: Transition Value _;       \r\nif (marker.numKeys<2){\r\n  tSecs = transition / ( 1 / thisComp.frameDuration); \r\n  linear(time, inPoint, inPoint + tSecs, 0, 100) - linear(time, outPoint - tSecs, outPoint, 0, 100)\r\n}else{\r\n  linear(time, inPoint, marker.key(1).time, 0, 100) - linear(time, marker.key(2).time, outPoint, 0, 100)\r\n}","name":"Automatic Fade","documentation":"The automatic fade expression is useful when you dont want to bother a create keyframes for a fade animation. TARGET: **Opacity**","property_types":["1d"],"tags":["Fade","Transition","Automatic"],"last_update":1588226154709},{"_id":"Blink-1588227811718","code":"blinkSpeed = _ angle: Blink Speed _;\r\nn = Math.sin(time * blinkSpeed);\r\nif (n < 0) 0\r\nelse 100;","name":"Blink","documentation":"The blinking expression become super handy when you dont want to repeat a bunch of opacity keyframes over and over or want to animate a cursor quickly.\nSimply add this expression below to your opacity properties.\nTARGET: **Opacity**","property_types":["other"],"tags":["Opacity","Blink"],"last_update":1588228205977},{"_id":"Bounce-Expression-1588219438498","code":"amp = _ slider: Amplitude _;\r\nfreq = _ slider: Frequency _;\r\ndecay = _ slider: Decay _;\r\nn = 0;\r\nif (numKeys > 0){\r\n  n = nearestKey(time).index;\r\nif (key(n).time > time){\r\n  n--;\r\n}}\r\nif (n == 0){\r\n  t = 0;\r\n}else{\r\n  t = time - key(n).time;\r\n}\r\nif (n > 0 && t < 1){\r\n  v = velocityAtTime(key(n).time - thisComp.frameDuration/10);\r\n  value + v*amp*Math.sin(freq*t*2*Math.PI)/Math.exp(decay*t);\r\n}else{\r\n  value\r\n  \r\n}","name":"Bounce Expression","documentation":"The bounce expression is very useful to make your animations and titles look dynamic with a nice elastic movement, just **make 2 keyframes position** and past the code below. TARGET: **Position**","property_types":["1d","2d"],"tags":["Bounce","Position"],"snippet_prefix":"","is_snippet":false,"last_update":1588226173559},{"_id":"Constant-Rotation-per-Second-1588226578681","code":"veloc = _ angle: Degree Rotation _; //360 Degree Rotation per Second\r\nr = rotation + (time - inPoint) *veloc;\r\n[r]","name":"Constant Rotation per Second","documentation":"Here is another After Effects rotation expression, no key frames needed to make a simple 360 rotation on a layer. TARGET: **Rotation**","property_types":["other"],"tags":["Rotation","Loop"],"last_update":1588226780120},{"_id":"Looping-Wiggle-1588226203602","code":"freq = _ slider: Frequency (Try 1.0) _;\r\namp = _ slider: Amplitude _;\r\nloopTime = _ slider: Num of Loop _;\r\nt = time % loopTime;\r\nwiggle1 = wiggle(freq, amp, 1, 0.5, t);\r\nwiggle2 = wiggle(freq, amp, 1, 0.5, t - loopTime);\r\nlinear(t, 0, loopTime, wiggle1, wiggle2)","name":"Looping Wiggle","documentation":"The looping [Wiggle Expression](https://blog.motionisland.com/wiggle-expression-after-effects-tutorial/) become handy when you want an object to move randomly in your composition. Looping wiggle should be seamless and you shouldnt see a cut, this expression is also used for background animation. TARGET: **Position**","property_types":["1d","other"],"tags":["Loop","Wiggle"],"last_update":1588226498353},{"_id":"Squash---Stretch-1588225343333","code":"maxDev = _ slider: Max Deviation in Pixels _; // max deviation in pixels\r\nspd = _ slider: Speed of Oscillation _; //speed of oscillation\r\ndecay = _ slider: How Fast it Slows Down (Try 1.0) _; //how fast it slows down\r\n\r\nt = time - inPoint;\r\nx = scale[0] + maxDev*Math.sin(spd*t)/Math.exp(decay*t);\r\ny = scale[0]*scale[1]/x;\r\n[x,y]","name":"Squash & Stretch","documentation":"This bouncing squash and stretch expression should make your animation a bit more alive by adding a proportional scale to your shapes or images. TARGET: **Scale**","property_types":["2d","2d_spatial"],"tags":["Squash","Stretch"],"last_update":1588225711828}]}]