[{"_id":"Fremox-Debug-1598611159207","name":"AE-Debug","type":"script","expressions":[{"_id":"Check-Object-Prototype-Integrity-1598611182249","code":"function isMyObjectFucked() {\n\tvar obj = {};\n\tfor (var key in obj) {\n\t\tif (!obj.hasOwnProperty(key)) return true;\n\t}\n\treturn false;\n}\n\nif (isMyObjectFucked()) alert(\"Object prototype has been altered\");\nelse alert(\"Object prototype is ok\");","name":"Check Object Prototype Integrity","last_update":1598614614879},{"_id":"Clean-Object-Prototype-1598611167384","code":"function isMyObjectFucked() {\n\tvar obj = {};\n\tfor (var key in obj) {\n\t\tif (!obj.hasOwnProperty(key)) return true;\n\t}\n\treturn false;\n}\n\nvar obj = {};\nfor (var key in obj) {\n\tif (!obj.hasOwnProperty(key)) delete Object.prototype[key];\n}\n\nif (isMyObjectFucked()) alert(\"Object prototype can't be cleaned\");\nelse alert(\"Object prototype has been cleaned\");","name":"Clean Object Prototype","documentation":"","last_update":1598614702886},{"_id":"Find-demoniac-script-1598614575057","code":"// Check if Object prototype is altered\nfunction isMyObjectPrototypeFucked() {\n\tvar obj = {};\n\tfor (var key in obj) {\n\t\tif (!obj.hasOwnProperty(key)) return true;\n\t}\n\treturn false;\n}\n\n// Clean Object prototype\nfunction cleanObjectPrototype() {\n\tvar obj = {};\n\tfor (var key in obj) {\n\t\tif (!obj.hasOwnProperty(key)) delete Object.prototype[key];\n\t}\n}\n\nvar folder = Folder.selectDialog(\"Select your script folder\");\nif (folder) {\n\tcleanObjectPrototype();\n\tvar files = folder.getFiles();\n\tvar bad_scripts = [];\n\tfor (var i = 0; i < files.length; i++) {\n\t\tvar parts = files[i].fsName.split(\".\");\n\t\tvar ext = parts[parts.length - 1].toLowerCase();\n\t\tif (ext === \"jsx\" || ext === \"jsxbin\") {\n\t\t\ttry {\n\t\t\t\t$.evalFile(files[i]);\n\t\t\t} catch (e) {}\n\t\t\tif (isMyObjectPrototypeFucked()) {\n\t\t\t\tbad_scripts.push(files[i].name);\n\t\t\t\tcleanObjectPrototype();\n\t\t\t}\n\t\t}\n\t}\n\tif (bad_scripts.length === 0) alert(\"There isn't any demoniac script in this folder\");\n\telse {\n\t\talert(\"Please uninstall these scripts: \" + bad_scripts.join(\", \"));\n\t}\n}","name":"Find demoniac script","documentation":"Run all scripts inside a folder (not in subfolders) to check if one or several of them have edited the Object prototype","last_update":1598614790911}]},{"_id":"Helper-1608553666230","name":"Helper","type":"script","creation_date":1608553666231,"expressions":[{"_id":"Collage-Script-1608620894986","code":"var run = _ bool: Run Collage immediately ? (Useful to execute from MoCode Editor _;\nvar borderSize = _ number: Border Size _;\nvar fitToComp = _ bool: Fit To Comp? _;\n\t\tif (run) {\n\t\t\trunCollage(borderSize, fitToComp);\n\t\t}\n\n\t\tfunction runCollage(borderSize, fitToComp) {\n\t\t\t// Collage.jsx\n\t\t\t// Copyright (c) 2012 Motion Boutique\n\t\t\t//\n\t\t\t// Photobook layout with selected layers\n      run()\n\t\t\tfunction Node() {\n\t\t\t\tthis.leftNode = null;\n\t\t\t\tthis.rightNode = null;\n\t\t\t\tthis.value = \"\";\n\t\t\t\tthis.bbWidth = \"\";\n\t\t\t\tthis.bbHeight = \"\";\n\t\t\t\tthis.equation = \"\";\n\t\t\t\tthis.upperLeft = [0, 0];\n\t\t\t}\n\n\t\t\tfunction nodeToString(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\ttreeStr += node.value + \" \"; // \"(\" + node.bbWidth + \",\" + node.bbHeight + \") \";\n\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\tvar s = nodeToString(node.leftNode);\n\t\t\t\t\t\tif (s) treeStr += s;\n\t\t\t\t\t}\n\t\t\t\t\tif (node.rightNode) {\n\t\t\t\t\t\tvar s = nodeToString(node.rightNode);\n\t\t\t\t\t\tif (s) treeStr += s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getRandomTree() {\n\t\t\t\tnPrime = 0;\n\t\t\t\tleafs = [];\n\t\t\t\twhile (nPrime < n) {\n\t\t\t\t\tif (leafs.length >= 1) {\n\t\t\t\t\t\tvar j = Math.floor(Math.random() * leafs.length);\n\t\t\t\t\t\tvar node = leafs[j];\n\t\t\t\t\t\tleafs.splice(j, 1);\n\n\t\t\t\t\t\tnode.leftNode = new Node();\n\t\t\t\t\t\tnode.leftNode.value = nPrime + 1;\n\t\t\t\t\t\tleafs.push(node.leftNode);\n\t\t\t\t\t\tnPrime++;\n\n\t\t\t\t\t\tif (nPrime < n) {\n\t\t\t\t\t\t\tnode.rightNode = new Node();\n\t\t\t\t\t\t\tnode.rightNode.value = nPrime + 1;\n\t\t\t\t\t\t\tleafs.push(node.rightNode);\n\t\t\t\t\t\t\tnPrime++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar node = rootNode;\n\t\t\t\t\t\tnode.value = nPrime + 1;\n\t\t\t\t\t\tleafs.push(node);\n\t\t\t\t\t\tnPrime++;\n\t\t\t\t\t}\n\t\t\t\t\t//alert(\"num nodes: \" + nPrime + \"\\rleafs: \" + leafs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar lastCut = \"\";\n\n\t\t\tfunction assignDataToNode(node) {\n\t\t\t\tif (node.leftNode) {\n\t\t\t\t\tif (!isNaN(node.value)) {\n\t\t\t\t\t\t//for (var z = 0; z < 25; z++) var foo = Math.random();\n\t\t\t\t\t\tvar nodeVal = (Math.random() < 0.5) ? \"H\" : \"V\";\n\t\t\t\t\t\tif (nodeVal == lastCut)\n\t\t\t\t\t\t\tnodeVal = (nodeVal == \"H\") ? \"V\" : \"H\";\n\t\t\t\t\t\tif (Math.random() < 0.3)\n\t\t\t\t\t\t\tnodeVal = (nodeVal == \"H\") ? \"V\" : \"H\";\n\t\t\t\t\t\tnode.value = nodeVal;\n\t\t\t\t\t\tlastCut = nodeVal;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!isNaN(node.value)) {\n\t\t\t\t\t\tvar j = Math.floor(Math.random() * leafs.length);\n\t\t\t\t\t\tnode.value = \"\" + (photoCounter + 1);\n\t\t\t\t\t\tphotoCounter++;\n\t\t\t\t\t\tleafs.splice(j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction traverseAndAssignData(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\tassignDataToNode(node);\n\t\t\t\t\ttraverseAndAssignData(node.leftNode);\n\t\t\t\t\ttraverseAndAssignData(node.rightNode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction traverseAndComputeBBPhotoNode(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// terminals\n\t\t\t\t\tif (!node.leftNode) //  !node.rightNode)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar nodeId = parseInt(node.value, 10);\n\t\t\t\t\t\tvar a = photoOriginalSizes[nodeId - 1][1] / photoOriginalSizes[nodeId - 1][0];\n\t\t\t\t\t\tnode.bbWidth = \"w\" + nodeId + \" + b + b\";\n\t\t\t\t\t\tnode.bbHeight = a.toFixed(3) + \" * w\" + nodeId + \" + b + b\";\n\n\t\t\t\t\t\t//alert(node.value + \"\\n\" + node.bbWidth);\n\t\t\t\t\t\t//alert(\"nodeId: \" + nodeId + \"\\nnode.value: \" + node.value);\n\t\t\t\t\t}\n\t\t\t\t\t// interior\n\t\t\t\t\telse {\n\t\t\t\t\t\ttraverseAndComputeBBPhotoNode(node.leftNode);\n\t\t\t\t\t\ttraverseAndComputeBBPhotoNode(node.rightNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction traverseAndComputeBBInteriorNode(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// interior\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\ttraverseAndComputeBBInteriorNode(node.leftNode);\n\t\t\t\t\t\ttraverseAndComputeBBInteriorNode(node.rightNode);\n\n\t\t\t\t\t\tif (node.value == \"H\") {\n\t\t\t\t\t\t\tnode.bbWidth = node.leftNode.bbWidth;\n\t\t\t\t\t\t\tnode.bbHeight = node.leftNode.bbHeight + \" + \" + node.rightNode.bbHeight + \" + s\";\n\n\t\t\t\t\t\t\t//alert(node.value + \"(traverseAndComputeBBInteriorNode)\\n\" + node.bbWidth);\n\t\t\t\t\t\t} else if (node.value == \"V\") {\n\t\t\t\t\t\t\tnode.bbWidth = node.leftNode.bbWidth + \" + \" + node.rightNode.bbWidth + \" + s\";\n\t\t\t\t\t\t\tnode.bbHeight = node.leftNode.bbHeight;\n\n\t\t\t\t\t\t\t//alert(node.value + \"(traverseAndComputeBBInteriorNode)\\n\" + node.bbWidth);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getNodeEquation(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// interior\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\tgetNodeEquation(node.leftNode);\n\t\t\t\t\t\tgetNodeEquation(node.rightNode);\n\n\t\t\t\t\t\tif (node.value == \"H\") {\n\t\t\t\t\t\t\t//alert(node.value + \" (getNodeEquation)\\n\" + node.leftNode.bbWidth);\n\t\t\t\t\t\t\tnode.equation = node.leftNode.bbWidth + \" = \" + node.rightNode.bbWidth;\n\t\t\t\t\t\t} else if (node.value == \"V\") {\n\t\t\t\t\t\t\t//alert(node.value + \" (getNodeEquation)\\n\" + node.leftNode.bbWidth);\n\t\t\t\t\t\t\tnode.equation = node.leftNode.bbHeight + \" = \" + node.rightNode.bbHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//alert(\"node.equation:\\n\" + node.equation);\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction evaluateExpression(expr) {\n\t\t\t\tvar wcoefs = [];\n\t\t\t\tvar betacoef = 0;\n\t\t\t\tvar sigmacoef = 0;\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\twcoefs.push(0);\n\t\t\t\t}\n\n\t\t\t\t//alert(\"expression:\\n\" + expr);\n\n\t\t\t\tfor (var i = 0; i < expr.length; i++) {\n\t\t\t\t\tvar ch = expr.charAt(i);\n\t\t\t\t\tif (ch == \"w\") {\n\t\t\t\t\t\tvar nodeIdStr = \"\";\n\t\t\t\t\t\tvar j = 1;\n\t\t\t\t\t\twhile (!isNaN(expr.charAt(i + j))) // w10 for instance\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnodeIdStr += expr.charAt(i + j);\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar nodeId = parseInt(nodeIdStr) - 1;\n\n\t\t\t\t\t\tvar factor = \"\"; // (1) w1\n\t\t\t\t\t\tif (i != 0 && expr.charAt(i - 2) == \"*\") {\n\t\t\t\t\t\t\tfor (var z = 0; z < 5; z++) // 1.333 * w1\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactor += expr.charAt(i - 8 + z);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else factor = \"1\";\n\n\t\t\t\t\t\twcoefs[nodeId] += parseFloat(factor);\n\t\t\t\t\t} else if (ch == \"b\") {\n\t\t\t\t\t\tbetacoef++;\n\t\t\t\t\t} else if (ch == \"s\") {\n\t\t\t\t\t\tsigmacoef++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//alert(wcoefs);\n\t\t\t\t//alert(betacoef);\n\t\t\t\t//alert(sigmacoef);\n\n\t\t\t\tvar res = 0;\n\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\tres += wcoefs[i] * xVec[i];\n\t\t\t\t}\n\t\t\t\tres += betacoef * beta + sigmacoef * sigma;\n\n\t\t\t\t//alert(\"res: \" + res);\n\n\t\t\t\treturn res;\n\t\t\t}\n\n\n\t\t\tfunction traverseAndComputeUpperLeft(node) {\n\t\t\t\tif (node) {\n\t\t\t\t\t// interior\n\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\tif (node.value == \"H\") {\n\t\t\t\t\t\t\tnode.leftNode.upperLeft = node.upperLeft;\n\t\t\t\t\t\t\tvar h = evaluateExpression(node.leftNode.bbHeight);\n\t\t\t\t\t\t\tnode.rightNode.upperLeft = node.upperLeft + [0, h];\n\t\t\t\t\t\t} else if (node.value == \"V\") {\n\t\t\t\t\t\t\tnode.leftNode.upperLeft = node.upperLeft;\n\t\t\t\t\t\t\tvar w = evaluateExpression(node.leftNode.bbWidth);\n\t\t\t\t\t\t\tnode.rightNode.upperLeft = node.upperLeft + [w, 0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttraverseAndComputeUpperLeft(node.leftNode);\n\t\t\t\t\t\ttraverseAndComputeUpperLeft(node.rightNode);\n\t\t\t\t\t}\n\t\t\t\t\t// leafs\n\t\t\t\t\telse {\n\t\t\t\t\t\t// upperleft's have been assigned, store location in global uls array\n\t\t\t\t\t\tvar nodeId = parseInt(node.value) - 1;\n\t\t\t\t\t\tuls[nodeId] = node.upperLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction findAndSolveSytem(node, constrainTypeStr) {\n\t\t\t\tvar matA = new Array(N);\n\t\t\t\tvar bVec = new Array(N);\n\n\t\t\t\tvar wsL = new Array(N);\n\t\t\t\tvar wsR = new Array(N);\n\t\t\t\tvar betasL = new Array(N);\n\t\t\t\tvar betasR = new Array(N);\n\t\t\t\tvar sigmasL = new Array(N);\n\t\t\t\tvar sigmasR = new Array(N);\n\n\t\t\t\t// init buckets\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\tmatA[i] = new Array(N);\n\t\t\t\t\tbVec[i] = 0;\n\n\t\t\t\t\twsL[i] = new Array(N);\n\t\t\t\t\twsR[i] = new Array(N);\n\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\twsL[i][j] = 0;\n\t\t\t\t\t\twsR[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbetasL[i] = 0;\n\t\t\t\t\tbetasR[i] = 0;\n\t\t\t\t\tsigmasL[i] = 0;\n\t\t\t\t\tsigmasR[i] = 0;\n\t\t\t\t}\n\n\t\t\t\tgetNodeEquation(node); // find N*-1* equations (populate '.equation' field of interior nodes)\n\n\n\t\t\t\t// parse N*-1* equations\n\t\t\t\tvar equationId = 0;\n\t\t\t\tparseEquation(node); // populate ws, betas and sigma arrays\n\n\n\t\t\t\t// construct coefs from the N-1 eqs\n\t\t\t\tfor (var i = 0; i < N - 1; i++) {\n\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\tmatA[i][j] = wsL[i][j] - wsR[i][j]; // ws are the unkown, on the left hand side of the eqn\n\t\t\t\t\t}\n\t\t\t\t\tbVec[i] = (betasR[i] - betasL[i]) * beta + (sigmasR[i] - sigmasL[i]) * sigma; // b is to the right hand side\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// add Nth constraint\n\t\t\t\t\tvar str;\n\t\t\t\t\tif (constrainTypeStr == \"constrainWidth\")\n\t\t\t\t\t\tstr = node.bbWidth + \" = 0\";\n\t\t\t\t\telse if (constrainTypeStr == \"constrainHeight\")\n\t\t\t\t\t\tstr = node.bbHeight + \" = 0\";\n\n\t\t\t\t\tparseAndAssign(str);\n\t\t\t\t\tequationId++;\n\n\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\tmatA[N - 1][j] = wsL[N - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (constrainTypeStr == \"constrainWidth\")\n\t\t\t\t\t\tbVec[N - 1] = W - (betasL[N - 1] * beta + sigmasL[N - 1] * sigma);\n\t\t\t\t\telse if (constrainTypeStr == \"constrainHeight\")\n\t\t\t\t\t\tbVec[N - 1] = H - (betasL[N - 1] * beta + sigmasL[N - 1] * sigma);\n\t\t\t\t\t/*\t\n\t\t\t\t\t// debug-------------\n\t\t\t\t\tvar file = new File(Folder.desktop.fsName + \"/Ab.txt\");\n\t\t\t\t\tfile.open(\"w\")\n\t\t\t\t\tvar txt = \"\"\n\t\t\t\t\tfor (var i = 0; i < matA.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var j = 0; j < matA[0].length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttxt += matA[i][j] + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt += \"\\r\\n\";\t\n\t\t\t\t\t}\n\t\t\t\t\tfile.writeln(txt);\n\t\t\t\t\tfile.writeln(\"\");\n\t\t\t\t\tvar txt = \"\";\n\t\t\t\t\tfor (var i = 0; i < bVec.length; i++)\n\t\t\t\t\t\ttxt += bVec[i] + \"\\n\";\n\t\t\t\t\tfile.writeln(txt);\n\n\t\t\t\t\ttreeStr = \"\";\n\t\t\t\t\tnodeToString(rootNode); // populate treeStr\n\t\t\t\t\tfile.writeln(treeStr);\n\n\t\t\t\t\tfile.close();\n\t\t\t\t\t//file.execute();\n\t\t\t\t\t//--------------\n\t\t\t\t\t*/\n\n\t\t\t\t\t// solve using SVD decomposition -------------------------\n\t\t\t\t\tmatA = numeric.svd(matA);\n\n\t\t\t\t\tvar diagInvS = new Array(N);\n\t\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\t\tdiagInvS[i] = new Array(N);\n\t\t\t\t\t\tfor (var j = 0; j < N; j++) {\n\t\t\t\t\t\t\tdiagInvS[i][j] = 0;\n\t\t\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\t\t\tif (matA.S[i] != 0)\n\t\t\t\t\t\t\t\t\tdiagInvS[i][j] = 1 / matA.S[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar temp1 = numeric.dot(matA.V, diagInvS);\n\t\t\t\t\tvar temp2 = numeric.dot(numeric.transpose(matA.U), bVec);\n\t\t\t\t\tvar res = numeric.dot(temp1, temp2);\n\t\t\t\t\t//----------------------------------------------------------\n\n\t\t\t\t\t/*\n\t\t\t\t\t// solve using Linear Programming\n\t\t\t\t\t*/\n\t\t\t\t\t//alert(res);\n\t\t\t\t} catch (e) {\n\t\t\t\t\talert(e);\n\t\t\t\t}\n\t\t\t\treturn res;\n\n\t\t\t\t//--utils\n\n\t\t\t\tfunction parseAndAssign(str) {\n\t\t\t\t\tvar strParts = str.split(\" = \");\n\t\t\t\t\tvar leftPart = strParts[0];\n\t\t\t\t\tvar rightPart = strParts[1];\n\n\t\t\t\t\t//alert(\"left part...\\n\" + leftPart);\n\t\t\t\t\t//alert(\"right part...\\n\" + rightPart);\n\n\t\t\t\t\t// parse left side\n\t\t\t\t\tfor (var i = 0; i < leftPart.length; i++) {\n\t\t\t\t\t\tvar ch = leftPart.charAt(i);\n\t\t\t\t\t\tif (ch == \"w\") {\n\t\t\t\t\t\t\tvar nodeIdStr = \"\";\n\t\t\t\t\t\t\tvar j = 1;\n\t\t\t\t\t\t\twhile (!isNaN(leftPart.charAt(i + j))) // w10 for instance\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeIdStr += leftPart.charAt(i + j);\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar nodeId = parseInt(nodeIdStr) - 1;\n\n\t\t\t\t\t\t\tvar factor = \"\"; // (1) w1\n\t\t\t\t\t\t\tif (i != 0 && leftPart.charAt(i - 2) == \"*\") {\n\t\t\t\t\t\t\t\tfor (var z = 0; z < 5; z++) // 1.333 * w1\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfactor += leftPart.charAt(i - 8 + z);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else factor = \"1\";\n\n\t\t\t\t\t\t\twsL[equationId][nodeId] += parseFloat(factor);\n\t\t\t\t\t\t} else if (ch == \"b\") {\n\t\t\t\t\t\t\tbetasL[equationId]++;\n\t\t\t\t\t\t} else if (ch == \"s\") {\n\t\t\t\t\t\t\tsigmasL[equationId]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// parse right side\n\t\t\t\t\tfor (var i = 0; i < rightPart.length; i++) {\n\t\t\t\t\t\tvar ch = rightPart.charAt(i);\n\t\t\t\t\t\tif (ch == \"w\") {\n\t\t\t\t\t\t\tvar nodeIdStr = \"\";\n\t\t\t\t\t\t\tvar j = 1;\n\t\t\t\t\t\t\twhile (!isNaN(rightPart.charAt(i + j))) // w10 for instance\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeIdStr += rightPart.charAt(i + j);\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar nodeId = parseInt(nodeIdStr) - 1;\n\n\t\t\t\t\t\t\tvar factor = \"\"; // (1) w1\n\t\t\t\t\t\t\tif (i != 0 && rightPart.charAt(i - 2) == \"*\") {\n\t\t\t\t\t\t\t\tfor (var z = 0; z < 5; z++) // 1.333 * w1\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfactor += rightPart.charAt(i - 8 + z);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else factor = \"1\";\n\n\t\t\t\t\t\t\twsR[equationId][nodeId] += parseFloat(factor);\n\t\t\t\t\t\t} else if (ch == \"b\") {\n\t\t\t\t\t\t\tbetasR[equationId]++;\n\t\t\t\t\t\t} else if (ch == \"s\") {\n\t\t\t\t\t\t\tsigmasR[equationId]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseEquation(node) {\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\t// interior\n\t\t\t\t\t\tif (node.leftNode) {\n\t\t\t\t\t\t\tparseEquation(node.leftNode);\n\t\t\t\t\t\t\tparseEquation(node.rightNode);\n\n\t\t\t\t\t\t\tvar str = node.equation;\n\t\t\t\t\t\t\tif (str != \"\") {\n\t\t\t\t\t\t\t\t//alert(\"parsing equationId \" + equationId + \"\\n\" + str);\n\t\t\t\t\t\t\t\tparseAndAssign(str);\n\n\t\t\t\t\t\t\t\tequationId++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getOriginalSizes() {\n\t\t\t\tvar sizes = [];\n\n\t\t\t\tvar comp = app.project.activeItem;\n\t\t\t\tif (comp instanceof CompItem) {\n\t\t\t\t\tvar selLayers = comp.selectedLayers;\n\t\t\t\t\tif (selLayers.length < 1) {\n\t\t\t\t\t\talert(\"Select some layers\");\n\t\t\t\t\t\treturn sizes;\n\t\t\t\t\t}\n\n\t\t\t\t\tW = comp.width;\n\t\t\t\t\tH = comp.height;\n\n\t\t\t\t\tfor (var i = 0; i < selLayers.length; i++) {\n\t\t\t\t\t\tif (selLayers[i] instanceof AVLayer) {\n\t\t\t\t\t\t\tsizes.push([selLayers[i].width, selLayers[i].height]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else alert(\"Select some layers\");\n\n\t\t\t\treturn sizes;\n\t\t\t}\n\n\t\t\tfunction scaleAndPositionLayers(xVec, uls) {\n\t\t\t\t//alert(xVec);\n\t\t\t\tvar comp = app.project.activeItem;\n\t\t\t\tvar selLayers = comp.selectedLayers;\n\t\t\t\tvar photoId = 0;\n\t\t\t\tfor (var i = 0; i < selLayers.length; i++) {\n\t\t\t\t\tif (selLayers[i] instanceof AVLayer) {\n\t\t\t\t\t\tvar newW = xVec[photoId];\n\t\t\t\t\t\tvar ratio = newW / photoOriginalSizes[photoId][0];\n\t\t\t\t\t\tvar newH = ratio * photoOriginalSizes[photoId][1];\n\n\t\t\t\t\t\tvar s = 100 * ratio; // newWidth / originalWidth\n\n\t\t\t\t\t\tvar holdTime = 1; // in s\n\n\t\t\t\t\t\tvar hasScaleKeys = selLayers[i].scale.numKeys;\n\t\t\t\t\t\tif (hasScaleKeys) {\n\t\t\t\t\t\t\tselLayers[i].scale.setValueAtTime(comp.time, [s, s]);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].scale.nearestKeyIndex(comp.time);\n\t\t\t\t\t\t\tselLayers[i].scale.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.HOLD);\n\n\t\t\t\t\t\t\tselLayers[i].scale.setValueAtTime(comp.time + holdTime, [s, s]);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].scale.nearestKeyIndex(comp.time + holdTime);\n\t\t\t\t\t\t\tselLayers[i].scale.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.LINEAR);\n\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tselLayers[i].scale.setValue([s, s]);\n\n\t\t\t\t\t\tvar p = uls[photoId] + [newW / 2, newH / 2];\n\n\t\t\t\t\t\tvar hasPosKeys = selLayers[i].position.numKeys;\n\t\t\t\t\t\tif (hasPosKeys) {\n\t\t\t\t\t\t\tselLayers[i].position.setValueAtTime(comp.time, p);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].position.nearestKeyIndex(comp.time);\n\t\t\t\t\t\t\tselLayers[i].position.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.HOLD);\n\n\t\t\t\t\t\t\tselLayers[i].position.setValueAtTime(comp.time + holdTime, p);\n\t\t\t\t\t\t\tvar keyIndex = selLayers[i].position.nearestKeyIndex(comp.time + holdTime);\n\t\t\t\t\t\t\tselLayers[i].position.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.LINEAR);\n\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tselLayers[i].position.setValue(p);\n\n\n\t\t\t\t\t\tphotoId++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction fitInside() {\n\t\t\t\tvar fitInside = true;\n\t\t\t\tfor (var i = 0; fitInside && i < N; i++) {\n\t\t\t\t\tvar newW = xVec[i];\n\t\t\t\t\tvar ratio = newW / photoOriginalSizes[i][0];\n\t\t\t\t\tvar newH = ratio * photoOriginalSizes[i][1];\n\n\t\t\t\t\tif (uls[i][0] + newW > (W + 0.1) || uls[i][1] + newH > (H + 0.1)) {\n\t\t\t\t\t\t//alert((uls[i][0] + newW) + \" > \" + W + \" || \" + (uls[i][1] + newH) + \" > \" + H);\n\t\t\t\t\t\tfitInside = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//alert(\"fitInside: \" + fitInside);\n\t\t\t\treturn fitInside;\n\t\t\t}\n\n\t\t\tfunction computeCoverage() {\n\t\t\t\tvar coverage = 0; // 1 represents the entire canvas\n\n\t\t\t\tvar totalArea = 0;\n\t\t\t\tfor (var i = 0; i < N; i++) {\n\t\t\t\t\tvar newW = xVec[i];\n\t\t\t\t\tvar ratio = newW / photoOriginalSizes[i][0];\n\t\t\t\t\tvar newH = ratio * photoOriginalSizes[i][1];\n\t\t\t\t\ttotalArea += (newW * newH);\n\t\t\t\t}\n\t\t\t\tcoverage = totalArea / (W * H);\n\n\t\t\t\treturn coverage;\n\t\t\t}\n\n\t\t\tfunction isScaleAcceptable() {\n\t\t\t\tvar isAcceptable = true;\n\n\t\t\t\tfor (var i = 0; isAcceptable && i < N; i++) {\n\t\t\t\t\tif (xVec[i] > photoOriginalSizes[i][0]) // image scale > 100%\n\t\t\t\t\t{\n\t\t\t\t\t\tisAcceptable = false;\n\t\t\t\t\t\t//alert(\"scale of layer \" + (i+1) + \" is not acceptable\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isAcceptable;\n\t\t\t}\n\n\t\t\tfunction fitCompToCollage(widths, origins) {\n\t\t\t\t//var bbW = evaluateExpression(rootNode.bbWidth);\n\t\t\t\t//var bbH = evaluateExpression(rootNode.bbHeight);\n\t\t\t\t//alert(bbW + \" x \" + bbH);\n\t\t\t\tvar top = 0;\n\t\t\t\tvar left = 0;\n\t\t\t\tvar bottom = 0;\n\t\t\t\tvar right = 0;\n\t\t\t\tfor (var i = 0; i < origins.length; i++) {\n\t\t\t\t\tvar w = widths[i];\n\t\t\t\t\tvar ratio = w / photoOriginalSizes[i][0];\n\t\t\t\t\tvar h = ratio * photoOriginalSizes[i][1];\n\t\t\t\t\tif (origins[i][0] < left) left = origins[i][0];\n\t\t\t\t\tif (origins[i][1] < top) top = origins[i][1];\n\t\t\t\t\tif (origins[i][0] + w > right) right = origins[i][0] + w;\n\t\t\t\t\tif (origins[i][1] + h > bottom) bottom = origins[i][1] + h;\n\t\t\t\t}\n\t\t\t\tcollageW = right - left;\n\t\t\t\tcollageH = bottom - top;\n\t\t\t\t//alert(collageW + \" x \" + collageH);\n\t\t\t\t//app.project.activeItem.width = Math.floor(collageW);\n\t\t\t\tapp.project.activeItem.height = Math.floor(collageH + beta);\n\t\t\t}\n\n\t\t\tfunction run() {\n\t\t\t\tvar startTime = new Date().getTime();\n\n\t\t\t\tphotoOriginalSizes = getOriginalSizes();\n\t\t\t\tif (photoOriginalSizes.length < 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tN = photoOriginalSizes.length;\n\t\t\t\tn = 2 * N - 1;\n\t\t\t\t//\n\t\t\t\tnPrime = 0;\n\t\t\t\tleafs = [];\n\t\t\t\tphotoCounter = 0;\n\t\t\t\trootNode = new Node();\n\n\t\t\t\tgetRandomTree(); // populate rootNode\n\t\t\t\ttraverseAndAssignData(rootNode); // assign data to nodes (H/V, p1,p2...pN)\n\n\t\t\t\t//treeStr = \"\";\n\t\t\t\t//nodeToString(rootNode); // populate treeStr\n\t\t\t\t//alert(treeStr);\n\n\t\t\t\ttraverseAndComputeBBPhotoNode(rootNode); // compute bounding box of terminal nodes (photos)\n\t\t\t\ttraverseAndComputeBBInteriorNode(rootNode); // compute bounding box of interior nodes\n\n\t\t\t\txVec = findAndSolveSytem(rootNode, \"constrainWidth\"); // // display result (solution vector containing the widths of each photos)\n\t\t\t\tif (!xVec) {\n\t\t\t\t\talert(\"no solution found !\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tuls = new Array(N); // upper left corner location of eah photos\n\t\t\t\trootNode.upperLeft = [sigma + beta, sigma + beta];\n\t\t\t\ttraverseAndComputeUpperLeft(rootNode);\n\n\t\t\t\t/*\n\t\t\t\tvar bestCoverage = 0;\n\t\t\t\tvar bestUls;\n\t\t\t\tvar bestXVec;\n\t\t\t\tvar masterIter = 0;\n\t\t\t\tvar mustRerun = false;\n\t\t\t\t\t\n\t\t\t\twhile ((masterIter++) < maxIters)\n\t\t\t\t{\n\t\t\t\t\tnPrime = 0;\n\t\t\t\t\tleafs = [];\n\t\t\t\t\tphotoCounter = 0;\n\t\t\t\t\trootNode = new Node();\n\t\t\t\t\t\t\n\t\t\t\t\tgetRandomTree(); // populate rootNode\n\t\t\t\t\ttraverseAndAssignData(rootNode); // assign data to nodes (H/V, p1,p2...pN)\n\t\t\t\t\t\t\n\t\t\t\t\t//treeStr = \"\";\n\t\t\t\t\t//nodeToString(rootNode); // populate treeStr\n\t\t\t\t\t//alert(treeStr);\n\t\t\t\t\t\n\t\t\t\t\ttraverseAndComputeBBPhotoNode(rootNode); // compute bounding box of terminal nodes (photos)\n\t\t\t\t\ttraverseAndComputeBBInteriorNode(rootNode); // compute bounding box of interior nodes\n\t\t\t\t\t\n\t\t\t\t\txVec = findAndSolveSytem(rootNode, \"constrainWidth\");// // display result (solution vector containing the widths of each photos)\n\t\t\t\t\tif (!xVec)\n\t\t\t\t\t{\n\t\t\t\t\t\talert(\"no sol !\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tuls = new Array(N); // upper left corner location of eah photos\n\t\t\t\t\trootNode.upperLeft = [sigma+beta, sigma+beta];\n\t\t\t\t\ttraverseAndComputeUpperLeft(rootNode);\n\t\t\t\t\t\n\t\t\t\t\tvar coverage = computeCoverage();\n\t\t\t\t\t//alert(\"initial coverage: \" + (100*coverage) + \"%\");\n\t\t\t\t\t\n\t\t\t\t\tvar delta = Math.abs(coverage - 1);\n\t\t\t\t\tvar bestDelta = Math.abs(bestCoverage - 1);\n\t\t\t\t\tif (delta < bestDelta)\n\t\t\t\t\t{\n\t\t\t\t\t\tbestRootNode = rootNode;\n\t\t\t\t\t\tbestCoverage = coverage;\n\t\t\t\t\t\tbestXVec = xVec;\n\t\t\t\t\t\tbestUls = uls;\n\t\t\t\t\t\t\n\t\t\t\t\t\twriteLn(\"masterIter: \" + (masterIter) + \" bestCoverage: \" + (100*coverage).toFixed(2) + \"%\");\n\t\t\t\t\t\n\t\t\t\t\t\tif (bestCoverage > 0.99 && bestCoverage < 1.01) // == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twriteLn(\"iters (break):\" + iter + \" coverage:\" + (100*coverage).toFixed(2) + \"%\");\n\t\t\t\t\t\t\t//alert(\"coverage reached 1, stop at iter \" + iter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//alert(\"masterIter: \" + masterIter + \" coverage: \" + (100*coverage).toFixed(2) + \"%\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\txVec = bestXVec;\n\t\t\t\tuls = bestUls;\n\t\t\t\twriteLn(\"masterIter:\" + masterIter + \" coverage:\" + (100*bestCoverage).toFixed(2) + \"%\");\n\t\t\t\t*/\n\t\t\t\tapp.beginUndoGroup(\"Collage\");\n\t\t\t\tscaleAndPositionLayers(xVec, uls); //(bestXVec,bestUls); \n\t\t\t\tif (fitComp) {\n\t\t\t\t\tfitCompToCollage(xVec, uls);\n\t\t\t\t}\n\t\t\t\tapp.endUndoGroup();\n\n\n\t\t\t\tvar endTime = new Date().getTime();\n\t\t\t\tvar executionTime = (endTime - startTime) / 1000.0;\n\t\t\t\t/*alert*/\n\t\t\t\twriteLn(\"Completed in \" + executionTime + \"s\");\n\t\t\t}\n\n\t\t\tfunction createUI(thisObj) {\n\t\t\t\tvar pal = (thisObj instanceof Panel) ? thisObj : new Window(\"palette\", \"Collage\", undefined, {\n\t\t\t\t\tresizeable: true\n\t\t\t\t});\n\n\t\t\t\tvar res =\n\t\t\t\t\t\"group { orientation:'column', alignment:['fill','fill'], alignChildren:['fill','fill'], \\\ngr1: Group { \\\n\taboutBtn: Button { text:'?', preferredSize:[25,20], alignment:['right','top'] } \\\n}, \\\ngr2: Group { orientation:'row', alignment:['fill','top'], \\\n\tborderSt: StaticText { text:'Border:' }, \\\n\tborderEt: EditText { alignment:['fill','top'], characters:5, text:'\" + beta + \"' } \\\n}, \\\ngr3: Group { alignment:['left','top'], \\\n\tfitCompCb: Checkbox { text:'Fit Comp to Collage', value:true } \\\n}, \\\ngr4: Group { alignment:['fill','top'], \\\n\tcreateBtn: Button { text:'Create', alignment:['fill','top'] } \\\n} \\\n}\";\n\t\t\t\tpal.gr = pal.add(res);\n\n\t\t\t\tvar aboutStr =\n\t\t\t\t\t\"Collage.jsx\\r\" +\n\t\t\t\t\t\"Copyright (c) 2012 Motion Boutique\\r\\r\" +\n\t\t\t\t\t\"Layout selected layers in a collage or photobook style. \" +\n\t\t\t\t\t\"Layers are arranged to fit in a rectangle area (with same width as the comp) while maintainig their aspect ratio. \" +\n\t\t\t\t\t\"You can specify a border in pixels around each layer.\";\n\n\t\t\t\tpal.onResize = pal.onResizing = function() {\n\t\t\t\t\tthis.layout.resize();\n\t\t\t\t};\n\t\t\t\tpal.gr.gr1.aboutBtn.onClick = function() {\n\t\t\t\t\talert(aboutStr);\n\t\t\t\t};\n\t\t\t\tpal.gr.gr2.borderEt.onChange = function() {\n\t\t\t\t\tbeta = parseFloat(this.text);\n\t\t\t\t};\n\t\t\t\tpal.gr.gr3.fitCompCb.onClick = function() {\n\t\t\t\t\tfitComp = this.value;\n\t\t\t\t};\n\t\t\t\tpal.gr.gr4.createBtn.onClick = function() {\n\t\t\t\t\trun();\n\t\t\t\t};\n\n\t\t\t\t// show user interface\n\t\t\t\tif (pal instanceof Window) {\n\t\t\t\t\tpal.center();\n\t\t\t\t\tpal.show();\n\t\t\t\t} else {\n\t\t\t\t\tpal.layout.layout(true);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tvar W;\n\t\t\tvar H;\n\t\t\tvar photoOriginalSizes;\n\t\t\tvar N;\n\t\t\tvar beta = borderSize; //5; // photo border\n\t\t\tvar sigma = 0; //10; // space between photos\n\t\t\t//var maxIters = 10;\n\t\t\tvar fitComp = fitToComp;\n\t\t\tvar n;\n\t\t\tvar leafs;\n\t\t\tvar nPrime;\n\t\t\tvar treeStr;\n\t\t\tvar photoCounter;\n\t\t\tvar rootNode;\n\t\t\tvar xVec;\n\t\t\tvar uls;\n\t\t\tvar collageW;\n\t\t\tvar collageH;\n\n\t\t// \tcreateUI(this);\n\n\n\t\t\t// numericjs\n\t\t\tvar numeric = (typeof exports === \"undefined\") ? (function numeric() {}) : (exports);\n\t\t\tif (typeof global !== \"undefined\") {\n\t\t\t\tglobal.numeric = numeric;\n\t\t\t}\n\n\t\t\tnumeric.version = \"1.2.2\";\n\n\t\t\t// 1. Utility functions\n\t\t\tnumeric.bench = function bench(f, interval) {\n\t\t\t\tvar t1, t2, n, i;\n\t\t\t\tif (typeof interval === \"undefined\") {\n\t\t\t\t\tinterval = 15;\n\t\t\t\t}\n\t\t\t\tn = 1;\n\t\t\t\tt1 = new Date();\n\t\t\t\twhile (1) {\n\t\t\t\t\tn *= 2;\n\t\t\t\t\tfor (i = n; i > 3; i -= 4) {\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tf();\n\t\t\t\t\t}\n\t\t\t\t\twhile (i > 0) {\n\t\t\t\t\t\tf();\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tt2 = new Date();\n\t\t\t\t\tif (t2 - t1 > interval) break;\n\t\t\t\t}\n\t\t\t\tfor (i = n; i > 3; i -= 4) {\n\t\t\t\t\tf();\n\t\t\t\t\tf();\n\t\t\t\t\tf();\n\t\t\t\t\tf();\n\t\t\t\t}\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\tf();\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tt2 = new Date();\n\t\t\t\treturn 1000 * (3 * n - 1) / (t2 - t1);\n\t\t\t};\n\n\t\t\t/* \n\t\t\t * IE doesn't have a global eval that works?\n\t\t\t * This apparently returns nothing: window.execScript('function () {}').            \n\t\t\t * Other things that don't work: window.execScript('foo = eval(\"function () {}\");')\n\t\t\t */\n\t\t\tif (1 || typeof window === \"undefined\" || typeof window.execScript !== \"undefined\") numeric.Function = Function;\n\t\t\telse numeric.Function = function() {\n\t\t\t\tvar foo = '(function (';\n\t\t\t\tfor (var k = 0; k < arguments.length - 1; ++k) {\n\t\t\t\t\tif (k > 0) foo += ',';\n\t\t\t\t\tfoo += arguments[k];\n\t\t\t\t}\n\t\t\t\tfoo += ') { \\n' + arguments[k] + '\\n});';\n\t\t\t\treturn window.eval(foo);\n\t\t\t};\n\n\t\t\tnumeric.precision = 4;\n\t\t\tnumeric.largeArray = 50;\n\n\t\t\tnumeric.prettyPrint = function prettyPrint(x) {\n\t\t\t\tfunction fmtnum(x) {\n\t\t\t\t\tif (x === 0) {\n\t\t\t\t\t\treturn '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\treturn 'NaN';\n\t\t\t\t\t}\n\t\t\t\t\tif (x < 0) {\n\t\t\t\t\t\treturn '-' + fmtnum(-x);\n\t\t\t\t\t}\n\t\t\t\t\tif (isFinite(x)) {\n\t\t\t\t\t\tvar scale = Math.floor(Math.log(x) / Math.log(10));\n\t\t\t\t\t\tvar normalized = x / Math.pow(10, scale);\n\t\t\t\t\t\tvar basic = normalized.toPrecision(numeric.precision);\n\t\t\t\t\t\tif (parseFloat(basic) === 10) {\n\t\t\t\t\t\t\tscale++;\n\t\t\t\t\t\t\tnormalized = 1;\n\t\t\t\t\t\t\tbasic = normalized.toPrecision(numeric.precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn parseFloat(basic).toString() + 'e' + scale.toString();\n\t\t\t\t\t}\n\t\t\t\t\treturn 'Infinity';\n\t\t\t\t}\n\t\t\t\tvar ret = [];\n\n\t\t\t\tfunction foo(x) {\n\t\t\t\t\tvar k;\n\t\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\t\tret.push(Array(numeric.precision + 8).join(' '));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"string\") {\n\t\t\t\t\t\tret.push('\"' + x + '\"');\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"boolean\") {\n\t\t\t\t\t\tret.push(x.toString());\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"number\") {\n\t\t\t\t\t\tvar a = fmtnum(x);\n\t\t\t\t\t\tvar b = x.toPrecision(numeric.precision);\n\t\t\t\t\t\tvar c = parseFloat(x.toString()).toString();\n\t\t\t\t\t\tvar d = [a, b, c, parseFloat(b).toString(), parseFloat(c).toString()];\n\t\t\t\t\t\tfor (k = 1; k < d.length; k++) {\n\t\t\t\t\t\t\tif (d[k].length < a.length) a = d[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret.push(Array(numeric.precision + 8 - a.length).join(' ') + a);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (x === null) {\n\t\t\t\t\t\tret.push(\"null\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x === \"function\") {\n\t\t\t\t\t\tret.push(x.toString());\n\t\t\t\t\t\tvar flag = false;\n\t\t\t\t\t\tfor (k in x) {\n\t\t\t\t\t\t\tif (x.hasOwnProperty(k)) {\n\t\t\t\t\t\t\t\tif (flag) ret.push(',\\n');\n\t\t\t\t\t\t\t\telse ret.push('\\n{');\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tret.push(k);\n\t\t\t\t\t\t\t\tret.push(': \\n');\n\t\t\t\t\t\t\t\tfoo(x[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) ret.push('}\\n');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (x instanceof Array) {\n\t\t\t\t\t\tif (x.length > numeric.largeArray) {\n\t\t\t\t\t\t\tret.push('...Large Array...');\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar flag = false;\n\t\t\t\t\t\tret.push('[');\n\t\t\t\t\t\tfor (k = 0; k < x.length; k++) {\n\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\tret.push(',');\n\t\t\t\t\t\t\t\tif (flag) ret.push('\\n ');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = foo(x[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret.push(']');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tret.push('{');\n\t\t\t\t\tvar flag = false;\n\t\t\t\t\tfor (k in x) {\n\t\t\t\t\t\tif (x.hasOwnProperty(k)) {\n\t\t\t\t\t\t\tif (flag) ret.push(',\\n');\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tret.push(k);\n\t\t\t\t\t\t\tret.push(': \\n');\n\t\t\t\t\t\t\tfoo(x[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret.push('}');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfoo(x);\n\t\t\t\treturn ret.join('');\n\t\t\t};\n\n\t\t\tnumeric.parseDate = function parseDate(d) {\n\t\t\t\tfunction foo(d) {\n\t\t\t\t\tif (typeof d === 'string') {\n\t\t\t\t\t\treturn Date.parse(d.replace(/-/g, '/'));\n\t\t\t\t\t}\n\t\t\t\t\tif (!(d instanceof Array)) {\n\t\t\t\t\t\tthrow new Error(\"parseDate: parameter must be arrays of strings\");\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\tk;\n\t\t\t\t\tfor (k = 0; k < d.length; k++) {\n\t\t\t\t\t\tret[k] = foo(d[k]);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn foo(d);\n\t\t\t};\n\n\t\t\tnumeric.parseFloat = function parseFloat_(d) {\n\t\t\t\tfunction foo(d) {\n\t\t\t\t\tif (typeof d === 'string') {\n\t\t\t\t\t\treturn parseFloat(d);\n\t\t\t\t\t}\n\t\t\t\t\tif (!(d instanceof Array)) {\n\t\t\t\t\t\tthrow new Error(\"parseFloat: parameter must be arrays of strings\");\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\tk;\n\t\t\t\t\tfor (k = 0; k < d.length; k++) {\n\t\t\t\t\t\tret[k] = foo(d[k]);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn foo(d);\n\t\t\t};\n\n\t\t\tnumeric.parseCSV = function parseCSV(t) {\n\t\t\t\tvar foo = t.split('\\n');\n\t\t\t\tvar j, k;\n\t\t\t\tvar ret = [];\n\t\t\t\tvar pat = /(([^'\",]*)|('[^']*')|(\"[^\"]*\")),/g;\n\t\t\t\tvar patnum = /^\\s*(([+-]?[0-9]+(\\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\\.[0-9]+)?(e[+-]?[0-9]+)?))\\s*$/;\n\t\t\t\tvar stripper = function(n) {\n\t\t\t\t\treturn n.substr(0, n.length - 1);\n\t\t\t\t};\n\t\t\t\tvar count = 0;\n\t\t\t\tfor (k = 0; k < foo.length; k++) {\n\t\t\t\t\tvar bar = (foo[k] + \",\").match(pat),\n\t\t\t\t\t\tbaz;\n\t\t\t\t\tif (bar.length > 0) {\n\t\t\t\t\t\tret[count] = [];\n\t\t\t\t\t\tfor (j = 0; j < bar.length; j++) {\n\t\t\t\t\t\t\tbaz = stripper(bar[j]);\n\t\t\t\t\t\t\tif (patnum.test(baz)) {\n\t\t\t\t\t\t\t\tret[count][j] = parseFloat(baz);\n\t\t\t\t\t\t\t} else ret[count][j] = baz;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.toCSV = function toCSV(A) {\n\t\t\t\tvar s = numeric.dim(A);\n\t\t\t\tvar i, j, m, n, row, ret;\n\t\t\t\tm = s[0];\n\t\t\t\tn = s[1];\n\t\t\t\tret = [];\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\trow = [];\n\t\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\t\trow[j] = A[i][j].toString();\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = row.join(', ');\n\t\t\t\t}\n\t\t\t\treturn ret.join('\\n') + '\\n';\n\t\t\t};\n\n\t\t\tnumeric.getURL = function getURL(url) {\n\t\t\t\tvar client = new XMLHttpRequest();\n\t\t\t\tclient.open(\"GET\", url, false);\n\t\t\t\tclient.send();\n\t\t\t\treturn client;\n\t\t\t};\n\n\t\t\tnumeric.imageURL = function imageURL(img) {\n\t\t\t\tfunction base64(A) {\n\t\t\t\t\tvar n = A.length,\n\t\t\t\t\t\ti, x, y, z, p, q, r, s;\n\t\t\t\t\tvar key = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\t\t\t\t\tvar ret = \"\";\n\t\t\t\t\tfor (i = 0; i < n; i += 3) {\n\t\t\t\t\t\tx = A[i];\n\t\t\t\t\t\ty = A[i + 1];\n\t\t\t\t\t\tz = A[i + 2];\n\t\t\t\t\t\tp = x >> 2;\n\t\t\t\t\t\tq = ((x & 3) << 4) + (y >> 4);\n\t\t\t\t\t\tr = ((y & 15) << 2) + (z >> 6);\n\t\t\t\t\t\ts = z & 63;\n\t\t\t\t\t\tif (i + 1 >= n) {\n\t\t\t\t\t\t\tr = s = 64;\n\t\t\t\t\t\t} else if (i + 2 >= n) {\n\t\t\t\t\t\t\ts = 64;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tfunction crc32Array(a, from, to) {\n\t\t\t\t\tif (typeof from === \"undefined\") {\n\t\t\t\t\t\tfrom = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof to === \"undefined\") {\n\t\t\t\t\t\tto = a.length;\n\t\t\t\t\t}\n\t\t\t\t\tvar table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n\t\t\t\t\t\t0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n\t\t\t\t\t\t0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n\t\t\t\t\t\t0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n\t\t\t\t\t\t0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n\t\t\t\t\t\t0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n\t\t\t\t\t\t0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n\t\t\t\t\t\t0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n\t\t\t\t\t\t0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n\t\t\t\t\t\t0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n\t\t\t\t\t\t0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n\t\t\t\t\t\t0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n\t\t\t\t\t\t0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n\t\t\t\t\t\t0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n\t\t\t\t\t\t0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n\t\t\t\t\t\t0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n\t\t\t\t\t\t0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n\t\t\t\t\t\t0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n\t\t\t\t\t\t0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n\t\t\t\t\t\t0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n\t\t\t\t\t\t0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n\t\t\t\t\t\t0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n\t\t\t\t\t\t0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n\t\t\t\t\t\t0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n\t\t\t\t\t\t0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n\t\t\t\t\t\t0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n\t\t\t\t\t\t0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n\t\t\t\t\t\t0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n\t\t\t\t\t\t0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n\t\t\t\t\t\t0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n\t\t\t\t\t\t0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n\t\t\t\t\t\t0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n\t\t\t\t\t];\n\n\t\t\t\t\tvar crc = -1,\n\t\t\t\t\t\ty = 0,\n\t\t\t\t\t\tn = a.length,\n\t\t\t\t\t\ti;\n\n\t\t\t\t\tfor (i = from; i < to; i++) {\n\t\t\t\t\t\ty = (crc ^ a[i]) & 0xFF;\n\t\t\t\t\t\tcrc = (crc >>> 8) ^ table[y];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn crc ^ (-1);\n\t\t\t\t}\n\n\t\t\t\tvar h = img[0].length,\n\t\t\t\t\tw = img[0][0].length,\n\t\t\t\t\ts1, s2, next, k, length, a, b, i, j, adler32, crc32;\n\t\t\t\tvar stream = [\n\t\t\t\t\t137, 80, 78, 71, 13, 10, 26, 10, //  0: PNG signature\n\t\t\t\t\t0, 0, 0, 13, //  8: IHDR Chunk length\n\t\t\t\t\t73, 72, 68, 82, // 12: \"IHDR\" \n\t\t\t\t\t(w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255, // 16: Width\n\t\t\t\t\t(h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h & 255, // 20: Height\n\t\t\t\t\t8, // 24: bit depth\n\t\t\t\t\t2, // 25: RGB\n\t\t\t\t\t0, // 26: deflate\n\t\t\t\t\t0, // 27: no filter\n\t\t\t\t\t0, // 28: no interlace\n\t\t\t\t\t-1, -2, -3, -4, // 29: CRC\n\t\t\t\t\t-5, -6, -7, -8, // 33: IDAT Chunk length\n\t\t\t\t\t73, 68, 65, 84, // 37: \"IDAT\"\n\t\t\t\t\t// RFC 1950 header starts here\n\t\t\t\t\t8, // 41: RFC1950 CMF\n\t\t\t\t\t29 // 42: RFC1950 FLG\n\t\t\t\t];\n\t\t\t\tcrc32 = crc32Array(stream, 12, 29);\n\t\t\t\tstream[29] = (crc32 >> 24) & 255;\n\t\t\t\tstream[30] = (crc32 >> 16) & 255;\n\t\t\t\tstream[31] = (crc32 >> 8) & 255;\n\t\t\t\tstream[32] = (crc32) & 255;\n\t\t\t\ts1 = 1;\n\t\t\t\ts2 = 0;\n\t\t\t\tfor (i = 0; i < h; i++) {\n\t\t\t\t\tif (i < h - 1) {\n\t\t\t\t\t\tstream.push(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstream.push(1);\n\t\t\t\t\t}\n\t\t\t\t\ta = (3 * w + 1 + (i === 0)) & 255;\n\t\t\t\t\tb = ((3 * w + 1 + (i === 0)) >> 8) & 255;\n\t\t\t\t\tstream.push(a);\n\t\t\t\t\tstream.push(b);\n\t\t\t\t\tstream.push((~a) & 255);\n\t\t\t\t\tstream.push((~b) & 255);\n\t\t\t\t\tif (i === 0) stream.push(0);\n\t\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\t\tfor (k = 0; k < 3; k++) {\n\t\t\t\t\t\t\ta = img[k][i][j];\n\t\t\t\t\t\t\tif (a > 255) a = 255;\n\t\t\t\t\t\t\telse if (a < 0) a = 0;\n\t\t\t\t\t\t\telse a = Math.round(a);\n\t\t\t\t\t\t\ts1 = (s1 + a) % 65521;\n\t\t\t\t\t\t\ts2 = (s2 + s1) % 65521;\n\t\t\t\t\t\t\tstream.push(a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstream.push(0);\n\t\t\t\t}\n\t\t\t\tadler32 = (s2 << 16) + s1;\n\t\t\t\tstream.push((adler32 >> 24) & 255);\n\t\t\t\tstream.push((adler32 >> 16) & 255);\n\t\t\t\tstream.push((adler32 >> 8) & 255);\n\t\t\t\tstream.push((adler32) & 255);\n\t\t\t\tlength = stream.length - 41;\n\t\t\t\tstream[33] = (length >> 24) & 255;\n\t\t\t\tstream[34] = (length >> 16) & 255;\n\t\t\t\tstream[35] = (length >> 8) & 255;\n\t\t\t\tstream[36] = (length) & 255;\n\t\t\t\tcrc32 = crc32Array(stream, 37);\n\t\t\t\tstream.push((crc32 >> 24) & 255);\n\t\t\t\tstream.push((crc32 >> 16) & 255);\n\t\t\t\tstream.push((crc32 >> 8) & 255);\n\t\t\t\tstream.push((crc32) & 255);\n\t\t\t\tstream.push(0);\n\t\t\t\tstream.push(0);\n\t\t\t\tstream.push(0);\n\t\t\t\tstream.push(0);\n\t\t\t\t//    a = stream.length;\n\t\t\t\tstream.push(73); // I\n\t\t\t\tstream.push(69); // E\n\t\t\t\tstream.push(78); // N\n\t\t\t\tstream.push(68); // D\n\t\t\t\tstream.push(174); // CRC1\n\t\t\t\tstream.push(66); // CRC2\n\t\t\t\tstream.push(96); // CRC3\n\t\t\t\tstream.push(130); // CRC4\n\t\t\t\treturn 'data:image/png;base64,' + base64(stream);\n\t\t\t};\n\n\t\t\t// 2. Linear algebra with Arrays.\n\t\t\tnumeric._dim = function _dim(x) {\n\t\t\t\tvar ret = [];\n\t\t\t\twhile (typeof x === \"object\") {\n\t\t\t\t\tret.push(x.length);\n\t\t\t\t\tx = x[0];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dim = function dim(x) {\n\t\t\t\tvar y, z;\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\ty = x[0];\n\t\t\t\t\tif (typeof y === \"object\") {\n\t\t\t\t\t\tz = y[0];\n\t\t\t\t\t\tif (typeof z === \"object\") {\n\t\t\t\t\t\t\treturn numeric._dim(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [x.length, y.length];\n\t\t\t\t\t}\n\t\t\t\t\treturn [x.length];\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t};\n\n\t\t\tnumeric.mapreduce = function mapreduce(body, init) {\n\t\t\t\treturn numeric.Function('x', 'accum', '_s', '_k',\n\t\t\t\t\t'if(typeof accum === \"undefined\") accum = ' + init + ';\\n' +\n\t\t\t\t\t'if(typeof x === \"number\") { var xi = x; ' + body + '; return accum; }\\n' +\n\t\t\t\t\t'if(typeof _s === \"undefined\") _s = numeric.dim(x);\\n' +\n\t\t\t\t\t'if(typeof _k === \"undefined\") _k = 0;\\n' +\n\t\t\t\t\t'var _n = _s[_k];\\n' +\n\t\t\t\t\t'var i,xi;\\n' +\n\t\t\t\t\t'if(_k < _s.length-1) {\\n' +\n\t\t\t\t\t'    for(i=_n-1;i>=0;i--) {\\n' +\n\t\t\t\t\t'        accum = arguments.callee(x[i],accum,_s,_k+1);\\n' +\n\t\t\t\t\t'    }' +\n\t\t\t\t\t'    return accum;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'for(i=_n-1;i>=1;i-=2) { \\n' +\n\t\t\t\t\t'    xi = x[i];\\n' +\n\t\t\t\t\t'    ' + body + ';\\n' +\n\t\t\t\t\t'    xi = x[i-1];\\n' +\n\t\t\t\t\t'    ' + body + ';\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'if(i === 0) {\\n' +\n\t\t\t\t\t'    xi = x[i];\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return accum;'\n\t\t\t\t);\n\t\t\t};\n\n\n\t\t\tnumeric.same = function same(x, y) {\n\t\t\t\tvar i, n;\n\t\t\t\tif (!(x instanceof Array) || !(y instanceof Array)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tn = x.length;\n\t\t\t\tif (n !== y.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tif (x[i] === y[i]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof x[i] === \"object\") {\n\t\t\t\t\t\tif (!same(x[i], y[i])) return false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tnumeric.rep = function rep(s, v, k) {\n\t\t\t\tif (typeof k === \"undefined\") {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tvar n = s[k],\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\ti;\n\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\tfor (i = n - 2; i >= 0; i -= 2) {\n\t\t\t\t\t\tret[i + 1] = v;\n\t\t\t\t\t\tret[i] = v;\n\t\t\t\t\t}\n\t\t\t\t\tif (i === -1) {\n\t\t\t\t\t\tret[0] = v;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\t\t\tret[i] = numeric.rep(s, v, k + 1);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\n\t\t\tnumeric.dotMMsmall = function dotMMsmall(x, y) {\n\t\t\t\tvar i, j, k, p, q, r, ret, foo, bar, woo, i0, k0, p0, r0;\n\t\t\t\tp = x.length;\n\t\t\t\tq = y.length;\n\t\t\t\tr = y[0].length;\n\t\t\t\tret = Array(p);\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\tfoo = Array(r);\n\t\t\t\t\tbar = x[i];\n\t\t\t\t\tfor (k = r - 1; k >= 0; k--) {\n\t\t\t\t\t\twoo = bar[q - 1] * y[q - 1][k];\n\t\t\t\t\t\tfor (j = q - 2; j >= 1; j -= 2) {\n\t\t\t\t\t\t\ti0 = j - 1;\n\t\t\t\t\t\t\twoo += bar[j] * y[j][k] + bar[i0] * y[i0][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\t\twoo += bar[0] * y[0][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoo[k] = woo;\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = foo;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric._getCol = function _getCol(A, j, x) {\n\t\t\t\tvar n = A.length,\n\t\t\t\t\ti;\n\t\t\t\tfor (i = n - 1; i > 0; --i) {\n\t\t\t\t\tx[i] = A[i][j];\n\t\t\t\t\t--i;\n\t\t\t\t\tx[i] = A[i][j];\n\t\t\t\t}\n\t\t\t\tif (i === 0) x[0] = A[0][j];\n\t\t\t};\n\t\t\tnumeric.dotMMbig = function dotMMbig(x, y) {\n\t\t\t\tvar gc = numeric._getCol,\n\t\t\t\t\tp = y.length,\n\t\t\t\t\tv = Array(p);\n\t\t\t\tvar m = x.length,\n\t\t\t\t\tn = y[0].length,\n\t\t\t\t\tA = new Array(m),\n\t\t\t\t\txj;\n\t\t\t\tvar i, j, k, z;\n\t\t\t\t--p;\n\t\t\t\t--m;\n\t\t\t\tfor (i = m; i !== -1; --i) A[i] = Array(n);\n\t\t\t\t--n;\n\t\t\t\tfor (i = n; i !== -1; --i) {\n\t\t\t\t\tgc(y, i, v);\n\t\t\t\t\tfor (j = m; j !== -1; --j) {\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\txj = x[j];\n\t\t\t\t\t\tfor (k = p; k > 0; --k) {\n\t\t\t\t\t\t\tz += xj[k] * v[k];\n\t\t\t\t\t\t\t--k;\n\t\t\t\t\t\t\tz += xj[k] * v[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k === 0) z += xj[0] * v[0];\n\t\t\t\t\t\tA[j][i] = z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\n\t\t\tnumeric.dotMV = function dotMV(x, y) {\n\t\t\t\tvar p = x.length,\n\t\t\t\t\tq = y.length,\n\t\t\t\t\ti;\n\t\t\t\tvar ret = Array(p),\n\t\t\t\t\tdotVV = numeric.dotVV;\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\tret[i] = dotVV(x[i], y);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dotVM = function dotVM(x, y) {\n\t\t\t\tvar i, j, k, p, q, r, ret, foo, bar, woo, i0, k0, p0, r0, s1, s2, s3, baz, accum;\n\t\t\t\tp = x.length;\n\t\t\t\tq = y[0].length;\n\t\t\t\tret = Array(q);\n\t\t\t\tfor (k = q - 1; k >= 0; k--) {\n\t\t\t\t\twoo = x[p - 1] * y[p - 1][k];\n\t\t\t\t\tfor (j = p - 2; j >= 1; j -= 2) {\n\t\t\t\t\t\ti0 = j - 1;\n\t\t\t\t\t\twoo += x[j] * y[j][k] + x[i0] * y[i0][k];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\twoo += x[0] * y[0][k];\n\t\t\t\t\t}\n\t\t\t\t\tret[k] = woo;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dotVV = function dotVV(x, y) {\n\t\t\t\tvar i, n = x.length,\n\t\t\t\t\ti1, ret = x[n - 1] * y[n - 1];\n\t\t\t\tfor (i = n - 2; i >= 1; i -= 2) {\n\t\t\t\t\ti1 = i - 1;\n\t\t\t\t\tret += x[i] * y[i] + x[i1] * y[i1];\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tret += x[0] * y[0];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.dot = function dot(x, y) {\n\t\t\t\tvar d = numeric.dim;\n\t\t\t\tswitch (d(x).length * 1000 + d(y).length) {\n\t\t\t\t\tcase 2002:\n\t\t\t\t\t\tif (y.length < 10) return numeric.dotMMsmall(x, y);\n\t\t\t\t\t\telse return numeric.dotMMbig(x, y);\n\t\t\t\t\tcase 2001:\n\t\t\t\t\t\treturn numeric.dotMV(x, y);\n\t\t\t\t\tcase 1002:\n\t\t\t\t\t\treturn numeric.dotVM(x, y);\n\t\t\t\t\tcase 1001:\n\t\t\t\t\t\treturn numeric.dotVV(x, y);\n\t\t\t\t\tcase 1000:\n\t\t\t\t\t\treturn numeric.mulVS(x, y);\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn numeric.mulSV(x, y);\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn x * y;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('numeric.dot only works on vectors and matrices');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnumeric.diag = function diag(d) {\n\t\t\t\tvar i, i1, j, n = d.length,\n\t\t\t\t\tA = Array(n),\n\t\t\t\t\tAi;\n\t\t\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\t\t\tAi = Array(n);\n\t\t\t\t\ti1 = i + 2;\n\t\t\t\t\tfor (j = n - 1; j >= i1; j -= 2) {\n\t\t\t\t\t\tAi[j] = 0;\n\t\t\t\t\t\tAi[j - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (j > i) {\n\t\t\t\t\t\tAi[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tAi[i] = d[i];\n\t\t\t\t\tfor (j = i - 1; j >= 1; j -= 2) {\n\t\t\t\t\t\tAi[j] = 0;\n\t\t\t\t\t\tAi[j - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tAi[0] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tA[i] = Ai;\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\t\t\tnumeric.getDiag = function(A) {\n\t\t\t\tvar n = Math.min(A.length, A[0].length),\n\t\t\t\t\ti, ret = Array(n);\n\t\t\t\tfor (i = n - 1; i >= 1; --i) {\n\t\t\t\t\tret[i] = A[i][i];\n\t\t\t\t\t--i;\n\t\t\t\t\tret[i] = A[i][i];\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tret[0] = A[0][0];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.identity = function identity(n) {\n\t\t\t\treturn numeric.diag(numeric.rep([n], 1));\n\t\t\t};\n\t\t\tnumeric.pointwise = function pointwise(params, body, setup) {\n\t\t\t\tif (typeof setup === \"undefined\") {\n\t\t\t\t\tsetup = \"\";\n\t\t\t\t}\n\t\t\t\tvar fun = [];\n\t\t\t\tvar k;\n\t\t\t\tvar avec = /\\[i\\]$/,\n\t\t\t\t\tp, thevec = '';\n\t\t\t\tfor (k = 0; k < params.length; k++) {\n\t\t\t\t\tif (avec.test(params[k])) {\n\t\t\t\t\t\tp = params[k].substring(0, params[k].length - 3);\n\t\t\t\t\t\tthevec = p;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = params[k];\n\t\t\t\t\t}\n\t\t\t\t\tfun.push(p);\n\t\t\t\t}\n\t\t\t\tfun[params.length] = '_s';\n\t\t\t\tfun[params.length + 1] = '_k';\n\t\t\t\tfun[params.length + 2] = (\n\t\t\t\t\t'if(typeof _s === \"undefined\") _s = numeric.dim(' + thevec + ');\\n' +\n\t\t\t\t\t'if(typeof _k === \"undefined\") _k = 0;\\n' +\n\t\t\t\t\t'var _n = _s[_k];\\n' +\n\t\t\t\t\t'var i, ret = Array(_n);\\n' +\n\t\t\t\t\t'if(_k < _s.length-1) {\\n' +\n\t\t\t\t\t'    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(' + params.join(',') + ',_s,_k+1);\\n' +\n\t\t\t\t\t'    return ret;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\tsetup + '\\n' +\n\t\t\t\t\t'for(i=_n-1;i>=3;--i) { \\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'while(i>=0) {\\n' +\n\t\t\t\t\t'    ' + body + '\\n' +\n\t\t\t\t\t'    --i;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return ret;'\n\t\t\t\t);\n\t\t\t\treturn numeric.Function.apply(null, fun);\n\t\t\t};\n\n\t\t\tnumeric._biforeach = (function _biforeach(x, y, s, k, f) {\n\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\tf(x, y);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar i, n = s[k];\n\t\t\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\t\t\t_biforeach(x[i], y[i], s, k + 1, f);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tnumeric.anyV = numeric.mapreduce('if(xi) return true;', 'false');\n\t\t\tnumeric.allV = numeric.mapreduce('if(!xi) return false;', 'true');\n\t\t\tnumeric.any = function(x) {\n\t\t\t\tif (typeof x.length === \"undefined\") return x;\n\t\t\t\treturn numeric.anyV(x);\n\t\t\t};\n\t\t\tnumeric.all = function(x) {\n\t\t\t\tif (typeof x.length === \"undefined\") return x;\n\t\t\t\treturn numeric.allV(x);\n\t\t\t};\n\n\t\t\tnumeric.ops2 = {\n\t\t\t\tadd: '+',\n\t\t\t\tsub: '-',\n\t\t\t\tmul: '*',\n\t\t\t\tdiv: '/',\n\t\t\t\tmod: '%',\n\t\t\t\tand: '&&',\n\t\t\t\tor: '||',\n\t\t\t\teq: '===',\n\t\t\t\tneq: '!==',\n\t\t\t\tlt: '<',\n\t\t\t\tgt: '>',\n\t\t\t\tleq: '<=',\n\t\t\t\tgeq: '>=',\n\t\t\t\tband: '&',\n\t\t\t\tbor: '|',\n\t\t\t\tbxor: '^',\n\t\t\t\tlshift: '<<',\n\t\t\t\trshift: '>>',\n\t\t\t\trrshift: '>>>'\n\t\t\t};\n\t\t\tnumeric.opseq = {\n\t\t\t\taddeq: '+=',\n\t\t\t\tsubeq: '-=',\n\t\t\t\tmuleq: '*=',\n\t\t\t\tdiveq: '/=',\n\t\t\t\tmodeq: '%=',\n\t\t\t\tlshifteq: '<<=',\n\t\t\t\trshifteq: '>>=',\n\t\t\t\trrshifteq: '>>>=',\n\t\t\t\tandeq: '&=',\n\t\t\t\toreq: '|=',\n\t\t\t\txoreq: '^='\n\t\t\t};\n\t\t\tnumeric.mathfuns = ['abs', 'acos', 'asin', 'atan', 'ceil', 'cos',\n\t\t\t\t'exp', 'floor', 'log', 'round', 'sin', 'sqrt', 'tan'\n\t\t\t];\n\t\t\tnumeric.ops1 = {\n\t\t\t\tneg: '-',\n\t\t\t\tnot: '!',\n\t\t\t\tbnot: '~'\n\t\t\t};\n\n\t\t\t(function() {\n\t\t\t\tvar i, o;\n\t\t\t\tfor (i in numeric.ops2) {\n\t\t\t\t\tif (numeric.ops2.hasOwnProperty(i)) {\n\t\t\t\t\t\to = numeric.ops2[i];\n\t\t\t\t\t\tnumeric[i + 'VV'] = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = x[i] ' + o + ' y[i];');\n\t\t\t\t\t\tnumeric[i + 'SV'] = numeric.pointwise(['x', 'y[i]'], 'ret[i] = x ' + o + ' y[i];');\n\t\t\t\t\t\tnumeric[i + 'VS'] = numeric.pointwise(['x[i]', 'y'], 'ret[i] = x[i] ' + o + ' y;');\n\t\t\t\t\t\tnumeric[i] = numeric.Function(\n\t\t\t\t\t\t\t'var n = arguments.length, i, x = arguments[0], y;\\n' +\n\t\t\t\t\t\t\t'var VV = numeric.' + i + 'VV, VS = numeric.' + i + 'VS, SV = numeric.' + i + 'SV;\\n' +\n\t\t\t\t\t\t\t'for(i=1;i!==n;++i) { \\n' +\n\t\t\t\t\t\t\t'  y = arguments[i];' +\n\t\t\t\t\t\t\t'  if(typeof x === \"object\") {\\n' +\n\t\t\t\t\t\t\t'      if(typeof y === \"object\") x = VV(x,y);\\n' +\n\t\t\t\t\t\t\t'      else x = VS(x,y);\\n' +\n\t\t\t\t\t\t\t'  } else if(typeof y === \"object\") x = SV(x,y);\\n' +\n\t\t\t\t\t\t\t'  else x = x ' + o + ' y;\\n' +\n\t\t\t\t\t\t\t'}\\nreturn x;\\n');\n\t\t\t\t\t\tnumeric[o] = numeric[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i in numeric.ops1) {\n\t\t\t\t\tif (numeric.ops1.hasOwnProperty(i)) {\n\t\t\t\t\t\to = numeric.ops1[i];\n\t\t\t\t\t\tnumeric[i + 'V'] = numeric.pointwise(['x[i]'], 'ret[i] = ' + o + 'x[i];');\n\t\t\t\t\t\tnumeric[i] = numeric.Function('x', 'if(typeof x === \"object\") return numeric.' + i + 'V(x);\\nreturn ' + o + '(x);');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < numeric.mathfuns.length; i++) {\n\t\t\t\t\to = numeric.mathfuns[i];\n\t\t\t\t\tnumeric[o + 'V'] = numeric.pointwise(['x[i]'], 'ret[i] = fun(x[i]);', 'var fun = Math.' + o + ';');\n\t\t\t\t\tnumeric[o] = numeric.Function('x', 'if(typeof x === \"object\") return numeric.' + o + 'V(x);\\nreturn Math.' + o + '(x);');\n\t\t\t\t}\n\t\t\t\tnumeric.isNaNV = numeric.pointwise(['x[i]'], 'ret[i] = isNaN(x[i]);');\n\t\t\t\tnumeric.isNaN = function isNaN(x) {\n\t\t\t\t\tif (typeof x === \"object\") return numeric.isNaNV(x);\n\t\t\t\t\treturn isNaN(x);\n\t\t\t\t};\n\t\t\t\tnumeric.isFiniteV = numeric.pointwise(['x[i]'], 'ret[i] = isFinite(x[i]);');\n\t\t\t\tnumeric.isFinite = function isNaN(x) {\n\t\t\t\t\tif (typeof x === \"object\") return numeric.isFiniteV(x);\n\t\t\t\t\treturn isFinite(x);\n\t\t\t\t};\n\t\t\t\tfor (i in numeric.opseq) {\n\t\t\t\t\tif (numeric.opseq.hasOwnProperty(i)) {\n\t\t\t\t\t\tnumeric[i + 'S'] = numeric.Function('x', 'y',\n\t\t\t\t\t\t\t'var n = x.length, i;\\n' +\n\t\t\t\t\t\t\t'for(i=n-1;i>=0;i--) x[i] ' + numeric.opseq[i] + ' y;');\n\t\t\t\t\t\tnumeric[i + 'V'] = numeric.Function('x', 'y',\n\t\t\t\t\t\t\t'var n = x.length, i;\\n' +\n\t\t\t\t\t\t\t'for(i=n-1;i>=0;i--) x[i] ' + numeric.opseq[i] + ' y[i];');\n\t\t\t\t\t\tnumeric[i] = numeric.Function('x', 'y',\n\t\t\t\t\t\t\t'var s = numeric.dim(x);\\n' +\n\t\t\t\t\t\t\t'if(typeof y === \"number\") { numeric._biforeach(x,y,s,0,numeric.' + i + 'S); return x; }\\n' +\n\t\t\t\t\t\t\t'numeric._biforeach(x,y,s,0,numeric.' + i + 'V);\\n' +\n\t\t\t\t\t\t\t'return x;');\n\t\t\t\t\t\tnumeric[numeric.opseq[i]] = numeric[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}());\n\n\t\t\tnumeric._f2 = ['atan2', 'pow', 'max', 'min'];\n\t\t\t((function() {\n\t\t\t\tvar i, j;\n\t\t\t\tfor (j = 0; j < numeric._f2.length; ++j) {\n\t\t\t\t\ti = numeric._f2[j];\n\t\t\t\t\tnumeric[i + 'VV'] = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = zz(x[i],y[i]);', 'var zz = Math.' + i + ';');\n\t\t\t\t\tnumeric[i + 'VS'] = numeric.pointwise(['x[i]', 'y'], 'ret[i] = zz(x[i],y);', 'var zz = Math.' + i + ';');\n\t\t\t\t\tnumeric[i + 'SV'] = numeric.pointwise(['x', 'y[i]'], 'ret[i] = zz(x,y[i]);', 'var zz = Math.' + i + ';');\n\t\t\t\t\tnumeric[i] = Function('x', 'y',\n\t\t\t\t\t\t'if(typeof x === \"object\") {\\n' +\n\t\t\t\t\t\t'    if(typeof y === \"object\") return numeric.' + i + 'VV(x,y);\\n' +\n\t\t\t\t\t\t'    return numeric.' + i + 'VS(x,y);\\n' +\n\t\t\t\t\t\t'}\\n' +\n\t\t\t\t\t\t'if (typeof y === \"object\") return numeric.' + i + 'SV(x,y);\\n' +\n\t\t\t\t\t\t'return Math.' + i + '(x,y);\\n');\n\t\t\t\t}\n\t\t\t})());\n\n\t\t\tnumeric.atan2VV = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = atan2(x[i],y[i]);', 'var atan2 = Math.atan2;');\n\t\t\tnumeric.atan2VS = numeric.pointwise(['x[i]', 'y'], 'ret[i] = atan2(x[i],y);', 'var atan2 = Math.atan2;');\n\t\t\tnumeric.atan2SV = numeric.pointwise(['x', 'y[i]'], 'ret[i] = atan2(x,y[i]);', 'var atan2 = Math.atan2;');\n\t\t\tnumeric.atan2 = function atan2(x, y) {\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\tif (typeof y === \"object\") return numeric.atan2VV(x, y);\n\t\t\t\t\treturn numeric.atan2VS(x, y);\n\t\t\t\t}\n\t\t\t\tif (typeof y === \"object\") return numeric.atan2SV(x, y);\n\t\t\t\treturn Math.atan2(x, y);\n\t\t\t};\n\n\t\t\tnumeric.truncVV = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = round(x[i]/y[i])*y[i];', 'var round = Math.round;');\n\t\t\tnumeric.truncVS = numeric.pointwise(['x[i]', 'y'], 'ret[i] = round(x[i]/y)*y;', 'var round = Math.round;');\n\t\t\tnumeric.truncSV = numeric.pointwise(['x', 'y[i]'], 'ret[i] = round(x/y[i])*y[i];', 'var round = Math.round;');\n\t\t\tnumeric.trunc = function trunc(x, y) {\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\tif (typeof y === \"object\") return numeric.truncVV(x, y);\n\t\t\t\t\treturn numeric.truncVS(x, y);\n\t\t\t\t}\n\t\t\t\tif (typeof y === \"object\") return numeric.truncSV(x, y);\n\t\t\t\treturn Math.round(x / y) * y;\n\t\t\t};\n\n\t\t\tnumeric.powVV = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = pow(x[i],y[i]);', 'var pow = Math.pow;');\n\t\t\tnumeric.powVS = numeric.pointwise(['x[i]', 'y'], 'ret[i] = pow(x[i],y);', 'var pow = Math.pow;');\n\t\t\tnumeric.powSV = numeric.pointwise(['x', 'y[i]'], 'ret[i] = pow(x,y[i]);', 'var pow = Math.pow;');\n\t\t\tnumeric.pow = function pow(x, y) {\n\t\t\t\tif (typeof x === \"object\") {\n\t\t\t\t\tif (typeof y === \"object\") return numeric.powVV(x, y);\n\t\t\t\t\treturn numeric.powVS(x, y);\n\t\t\t\t}\n\t\t\t\tif (typeof y === \"object\") return numeric.powSV(x, y);\n\t\t\t\treturn Math.pow(x, y);\n\t\t\t};\n\n\t\t\tnumeric.clone = numeric.pointwise(['x[i]'], 'ret[i] = x[i];');\n\n\t\t\tnumeric.inv = function inv(x) {\n\t\t\t\tvar s = numeric.dim(x),\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1];\n\t\t\t\tvar A = numeric.clone(x),\n\t\t\t\t\tAi, Aj;\n\t\t\t\tvar I = numeric.identity(m),\n\t\t\t\t\tIi, Ij;\n\t\t\t\tvar i, j, k, x;\n\t\t\t\tfor (j = 0; j < n; ++j) {\n\t\t\t\t\ti0 = -1;\n\t\t\t\t\tv0 = -1;\n\t\t\t\t\tfor (i = j; i !== m; ++i) {\n\t\t\t\t\t\tk = abs(A[i][j]);\n\t\t\t\t\t\tif (k > v0) {\n\t\t\t\t\t\t\ti0 = i;\n\t\t\t\t\t\t\tv0 = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tAj = A[i0];\n\t\t\t\t\tA[i0] = A[j];\n\t\t\t\t\tA[j] = Aj;\n\t\t\t\t\tIj = I[i0];\n\t\t\t\t\tI[i0] = I[j];\n\t\t\t\t\tI[j] = Ij;\n\t\t\t\t\tx = Aj[j];\n\t\t\t\t\tfor (k = j; k !== n; ++k) Aj[k] /= x;\n\t\t\t\t\tfor (k = n - 1; k !== -1; --k) Ij[k] /= x;\n\t\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\t\tif (i !== j) {\n\t\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\t\tIi = I[i];\n\t\t\t\t\t\t\tx = Ai[j];\n\t\t\t\t\t\t\tfor (k = j + 1; k !== n; ++k) Ai[k] -= Aj[k] * x;\n\t\t\t\t\t\t\tfor (k = n - 1; k > 0; --k) {\n\t\t\t\t\t\t\t\tIi[k] -= Ij[k] * x;\n\t\t\t\t\t\t\t\t--k;\n\t\t\t\t\t\t\t\tIi[k] -= Ij[k] * x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k === 0) Ii[0] -= Ij[0] * x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn I;\n\t\t\t};\n\n\t\t\tnumeric.det = function det(x) {\n\t\t\t\tvar s = numeric.dim(x);\n\t\t\t\tif (s.length !== 2 || s[0] !== s[1]) {\n\t\t\t\t\tthrow new Error('numeric: det() only works on square matrices');\n\t\t\t\t}\n\t\t\t\tvar n = s[0],\n\t\t\t\t\tret = 1,\n\t\t\t\t\ti, j, k, A = numeric.clone(x),\n\t\t\t\t\tAj, Ai, alpha, temp, k1, k2, k3;\n\t\t\t\tfor (j = 0; j < n - 1; j++) {\n\t\t\t\t\tk = j;\n\t\t\t\t\tfor (i = j + 1; i < n; i++) {\n\t\t\t\t\t\tif (Math.abs(A[i][j]) > Math.abs(A[k][j])) {\n\t\t\t\t\t\t\tk = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k !== j) {\n\t\t\t\t\t\ttemp = A[k];\n\t\t\t\t\t\tA[k] = A[j];\n\t\t\t\t\t\tA[j] = temp;\n\t\t\t\t\t\tret *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tAj = A[j];\n\t\t\t\t\tfor (i = j + 1; i < n; i++) {\n\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\talpha = Ai[j] / Aj[j];\n\t\t\t\t\t\tfor (k = j + 1; k < n - 1; k += 2) {\n\t\t\t\t\t\t\tk1 = k + 1;\n\t\t\t\t\t\t\tAi[k] -= Aj[k] * alpha;\n\t\t\t\t\t\t\tAi[k1] -= Aj[k1] * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k !== n) {\n\t\t\t\t\t\t\tAi[k] -= Aj[k] * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Aj[j] === 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tret *= Aj[j];\n\t\t\t\t}\n\t\t\t\treturn ret * A[j][j];\n\t\t\t};\n\n\t\t\tnumeric.transpose = function transpose(x) {\n\t\t\t\tvar i, j, m = x.length,\n\t\t\t\t\tn = x[0].length,\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\tA0, A1, Bj;\n\t\t\t\tfor (j = 0; j < n; j++) ret[j] = Array(m);\n\t\t\t\tfor (i = m - 1; i >= 1; i -= 2) {\n\t\t\t\t\tA1 = x[i];\n\t\t\t\t\tA0 = x[i - 1];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = A1[j];\n\t\t\t\t\t\tBj[i - 1] = A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = A1[j];\n\t\t\t\t\t\tBj[i - 1] = A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tBj = ret[0];\n\t\t\t\t\t\tBj[i] = A1[0];\n\t\t\t\t\t\tBj[i - 1] = A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tA0 = x[0];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tret[j][0] = A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tret[j][0] = A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tret[0][0] = A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.negtranspose = function negtranspose(x) {\n\t\t\t\tvar i, j, m = x.length,\n\t\t\t\t\tn = x[0].length,\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\tA0, A1, Bj;\n\t\t\t\tfor (j = 0; j < n; j++) ret[j] = Array(m);\n\t\t\t\tfor (i = m - 1; i >= 1; i -= 2) {\n\t\t\t\t\tA1 = x[i];\n\t\t\t\t\tA0 = x[i - 1];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = -A1[j];\n\t\t\t\t\t\tBj[i - 1] = -A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tBj = ret[j];\n\t\t\t\t\t\tBj[i] = -A1[j];\n\t\t\t\t\t\tBj[i - 1] = -A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tBj = ret[0];\n\t\t\t\t\t\tBj[i] = -A1[0];\n\t\t\t\t\t\tBj[i - 1] = -A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tA0 = x[0];\n\t\t\t\t\tfor (j = n - 1; j >= 1; --j) {\n\t\t\t\t\t\tret[j][0] = -A0[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tret[j][0] = -A0[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tret[0][0] = -A0[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric._random = function _random(s, k) {\n\t\t\t\tvar i, n = s[k],\n\t\t\t\t\tret = Array(n),\n\t\t\t\t\trnd;\n\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\trnd = Math.random;\n\t\t\t\t\tfor (i = n - 1; i >= 1; i -= 2) {\n\t\t\t\t\t\tret[i] = rnd();\n\t\t\t\t\t\tret[i - 1] = rnd();\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tret[0] = rnd();\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfor (i = n - 1; i >= 0; i--) ret[i] = _random(s, k + 1);\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.random = function random(s) {\n\t\t\t\treturn numeric._random(s, 0);\n\t\t\t};\n\n\t\t\tnumeric.norm2Squared = function norm2Squared(x) {};\n\t\t\tnumeric.norm2Squared = numeric.mapreduce('accum += xi*xi;', '0');\n\n\t\t\tnumeric.norm2 = function norm2(x) {\n\t\t\t\treturn Math.sqrt(numeric.norm2Squared(x));\n\t\t\t};\n\t\t\tnumeric.norminf = numeric.mapreduce('accum = max(abs(xi),accum);', '0; var max = Math.max, abs = Math.abs;');\n\t\t\tnumeric.sum = numeric.mapreduce('accum += xi;', '0');\n\t\t\tnumeric.sup = numeric.mapreduce('accum = max(xi,accum);', '-Infinity; var max = Math.max;');\n\t\t\tnumeric.inf = numeric.mapreduce('accum = min(xi,accum);', 'Infinity; var min = Math.min;');\n\n\t\t\tnumeric.linspace = function linspace(a, b, n) {\n\t\t\t\tif (typeof n === \"undefined\") n = Math.max(Math.round(b - a) + 1, 1);\n\t\t\t\tif (n < 2) {\n\t\t\t\t\treturn n === 1 ? [a] : [];\n\t\t\t\t}\n\t\t\t\tvar i, ret = Array(n);\n\t\t\t\tn--;\n\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\tret[i] = (i * b + (n - i) * a) / n;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.getBlock = function getBlock(x, from, to) {\n\t\t\t\tvar s = numeric.dim(x);\n\n\t\t\t\tfunction foo(x, k) {\n\t\t\t\t\tvar i, a = from[k],\n\t\t\t\t\t\tn = to[k] - a,\n\t\t\t\t\t\tret = Array(n);\n\t\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\t\tret[i] = x[i + a];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\tret[i] = foo(x[i + a], k + 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn foo(x, 0);\n\t\t\t};\n\n\t\t\tnumeric.setBlock = function setBlock(x, from, to, B) {\n\t\t\t\tvar s = numeric.dim(x);\n\n\t\t\t\tfunction foo(x, y, k) {\n\t\t\t\t\tvar i, a = from[k],\n\t\t\t\t\t\tn = to[k] - a;\n\t\t\t\t\tif (k === s.length - 1) {\n\t\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\t\tx[i + a] = y[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = n; i >= 0; i--) {\n\t\t\t\t\t\tfoo(x[i + a], y[i], k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoo(x, B, 0);\n\t\t\t\treturn x;\n\t\t\t};\n\n\t\t\tnumeric.getRange = function getRange(A, I, J) {\n\t\t\t\tvar m = I.length,\n\t\t\t\t\tn = J.length;\n\t\t\t\tvar i, j;\n\t\t\t\tvar B = Array(m),\n\t\t\t\t\tBi, AI;\n\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\tB[i] = Array(n);\n\t\t\t\t\tBi = B[i];\n\t\t\t\t\tAI = A[I[i]];\n\t\t\t\t\tfor (j = n - 1; j !== -1; --j) Bi[j] = AI[J[j]];\n\t\t\t\t}\n\t\t\t\treturn B;\n\t\t\t};\n\n\t\t\tnumeric.blockMatrix = function blockMatrix(X) {\n\t\t\t\tvar s = numeric.dim(X);\n\t\t\t\tif (s.length < 4) return numeric.blockMatrix([X]);\n\t\t\t\tvar m = s[0],\n\t\t\t\t\tn = s[1],\n\t\t\t\t\tM, N, i, j, Xij;\n\t\t\t\tM = 0;\n\t\t\t\tN = 0;\n\t\t\t\tfor (i = 0; i < m; ++i) M += X[i][0].length;\n\t\t\t\tfor (j = 0; j < n; ++j) N += X[0][j][0].length;\n\t\t\t\tvar Z = Array(M);\n\t\t\t\tfor (i = 0; i < M; ++i) Z[i] = Array(N);\n\t\t\t\tvar I = 0,\n\t\t\t\t\tJ, ZI, k, l, Xijk;\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tJ = N;\n\t\t\t\t\tfor (j = n - 1; j !== -1; --j) {\n\t\t\t\t\t\tXij = X[i][j];\n\t\t\t\t\t\tJ -= Xij[0].length;\n\t\t\t\t\t\tfor (k = Xij.length - 1; k !== -1; --k) {\n\t\t\t\t\t\t\tXijk = Xij[k];\n\t\t\t\t\t\t\tZI = Z[I + k];\n\t\t\t\t\t\t\tfor (l = Xijk.length - 1; l !== -1; --l) ZI[J + l] = Xijk[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tI += X[i][0].length;\n\t\t\t\t}\n\t\t\t\treturn Z;\n\t\t\t};\n\n\t\t\tnumeric.tensor = function tensor(x, y) {\n\t\t\t\tif (typeof x === \"number\" || typeof y === \"number\") return numeric.mul(x, y);\n\t\t\t\tvar s1 = numeric.dim(x),\n\t\t\t\t\ts2 = numeric.dim(y);\n\t\t\t\tif (s1.length !== 1 || s2.length !== 1) {\n\t\t\t\t\tthrow new Error('numeric: tensor product is only defined for vectors');\n\t\t\t\t}\n\t\t\t\tvar m = s1[0],\n\t\t\t\t\tn = s2[0],\n\t\t\t\t\tA = Array(m),\n\t\t\t\t\tAi, i, j, xi;\n\t\t\t\tfor (i = m - 1; i >= 0; i--) {\n\t\t\t\t\tAi = Array(n);\n\t\t\t\t\txi = x[i];\n\t\t\t\t\tfor (j = n - 1; j >= 3; --j) {\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t}\n\t\t\t\t\twhile (j >= 0) {\n\t\t\t\t\t\tAi[j] = xi * y[j];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t}\n\t\t\t\t\tA[i] = Ai;\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\n\t\t\t// 3. The Tensor type T\n\t\t\tnumeric.T = function T(x, y) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t};\n\t\t\tnumeric.t = function t(x, y) {\n\t\t\t\treturn new numeric.T(x, y);\n\t\t\t};\n\n\t\t\tnumeric.Tbinop = function Tbinop(rr, rc, cr, cc, setup) {\n\t\t\t\tvar io = numeric.indexOf;\n\t\t\t\tif (typeof setup !== \"string\") {\n\t\t\t\t\tvar k;\n\t\t\t\t\tsetup = '';\n\t\t\t\t\tfor (k in numeric) {\n\t\t\t\t\t\tif (numeric.hasOwnProperty(k) && (rr.indexOf(k) >= 0 || rc.indexOf(k) >= 0 || cr.indexOf(k) >= 0 || cc.indexOf(k) >= 0) && k.length > 1) {\n\t\t\t\t\t\t\tsetup += 'var ' + k + ' = numeric.' + k + ';\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn numeric.Function(['y'],\n\t\t\t\t\t'var x = this;\\n' +\n\t\t\t\t\t'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\\n' +\n\t\t\t\t\tsetup + '\\n' +\n\t\t\t\t\t'if(x.y) {' +\n\t\t\t\t\t'  if(y.y) {' +\n\t\t\t\t\t'    return new numeric.T(' + cc + ');\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  return new numeric.T(' + cr + ');\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'if(y.y) {\\n' +\n\t\t\t\t\t'  return new numeric.T(' + rc + ');\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return new numeric.T(' + rr + ');\\n'\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tnumeric.T.prototype.add = numeric.Tbinop(\n\t\t\t\t'add(x.x,y.x)',\n\t\t\t\t'add(x.x,y.x),y.y',\n\t\t\t\t'add(x.x,y.x),x.y',\n\t\t\t\t'add(x.x,y.x),add(x.y,y.y)');\n\t\t\tnumeric.T.prototype.sub = numeric.Tbinop(\n\t\t\t\t'sub(x.x,y.x)',\n\t\t\t\t'sub(x.x,y.x),neg(y.y)',\n\t\t\t\t'sub(x.x,y.x),x.y',\n\t\t\t\t'sub(x.x,y.x),sub(x.y,y.y)');\n\t\t\tnumeric.T.prototype.mul = numeric.Tbinop(\n\t\t\t\t'mul(x.x,y.x)',\n\t\t\t\t'mul(x.x,y.x),mul(x.x,y.y)',\n\t\t\t\t'mul(x.x,y.x),mul(x.y,y.x)',\n\t\t\t\t'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');\n\n\t\t\tnumeric.T.prototype.reciprocal = function reciprocal() {\n\t\t\t\tvar mul = numeric.mul,\n\t\t\t\t\tdiv = numeric.div;\n\t\t\t\tif (this.y) {\n\t\t\t\t\tvar d = numeric.add(mul(this.x, this.x), mul(this.y, this.y));\n\t\t\t\t\treturn new numeric.T(div(this.x, d), div(numeric.neg(this.y), d));\n\t\t\t\t}\n\t\t\t\treturn new T(div(1, this.x));\n\t\t\t};\n\t\t\tnumeric.T.prototype.div = function div(y) {\n\t\t\t\tif (!(y instanceof numeric.T)) y = new numeric.T(y);\n\t\t\t\tif (y.y) {\n\t\t\t\t\treturn this.mul(y.reciprocal());\n\t\t\t\t}\n\t\t\t\tvar div = numeric.div;\n\t\t\t\tif (this.y) {\n\t\t\t\t\treturn new numeric.T(div(this.x, y.x), div(this.y, y.x));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(div(this.x, y.x));\n\t\t\t};\n\t\t\tnumeric.T.prototype.dot = numeric.Tbinop(\n\t\t\t\t'dot(x.x,y.x)',\n\t\t\t\t'dot(x.x,y.x),dot(x.x,y.y)',\n\t\t\t\t'dot(x.x,y.x),dot(x.y,y.x)',\n\t\t\t\t'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'\n\t\t\t);\n\t\t\tnumeric.T.prototype.transpose = function transpose() {\n\t\t\t\tvar t = numeric.transpose,\n\t\t\t\t\tx = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(t(x), t(y));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(t(x));\n\t\t\t};\n\t\t\tnumeric.T.prototype.transjugate = function transjugate() {\n\t\t\t\tvar t = numeric.transpose,\n\t\t\t\t\tx = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(t(x), numeric.negtranspose(y));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(t(x));\n\t\t\t};\n\t\t\tnumeric.Tunop = function Tunop(r, c, s) {\n\t\t\t\tif (typeof s !== \"string\") {\n\t\t\t\t\ts = '';\n\t\t\t\t}\n\t\t\t\treturn numeric.Function(\n\t\t\t\t\t'var x = this;\\n' +\n\t\t\t\t\ts + '\\n' +\n\t\t\t\t\t'if(x.y) {' +\n\t\t\t\t\t'  ' + c + ';\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\tr + ';\\n'\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tnumeric.T.prototype.exp = numeric.Tunop(\n\t\t\t\t'return new numeric.T(ex)',\n\t\t\t\t'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',\n\t\t\t\t'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');\n\t\t\tnumeric.T.prototype.conj = numeric.Tunop(\n\t\t\t\t'return new numeric.T(x.x);',\n\t\t\t\t'return new numeric.T(x.x,numeric.neg(x.y));');\n\t\t\tnumeric.T.prototype.neg = numeric.Tunop(\n\t\t\t\t'return new numeric.T(neg(x.x));',\n\t\t\t\t'return new numeric.T(neg(x.x),neg(x.y));',\n\t\t\t\t'var neg = numeric.neg;');\n\t\t\tnumeric.T.prototype.sin = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.sin(x.x))',\n\t\t\t\t'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');\n\t\t\tnumeric.T.prototype.cos = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.cos(x.x))',\n\t\t\t\t'return x.exp().add(x.neg().exp()).div(2);');\n\t\t\tnumeric.T.prototype.abs = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.abs(x.x));',\n\t\t\t\t'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',\n\t\t\t\t'var mul = numeric.mul;');\n\t\t\tnumeric.T.prototype.log = numeric.Tunop(\n\t\t\t\t'return new numeric.T(numeric.log(x.x));',\n\t\t\t\t'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\\n' +\n\t\t\t\t'return new numeric.T(numeric.log(r.x),theta.x);');\n\t\t\tnumeric.T.prototype.norm2 = numeric.Tunop(\n\t\t\t\t'return numeric.norm2(x.x);',\n\t\t\t\t'var f = numeric.norm2Squared;\\n' +\n\t\t\t\t'return Math.sqrt(f(x.x)+f(x.y));');\n\t\t\tnumeric.T.prototype.inv = function inv() {\n\t\t\t\tvar A = this;\n\t\t\t\tif (typeof A.y === \"undefined\") {\n\t\t\t\t\treturn new numeric.T(numeric.inv(A.x));\n\t\t\t\t}\n\t\t\t\tvar n = A.x.length,\n\t\t\t\t\ti, j, k;\n\t\t\t\tvar Rx = numeric.identity(n),\n\t\t\t\t\tRy = numeric.rep([n, n], 0);\n\t\t\t\tvar Ax = numeric.clone(A.x),\n\t\t\t\t\tAy = numeric.clone(A.y);\n\t\t\t\tvar Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;\n\t\t\t\tvar i, j, k, d, d1, ax, ay, bx, by, temp;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tax = Ax[i][i];\n\t\t\t\t\tay = Ay[i][i];\n\t\t\t\t\td = ax * ax + ay * ay;\n\t\t\t\t\tk = i;\n\t\t\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\t\t\tax = Ax[j][i];\n\t\t\t\t\t\tay = Ay[j][i];\n\t\t\t\t\t\td1 = ax * ax + ay * ay;\n\t\t\t\t\t\tif (d1 > d) {\n\t\t\t\t\t\t\tk = j;\n\t\t\t\t\t\t\td = d1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k !== i) {\n\t\t\t\t\t\ttemp = Ax[i];\n\t\t\t\t\t\tAx[i] = Ax[k];\n\t\t\t\t\t\tAx[k] = temp;\n\t\t\t\t\t\ttemp = Ay[i];\n\t\t\t\t\t\tAy[i] = Ay[k];\n\t\t\t\t\t\tAy[k] = temp;\n\t\t\t\t\t\ttemp = Rx[i];\n\t\t\t\t\t\tRx[i] = Rx[k];\n\t\t\t\t\t\tRx[k] = temp;\n\t\t\t\t\t\ttemp = Ry[i];\n\t\t\t\t\t\tRy[i] = Ry[k];\n\t\t\t\t\t\tRy[k] = temp;\n\t\t\t\t\t}\n\t\t\t\t\tAix = Ax[i];\n\t\t\t\t\tAiy = Ay[i];\n\t\t\t\t\tRix = Rx[i];\n\t\t\t\t\tRiy = Ry[i];\n\t\t\t\t\tax = Aix[i];\n\t\t\t\t\tay = Aiy[i];\n\t\t\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\t\t\tbx = Aix[j];\n\t\t\t\t\t\tby = Aiy[j];\n\t\t\t\t\t\tAix[j] = (bx * ax + by * ay) / d;\n\t\t\t\t\t\tAiy[j] = (by * ax - bx * ay) / d;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\t\tbx = Rix[j];\n\t\t\t\t\t\tby = Riy[j];\n\t\t\t\t\t\tRix[j] = (bx * ax + by * ay) / d;\n\t\t\t\t\t\tRiy[j] = (by * ax - bx * ay) / d;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\t\t\tAjx = Ax[j];\n\t\t\t\t\t\tAjy = Ay[j];\n\t\t\t\t\t\tRjx = Rx[j];\n\t\t\t\t\t\tRjy = Ry[j];\n\t\t\t\t\t\tax = Ajx[i];\n\t\t\t\t\t\tay = Ajy[i];\n\t\t\t\t\t\tfor (k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tbx = Aix[k];\n\t\t\t\t\t\t\tby = Aiy[k];\n\t\t\t\t\t\t\tAjx[k] -= bx * ax - by * ay;\n\t\t\t\t\t\t\tAjy[k] -= by * ax + bx * ay;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\t\t\tbx = Rix[k];\n\t\t\t\t\t\t\tby = Riy[k];\n\t\t\t\t\t\t\tRjx[k] -= bx * ax - by * ay;\n\t\t\t\t\t\t\tRjy[k] -= by * ax + bx * ay;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = n - 1; i > 0; i--) {\n\t\t\t\t\tRix = Rx[i];\n\t\t\t\t\tRiy = Ry[i];\n\t\t\t\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tRjx = Rx[j];\n\t\t\t\t\t\tRjy = Ry[j];\n\t\t\t\t\t\tax = Ax[j][i];\n\t\t\t\t\t\tay = Ay[j][i];\n\t\t\t\t\t\tfor (k = n - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tbx = Rix[k];\n\t\t\t\t\t\t\tby = Riy[k];\n\t\t\t\t\t\t\tRjx[k] -= ax * bx - ay * by;\n\t\t\t\t\t\t\tRjy[k] -= ax * by + ay * bx;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(Rx, Ry);\n\t\t\t};\n\t\t\tnumeric.T.prototype.get = function get(i) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tk = 0,\n\t\t\t\t\tik, n = i.length;\n\t\t\t\tif (y) {\n\t\t\t\t\twhile (k < n) {\n\t\t\t\t\t\tik = i[k];\n\t\t\t\t\t\tx = x[ik];\n\t\t\t\t\t\ty = y[ik];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\treturn new numeric.T(x, y);\n\t\t\t\t}\n\t\t\t\twhile (k < n) {\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx = x[ik];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(x);\n\t\t\t};\n\t\t\tnumeric.T.prototype.set = function set(i, v) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tk = 0,\n\t\t\t\t\tik, n = i.length,\n\t\t\t\t\tvx = v.x,\n\t\t\t\t\tvy = v.y;\n\t\t\t\tif (n === 0) {\n\t\t\t\t\tif (vy) {\n\t\t\t\t\t\tthis.y = vy;\n\t\t\t\t\t} else if (y) {\n\t\t\t\t\t\tthis.y = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x = x;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tif (vy) {\n\t\t\t\t\tif (y) {\n\t\t\t\t\t\t/* ok */\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty = numeric.rep(numeric.dim(x), 0);\n\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t}\n\t\t\t\t\twhile (k < n - 1) {\n\t\t\t\t\t\tik = i[k];\n\t\t\t\t\t\tx = x[ik];\n\t\t\t\t\t\ty = y[ik];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx[ik] = vx;\n\t\t\t\t\ty[ik] = vy;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tif (y) {\n\t\t\t\t\twhile (k < n - 1) {\n\t\t\t\t\t\tik = i[k];\n\t\t\t\t\t\tx = x[ik];\n\t\t\t\t\t\ty = y[ik];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx[ik] = vx;\n\t\t\t\t\tif (vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx), 0);\n\t\t\t\t\telse y[ik] = 0;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\twhile (k < n - 1) {\n\t\t\t\t\tik = i[k];\n\t\t\t\t\tx = x[ik];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tik = i[k];\n\t\t\t\tx[ik] = vx;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tnumeric.T.prototype.getRows = function getRows(i0, i1) {\n\t\t\t\tvar n = i1 - i0 + 1,\n\t\t\t\t\tj;\n\t\t\t\tvar rx = Array(n),\n\t\t\t\t\try, x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\trx[j - i0] = x[j];\n\t\t\t\t}\n\t\t\t\tif (y) {\n\t\t\t\t\try = Array(n);\n\t\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\t\try[j - i0] = y[j];\n\t\t\t\t\t}\n\t\t\t\t\treturn new numeric.T(rx, ry);\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(rx);\n\t\t\t};\n\t\t\tnumeric.T.prototype.setRows = function setRows(i0, i1, A) {\n\t\t\t\tvar j;\n\t\t\t\tvar rx = this.x,\n\t\t\t\t\try = this.y,\n\t\t\t\t\tx = A.x,\n\t\t\t\t\ty = A.y;\n\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\trx[j] = x[j - i0];\n\t\t\t\t}\n\t\t\t\tif (y) {\n\t\t\t\t\tif (!ry) {\n\t\t\t\t\t\try = numeric.rep(numeric.dim(rx), 0);\n\t\t\t\t\t\tthis.y = ry;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\t\try[j] = y[j - i0];\n\t\t\t\t\t}\n\t\t\t\t} else if (ry) {\n\t\t\t\t\tfor (j = i0; j <= i1; j++) {\n\t\t\t\t\t\try[j] = numeric.rep([x[j - i0].length], 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tnumeric.T.prototype.getRow = function getRow(k) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(x[k], y[k]);\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(x[k]);\n\t\t\t};\n\t\t\tnumeric.T.prototype.setRow = function setRow(i, v) {\n\t\t\t\tvar rx = this.x,\n\t\t\t\t\try = this.y,\n\t\t\t\t\tx = v.x,\n\t\t\t\t\ty = v.y;\n\t\t\t\trx[i] = x;\n\t\t\t\tif (y) {\n\t\t\t\t\tif (!ry) {\n\t\t\t\t\t\try = numeric.rep(numeric.dim(rx), 0);\n\t\t\t\t\t\tthis.y = ry;\n\t\t\t\t\t}\n\t\t\t\t\try[i] = y;\n\t\t\t\t} else if (ry) {\n\t\t\t\t\try = numeric.rep([x.length], 0);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tnumeric.T.prototype.getBlock = function getBlock(from, to) {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tb = numeric.getBlock;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new numeric.T(b(x, from, to), b(y, from, to));\n\t\t\t\t}\n\t\t\t\treturn new numeric.T(b(x, from, to));\n\t\t\t};\n\t\t\tnumeric.T.prototype.setBlock = function setBlock(from, to, A) {\n\t\t\t\tif (!(A instanceof numeric.T)) A = new numeric.T(A);\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y,\n\t\t\t\t\tb = numeric.setBlock,\n\t\t\t\t\tAx = A.x,\n\t\t\t\t\tAy = A.y;\n\t\t\t\tif (Ay) {\n\t\t\t\t\tif (!y) {\n\t\t\t\t\t\tthis.y = numeric.rep(numeric.dim(this), 0);\n\t\t\t\t\t\ty = this.y;\n\t\t\t\t\t}\n\t\t\t\t\tb(x, from, to, Ax);\n\t\t\t\t\tb(y, from, to, Ay);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tb(x, from, to, Ax);\n\t\t\t\tif (y) b(y, from, to, numeric.rep(numeric.dim(Ax), 0));\n\t\t\t};\n\t\t\tnumeric.T.rep = function rep(s, v) {\n\t\t\t\tvar T = numeric.T;\n\t\t\t\tif (!(v instanceof T)) v = new T(v);\n\t\t\t\tvar x = v.x,\n\t\t\t\t\ty = v.y,\n\t\t\t\t\tr = numeric.rep;\n\t\t\t\tif (y) return new T(r(s, x), r(s, y));\n\t\t\t\treturn new T(r(s, x));\n\t\t\t};\n\t\t\tnumeric.T.diag = function diag(d) {\n\t\t\t\tif (!(d instanceof numeric.T)) d = new numeric.T(d);\n\t\t\t\tvar x = d.x,\n\t\t\t\t\ty = d.y,\n\t\t\t\t\tdiag = numeric.diag;\n\t\t\t\tif (y) return new numeric.T(diag(x), diag(y));\n\t\t\t\treturn new numeric.T(diag(x));\n\t\t\t};\n\t\t\tnumeric.T.eig = function eig() {\n\t\t\t\tif (this.y) {\n\t\t\t\t\tthrow new Error('eig: not implemented for complex matrices.');\n\t\t\t\t}\n\t\t\t\treturn numeric.eig(this.x);\n\t\t\t};\n\t\t\tnumeric.T.identity = function identity(n) {\n\t\t\t\treturn new numeric.T(numeric.identity(n));\n\t\t\t};\n\t\t\tnumeric.T.prototype.getDiag = function getDiag() {\n\t\t\t\tvar n = numeric;\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tif (y) {\n\t\t\t\t\treturn new n.T(n.getDiag(x), n.getDiag(y));\n\t\t\t\t}\n\t\t\t\treturn new n.T(n.getDiag(x));\n\t\t\t};\n\n\t\t\t// 4. Eigenvalues of real matrices\n\n\t\t\tnumeric.house = function house(x) {\n\t\t\t\tvar v = numeric.clone(x);\n\t\t\t\tvar s = x[0] >= 0 ? 1 : -1;\n\t\t\t\tvar alpha = s * numeric.norm2(x);\n\t\t\t\tv[0] += alpha;\n\t\t\t\tvar foo = numeric.norm2(v);\n\t\t\t\tif (foo === 0) {\n\t\t\t\t\t/* this should not happen */\n\t\t\t\t\tthrow new Error('eig: internal error');\n\t\t\t\t}\n\t\t\t\treturn numeric.div(v, foo);\n\t\t\t};\n\n\t\t\tnumeric.toUpperHessenberg = function toUpperHessenberg(me) {\n\t\t\t\tvar s = numeric.dim(me);\n\t\t\t\tif (s.length !== 2 || s[0] !== s[1]) {\n\t\t\t\t\tthrow new Error('numeric: toUpperHessenberg() only works on square matrices');\n\t\t\t\t}\n\t\t\t\tvar m = s[0],\n\t\t\t\t\ti, j, k, x, v, A = numeric.clone(me),\n\t\t\t\t\tB, C, Ai, Ci, Q = numeric.identity(m),\n\t\t\t\t\tQi;\n\t\t\t\tfor (j = 0; j < m - 2; j++) {\n\t\t\t\t\tx = Array(m - j - 1);\n\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\tx[i - j - 1] = A[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (numeric.norm2(x) > 0) {\n\t\t\t\t\t\tv = numeric.house(x);\n\t\t\t\t\t\tB = numeric.getBlock(A, [j + 1, j], [m - 1, m - 1]);\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = j; k < m; k++) Ai[k] -= 2 * Ci[k - j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = numeric.getBlock(A, [0, j + 1], [m - 1, m - 1]);\n\t\t\t\t\t\tC = numeric.tensor(numeric.dot(B, v), v);\n\t\t\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\t\tfor (k = j + 1; k < m; k++) Ai[k] -= 2 * Ci[k - j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = Array(m - j - 1);\n\t\t\t\t\t\tfor (i = j + 1; i < m; i++) B[i - j - 1] = Q[i];\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\tQi = Q[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tH: A,\n\t\t\t\t\tQ: Q\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.epsilon = 2.220446049250313e-16;\n\n\t\t\tnumeric.QRFrancis = function(H, maxiter) {\n\t\t\t\tif (typeof maxiter === \"undefined\") {\n\t\t\t\t\tmaxiter = 10000;\n\t\t\t\t}\n\t\t\t\tH = numeric.clone(H);\n\t\t\t\tvar H0 = numeric.clone(H);\n\t\t\t\tvar s = numeric.dim(H),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tx, v, a, b, c, d, det, tr, Hloc, Q = numeric.identity(m),\n\t\t\t\t\tQi, Hi, B, C, Ci, i, j, k, iter;\n\t\t\t\tif (m < 3) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tQ: Q,\n\t\t\t\t\t\tB: [\n\t\t\t\t\t\t\t[0, m - 1]\n\t\t\t\t\t\t]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar epsilon = numeric.epsilon;\n\t\t\t\tfor (iter = 0; iter < maxiter; iter++) {\n\t\t\t\t\tfor (j = 0; j < m - 1; j++) {\n\t\t\t\t\t\tif (Math.abs(H[j + 1][j]) < epsilon * (Math.abs(H[j][j]) + Math.abs(H[j + 1][j + 1]))) {\n\t\t\t\t\t\t\tvar QH1 = numeric.QRFrancis(numeric.getBlock(H, [0, 0], [j, j]), maxiter);\n\t\t\t\t\t\t\tvar QH2 = numeric.QRFrancis(numeric.getBlock(H, [j + 1, j + 1], [m - 1, m - 1]), maxiter);\n\t\t\t\t\t\t\tB = Array(j + 1);\n\t\t\t\t\t\t\tfor (i = 0; i <= j; i++) {\n\t\t\t\t\t\t\t\tB[i] = Q[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tC = numeric.dot(QH1.Q, B);\n\t\t\t\t\t\t\tfor (i = 0; i <= j; i++) {\n\t\t\t\t\t\t\t\tQ[i] = C[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tB = Array(m - j - 1);\n\t\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\t\tB[i - j - 1] = Q[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tC = numeric.dot(QH2.Q, B);\n\t\t\t\t\t\t\tfor (i = j + 1; i < m; i++) {\n\t\t\t\t\t\t\t\tQ[i] = C[i - j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tQ: Q,\n\t\t\t\t\t\t\t\tB: QH1.B.concat(numeric.add(QH2.B, j + 1))\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = H[m - 2][m - 2];\n\t\t\t\t\tb = H[m - 2][m - 1];\n\t\t\t\t\tc = H[m - 1][m - 2];\n\t\t\t\t\td = H[m - 1][m - 1];\n\t\t\t\t\ttr = a + d;\n\t\t\t\t\tdet = (a * d - b * c);\n\t\t\t\t\tHloc = numeric.getBlock(H, [0, 0], [2, 2]);\n\t\t\t\t\tif (tr * tr >= 4 * det) {\n\t\t\t\t\t\tvar s1, s2;\n\t\t\t\t\t\ts1 = 0.5 * (tr + Math.sqrt(tr * tr - 4 * det));\n\t\t\t\t\t\ts2 = 0.5 * (tr - Math.sqrt(tr * tr - 4 * det));\n\t\t\t\t\t\tHloc = numeric.add(numeric.sub(numeric.dot(Hloc, Hloc),\n\t\t\t\t\t\t\t\tnumeric.mul(Hloc, s1 + s2)),\n\t\t\t\t\t\t\tnumeric.diag(numeric.rep([3], s1 * s2)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tHloc = numeric.add(numeric.sub(numeric.dot(Hloc, Hloc),\n\t\t\t\t\t\t\t\tnumeric.mul(Hloc, tr)),\n\t\t\t\t\t\t\tnumeric.diag(numeric.rep([3], det)));\n\t\t\t\t\t}\n\t\t\t\t\tx = [Hloc[0][0], Hloc[1][0], Hloc[2][0]];\n\t\t\t\t\tv = numeric.house(x);\n\t\t\t\t\tB = [H[0], H[1], H[2]];\n\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\tfor (k = 0; k < m; k++) Hi[k] -= 2 * Ci[k];\n\t\t\t\t\t}\n\t\t\t\t\tB = numeric.getBlock(H, [0, 0], [m - 1, 2]);\n\t\t\t\t\tC = numeric.tensor(numeric.dot(B, v), v);\n\t\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\tfor (k = 0; k < 3; k++) Hi[k] -= 2 * Ci[k];\n\t\t\t\t\t}\n\t\t\t\t\tB = [Q[0], Q[1], Q[2]];\n\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tQi = Q[i];\n\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\tfor (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];\n\t\t\t\t\t}\n\t\t\t\t\tvar J;\n\t\t\t\t\tfor (j = 0; j < m - 2; j++) {\n\t\t\t\t\t\tfor (k = j; k <= j + 1; k++) {\n\t\t\t\t\t\t\tif (Math.abs(H[k + 1][k]) < epsilon * (Math.abs(H[k][k]) + Math.abs(H[k + 1][k + 1]))) {\n\t\t\t\t\t\t\t\tvar QH1 = numeric.QRFrancis(numeric.getBlock(H, [0, 0], [k, k]), maxiter);\n\t\t\t\t\t\t\t\tvar QH2 = numeric.QRFrancis(numeric.getBlock(H, [k + 1, k + 1], [m - 1, m - 1]), maxiter);\n\t\t\t\t\t\t\t\tB = Array(k + 1);\n\t\t\t\t\t\t\t\tfor (i = 0; i <= k; i++) {\n\t\t\t\t\t\t\t\t\tB[i] = Q[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tC = numeric.dot(QH1.Q, B);\n\t\t\t\t\t\t\t\tfor (i = 0; i <= k; i++) {\n\t\t\t\t\t\t\t\t\tQ[i] = C[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tB = Array(m - k - 1);\n\t\t\t\t\t\t\t\tfor (i = k + 1; i < m; i++) {\n\t\t\t\t\t\t\t\t\tB[i - k - 1] = Q[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tC = numeric.dot(QH2.Q, B);\n\t\t\t\t\t\t\t\tfor (i = k + 1; i < m; i++) {\n\t\t\t\t\t\t\t\t\tQ[i] = C[i - k - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tQ: Q,\n\t\t\t\t\t\t\t\t\tB: QH1.B.concat(numeric.add(QH2.B, k + 1))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJ = Math.min(m - 1, j + 3);\n\t\t\t\t\t\tx = Array(J - j);\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) {\n\t\t\t\t\t\t\tx[i - j - 1] = H[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv = numeric.house(x);\n\t\t\t\t\t\tB = numeric.getBlock(H, [j + 1, j], [J, m - 1]);\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) {\n\t\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = j; k < m; k++) Hi[k] -= 2 * Ci[k - j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = numeric.getBlock(H, [0, j + 1], [m - 1, J]);\n\t\t\t\t\t\tC = numeric.tensor(numeric.dot(B, v), v);\n\t\t\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\t\t\tHi = H[i];\n\t\t\t\t\t\t\tCi = C[i];\n\t\t\t\t\t\t\tfor (k = j + 1; k <= J; k++) Hi[k] -= 2 * Ci[k - j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tB = Array(J - j);\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) B[i - j - 1] = Q[i];\n\t\t\t\t\t\tC = numeric.tensor(v, numeric.dot(v, B));\n\t\t\t\t\t\tfor (i = j + 1; i <= J; i++) {\n\t\t\t\t\t\t\tQi = Q[i];\n\t\t\t\t\t\t\tCi = C[i - j - 1];\n\t\t\t\t\t\t\tfor (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');\n\t\t\t};\n\n\t\t\tnumeric.eig = function eig(A, maxiter) {\n\t\t\t\tvar QH = numeric.toUpperHessenberg(A);\n\t\t\t\tvar QB = numeric.QRFrancis(QH.H, maxiter);\n\t\t\t\tvar T = numeric.T;\n\t\t\t\tvar n = A.length,\n\t\t\t\t\ti, k, flag = false,\n\t\t\t\t\tB = QB.B,\n\t\t\t\t\tH = numeric.dot(QB.Q, numeric.dot(QH.H, numeric.transpose(QB.Q)));\n\t\t\t\tvar Q = new T(numeric.dot(QB.Q, QH.Q)),\n\t\t\t\t\tQ0;\n\t\t\t\tvar m = B.length,\n\t\t\t\t\tj;\n\t\t\t\tvar a, b, c, d, p1, p2, disc, x, y, p, q, n1, n2;\n\t\t\t\tvar sqrt = Math.sqrt;\n\t\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\t\ti = B[k][0];\n\t\t\t\t\tif (i === B[k][1]) {\n\t\t\t\t\t\t// nothing\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\ta = H[i][i];\n\t\t\t\t\t\tb = H[i][j];\n\t\t\t\t\t\tc = H[j][i];\n\t\t\t\t\t\td = H[j][j];\n\t\t\t\t\t\tif (b === 0 && c === 0) continue;\n\t\t\t\t\t\tp1 = -a - d;\n\t\t\t\t\t\tp2 = a * d - b * c;\n\t\t\t\t\t\tdisc = p1 * p1 - 4 * p2;\n\t\t\t\t\t\tif (disc >= 0) {\n\t\t\t\t\t\t\tif (p1 < 0) x = -0.5 * (p1 - sqrt(disc));\n\t\t\t\t\t\t\telse x = -0.5 * (p1 + sqrt(disc));\n\t\t\t\t\t\t\tn1 = (a - x) * (a - x) + b * b;\n\t\t\t\t\t\t\tn2 = c * c + (d - x) * (d - x);\n\t\t\t\t\t\t\tif (n1 > n2) {\n\t\t\t\t\t\t\t\tn1 = sqrt(n1);\n\t\t\t\t\t\t\t\tp = (a - x) / n1;\n\t\t\t\t\t\t\t\tq = b / n1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tn2 = sqrt(n2);\n\t\t\t\t\t\t\t\tp = c / n2;\n\t\t\t\t\t\t\t\tq = (d - x) / n2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ0 = new T([\n\t\t\t\t\t\t\t\t[q, -p],\n\t\t\t\t\t\t\t\t[p, q]\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\tQ.setRows(i, j, Q0.dot(Q.getRows(i, j)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tx = -0.5 * p1;\n\t\t\t\t\t\t\ty = 0.5 * sqrt(-disc);\n\t\t\t\t\t\t\tn1 = (a - x) * (a - x) + b * b;\n\t\t\t\t\t\t\tn2 = c * c + (d - x) * (d - x);\n\t\t\t\t\t\t\tif (n1 > n2) {\n\t\t\t\t\t\t\t\tn1 = sqrt(n1 + y * y);\n\t\t\t\t\t\t\t\tp = (a - x) / n1;\n\t\t\t\t\t\t\t\tq = b / n1;\n\t\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\t\ty /= n1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tn2 = sqrt(n2 + y * y);\n\t\t\t\t\t\t\t\tp = c / n2;\n\t\t\t\t\t\t\t\tq = (d - x) / n2;\n\t\t\t\t\t\t\t\tx = y / n2;\n\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ0 = new T([\n\t\t\t\t\t\t\t\t[q, -p],\n\t\t\t\t\t\t\t\t[p, q]\n\t\t\t\t\t\t\t], [\n\t\t\t\t\t\t\t\t[x, y],\n\t\t\t\t\t\t\t\t[y, -x]\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\tQ.setRows(i, j, Q0.dot(Q.getRows(i, j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar R = Q.dot(A).dot(Q.transjugate()),\n\t\t\t\t\tn = A.length,\n\t\t\t\t\tE = numeric.T.identity(n);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tfor (k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tvar Rk = R.get([k, k]),\n\t\t\t\t\t\t\t\tRj = R.get([j, j]);\n\t\t\t\t\t\t\tif (numeric.neq(Rk.x, Rj.x) || numeric.neq(Rk.y, Rj.y)) {\n\t\t\t\t\t\t\t\tx = R.getRow(k).getBlock([k], [j - 1]);\n\t\t\t\t\t\t\t\ty = E.getRow(j).getBlock([k], [j - 1]);\n\t\t\t\t\t\t\t\tE.set([j, k], (R.get([k, j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tE.setRow(j, E.getRow(k));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tx = E.getRow(j);\n\t\t\t\t\tE.setRow(j, x.div(x.norm2()));\n\t\t\t\t}\n\t\t\t\tE = E.transpose();\n\t\t\t\tE = Q.transjugate().dot(E);\n\t\t\t\treturn {\n\t\t\t\t\tlambda: R.getDiag(),\n\t\t\t\t\tE: E\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// 5. Compressed Column Storage matrices\n\t\t\tnumeric.ccsSparse = function ccsSparse(A) {\n\t\t\t\tvar m = A.length,\n\t\t\t\t\tn, foo, i, j, counts = [];\n\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\tfoo = A[i];\n\t\t\t\t\tfor (j in foo) {\n\t\t\t\t\t\tj = parseInt(j);\n\t\t\t\t\t\twhile (j >= counts.length) counts[counts.length] = 0;\n\t\t\t\t\t\tif (foo[j] !== 0) counts[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar n = counts.length;\n\t\t\t\tvar Ai = Array(n + 1);\n\t\t\t\tAi[0] = 0;\n\t\t\t\tfor (i = 0; i < n; ++i) Ai[i + 1] = Ai[i] + counts[i];\n\t\t\t\tvar Aj = Array(Ai[n]),\n\t\t\t\t\tAv = Array(Ai[n]);\n\t\t\t\tfor (i = m - 1; i !== -1; --i) {\n\t\t\t\t\tfoo = A[i];\n\t\t\t\t\tfor (j in foo) {\n\t\t\t\t\t\tif (foo[j] !== 0) {\n\t\t\t\t\t\t\tcounts[j]--;\n\t\t\t\t\t\t\tAj[Ai[j] + counts[j]] = i;\n\t\t\t\t\t\t\tAv[Ai[j] + counts[j]] = foo[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [Ai, Aj, Av];\n\t\t\t};\n\t\t\tnumeric.ccsFull = function ccsFull(A) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\ts = numeric.ccsDim(A),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1],\n\t\t\t\t\ti, j, j0, j1, k;\n\t\t\t\tvar B = numeric.rep([m, n], 0);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tj0 = Ai[i];\n\t\t\t\t\tj1 = Ai[i + 1];\n\t\t\t\t\tfor (j = j0; j < j1; ++j) {\n\t\t\t\t\t\tB[Aj[j]][i] = Av[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn B;\n\t\t\t};\n\t\t\tnumeric.ccsTSolve = function ccsTSolve(A, b, x, bj, xj) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tm = Ai.length - 1,\n\t\t\t\t\tmax = Math.max,\n\t\t\t\t\tn = 0;\n\t\t\t\tif (typeof bj === \"undefined\") x = numeric.rep([m], 0);\n\t\t\t\tif (typeof bj === \"undefined\") bj = numeric.linspace(0, x.length - 1);\n\t\t\t\tif (typeof xj === \"undefined\") xj = [];\n\n\t\t\t\tfunction dfs(j) {\n\t\t\t\t\tvar k;\n\t\t\t\t\tif (x[j] !== 0) return;\n\t\t\t\t\tx[j] = 1;\n\t\t\t\t\tfor (k = Ai[j]; k < Ai[j + 1]; ++k) dfs(Aj[k]);\n\t\t\t\t\txj[n] = j;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\tvar i, j, j0, j1, k, l, l0, l1, a;\n\t\t\t\tfor (i = bj.length - 1; i !== -1; --i) {\n\t\t\t\t\tdfs(bj[i]);\n\t\t\t\t}\n\t\t\t\txj.length = n;\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tx[xj[i]] = 0;\n\t\t\t\t}\n\t\t\t\tfor (i = bj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = bj[i];\n\t\t\t\t\tx[j] = b[j];\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\tj0 = Ai[j];\n\t\t\t\t\tj1 = max(Ai[j + 1], j0);\n\t\t\t\t\tfor (k = j0; k !== j1; ++k) {\n\t\t\t\t\t\tif (Aj[k] === j) {\n\t\t\t\t\t\t\tx[j] /= Av[k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = x[j];\n\t\t\t\t\tfor (k = j0; k !== j1; ++k) {\n\t\t\t\t\t\tl = Aj[k];\n\t\t\t\t\t\tif (l !== j) x[l] -= a * Av[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t};\n\t\t\tnumeric.ccsDFS = function ccsDFS(n) {\n\t\t\t\tthis.k = Array(n);\n\t\t\t\tthis.k1 = Array(n);\n\t\t\t\tthis.j = Array(n);\n\t\t\t};\n\t\t\tnumeric.ccsDFS.prototype.dfs = function dfs(J, Ai, Aj, x, xj, Pinv) {\n\t\t\t\tvar m = 0,\n\t\t\t\t\tfoo, n = xj.length;\n\t\t\t\tvar k = this.k,\n\t\t\t\t\tk1 = this.k1,\n\t\t\t\t\tj = this.j,\n\t\t\t\t\tkm, k11;\n\t\t\t\tif (x[J] !== 0) return;\n\t\t\t\tx[J] = 1;\n\t\t\t\tj[0] = J;\n\t\t\t\tk[0] = km = Ai[J];\n\t\t\t\tk1[0] = k11 = Ai[J + 1];\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (km >= k11) {\n\t\t\t\t\t\txj[n] = j[m];\n\t\t\t\t\t\tif (m === 0) return;\n\t\t\t\t\t\t++n;\n\t\t\t\t\t\t--m;\n\t\t\t\t\t\tkm = k[m];\n\t\t\t\t\t\tk11 = k1[m];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfoo = Pinv[Aj[km]];\n\t\t\t\t\t\tif (x[foo] === 0) {\n\t\t\t\t\t\t\tx[foo] = 1;\n\t\t\t\t\t\t\tk[m] = km;\n\t\t\t\t\t\t\t++m;\n\t\t\t\t\t\t\tj[m] = foo;\n\t\t\t\t\t\t\tkm = Ai[foo];\n\t\t\t\t\t\t\tk1[m] = k11 = Ai[foo + 1];\n\t\t\t\t\t\t} else ++km;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ccsLPSolve = function ccsLPSolve(A, B, x, xj, I, Pinv, dfs) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tm = Ai.length - 1,\n\t\t\t\t\tn = 0;\n\t\t\t\tvar Bi = B[0],\n\t\t\t\t\tBj = B[1],\n\t\t\t\t\tBv = B[2];\n\n\t\t\t\tvar i, i0, i1, j, J, j0, j1, k, l, l0, l1, a;\n\t\t\t\ti0 = Bi[I];\n\t\t\t\ti1 = Bi[I + 1];\n\t\t\t\txj.length = 0;\n\t\t\t\tfor (i = i0; i < i1; ++i) {\n\t\t\t\t\tdfs.dfs(Pinv[Bj[i]], Ai, Aj, x, xj, Pinv);\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tx[xj[i]] = 0;\n\t\t\t\t}\n\t\t\t\tfor (i = i0; i !== i1; ++i) {\n\t\t\t\t\tj = Pinv[Bj[i]];\n\t\t\t\t\tx[j] = Bv[i];\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\tj0 = Ai[j];\n\t\t\t\t\tj1 = Ai[j + 1];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) {\n\t\t\t\t\t\tif (Pinv[Aj[k]] === j) {\n\t\t\t\t\t\t\tx[j] /= Av[k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = x[j];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) {\n\t\t\t\t\t\tl = Pinv[Aj[k]];\n\t\t\t\t\t\tif (l !== j) x[l] -= a * Av[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t};\n\t\t\tnumeric.ccsLUP1 = function ccsLUP1(A, threshold) {\n\t\t\t\tvar m = A[0].length - 1;\n\t\t\t\tvar L = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t],\n\t\t\t\t\tU = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t];\n\t\t\t\tvar Li = L[0],\n\t\t\t\t\tLj = L[1],\n\t\t\t\t\tLv = L[2],\n\t\t\t\t\tUi = U[0],\n\t\t\t\t\tUj = U[1],\n\t\t\t\t\tUv = U[2];\n\t\t\t\tvar x = numeric.rep([m], 0),\n\t\t\t\t\txj = numeric.rep([m], 0);\n\t\t\t\tvar i, j, k, j0, j1, a, e, c, d, K;\n\t\t\t\tvar sol = numeric.ccsLPSolve,\n\t\t\t\t\tmax = Math.max,\n\t\t\t\t\tabs = Math.abs;\n\t\t\t\tvar P = numeric.linspace(0, m - 1),\n\t\t\t\t\tPinv = numeric.linspace(0, m - 1);\n\t\t\t\tvar dfs = new numeric.ccsDFS(m);\n\t\t\t\tif (typeof threshold === \"undefined\") {\n\t\t\t\t\tthreshold = 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tsol(L, A, x, xj, i, Pinv, dfs);\n\t\t\t\t\ta = -1;\n\t\t\t\t\te = -1;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tif (k <= i) continue;\n\t\t\t\t\t\tc = abs(x[k]);\n\t\t\t\t\t\tif (c > a) {\n\t\t\t\t\t\t\te = k;\n\t\t\t\t\t\t\ta = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(x[i]) < threshold * a) {\n\t\t\t\t\t\tj = P[i];\n\t\t\t\t\t\ta = P[e];\n\t\t\t\t\t\tP[i] = a;\n\t\t\t\t\t\tPinv[a] = i;\n\t\t\t\t\t\tP[e] = j;\n\t\t\t\t\t\tPinv[j] = e;\n\t\t\t\t\t\ta = x[i];\n\t\t\t\t\t\tx[i] = x[e];\n\t\t\t\t\t\tx[e] = a;\n\t\t\t\t\t}\n\t\t\t\t\ta = Li[i];\n\t\t\t\t\te = Ui[i];\n\t\t\t\t\td = x[i];\n\t\t\t\t\tLj[a] = P[i];\n\t\t\t\t\tLv[a] = 1;\n\t\t\t\t\t++a;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tc = x[k];\n\t\t\t\t\t\txj[j] = 0;\n\t\t\t\t\t\tx[k] = 0;\n\t\t\t\t\t\tif (k <= i) {\n\t\t\t\t\t\t\tUj[e] = k;\n\t\t\t\t\t\t\tUv[e] = c;\n\t\t\t\t\t\t\t++e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLj[a] = P[k];\n\t\t\t\t\t\t\tLv[a] = c / d;\n\t\t\t\t\t\t\t++a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLi[i + 1] = a;\n\t\t\t\t\tUi[i + 1] = e;\n\t\t\t\t}\n\t\t\t\tfor (j = Lj.length - 1; j !== -1; --j) {\n\t\t\t\t\tLj[j] = Pinv[Lj[j]];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tL: L,\n\t\t\t\t\tU: U,\n\t\t\t\t\tP: P,\n\t\t\t\t\tPinv: Pinv\n\t\t\t\t};\n\t\t\t};\n\t\t\tnumeric.ccsDFS0 = function ccsDFS0(n) {\n\t\t\t\tthis.k = Array(n);\n\t\t\t\tthis.k1 = Array(n);\n\t\t\t\tthis.j = Array(n);\n\t\t\t};\n\t\t\tnumeric.ccsDFS0.prototype.dfs = function dfs(J, Ai, Aj, x, xj, Pinv, P) {\n\t\t\t\tvar m = 0,\n\t\t\t\t\tfoo, n = xj.length;\n\t\t\t\tvar k = this.k,\n\t\t\t\t\tk1 = this.k1,\n\t\t\t\t\tj = this.j,\n\t\t\t\t\tkm, k11;\n\t\t\t\tif (x[J] !== 0) return;\n\t\t\t\tx[J] = 1;\n\t\t\t\tj[0] = J;\n\t\t\t\tk[0] = km = Ai[Pinv[J]];\n\t\t\t\tk1[0] = k11 = Ai[Pinv[J] + 1];\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (isNaN(km)) throw new Error(\"Ow!\");\n\t\t\t\t\tif (km >= k11) {\n\t\t\t\t\t\txj[n] = Pinv[j[m]];\n\t\t\t\t\t\tif (m === 0) return;\n\t\t\t\t\t\t++n;\n\t\t\t\t\t\t--m;\n\t\t\t\t\t\tkm = k[m];\n\t\t\t\t\t\tk11 = k1[m];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfoo = Aj[km];\n\t\t\t\t\t\tif (x[foo] === 0) {\n\t\t\t\t\t\t\tx[foo] = 1;\n\t\t\t\t\t\t\tk[m] = km;\n\t\t\t\t\t\t\t++m;\n\t\t\t\t\t\t\tj[m] = foo;\n\t\t\t\t\t\t\tfoo = Pinv[foo];\n\t\t\t\t\t\t\tkm = Ai[foo];\n\t\t\t\t\t\t\tk1[m] = k11 = Ai[foo + 1];\n\t\t\t\t\t\t} else ++km;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ccsLPSolve0 = function ccsLPSolve0(A, B, y, xj, I, Pinv, P, dfs) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tm = Ai.length - 1,\n\t\t\t\t\tn = 0;\n\t\t\t\tvar Bi = B[0],\n\t\t\t\t\tBj = B[1],\n\t\t\t\t\tBv = B[2];\n\n\t\t\t\tvar i, i0, i1, j, J, j0, j1, k, l, l0, l1, a;\n\t\t\t\ti0 = Bi[I];\n\t\t\t\ti1 = Bi[I + 1];\n\t\t\t\txj.length = 0;\n\t\t\t\tfor (i = i0; i < i1; ++i) {\n\t\t\t\t\tdfs.dfs(Bj[i], Ai, Aj, y, xj, Pinv, P);\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\ty[P[j]] = 0;\n\t\t\t\t}\n\t\t\t\tfor (i = i0; i !== i1; ++i) {\n\t\t\t\t\tj = Bj[i];\n\t\t\t\t\ty[j] = Bv[i];\n\t\t\t\t}\n\t\t\t\tfor (i = xj.length - 1; i !== -1; --i) {\n\t\t\t\t\tj = xj[i];\n\t\t\t\t\tl = P[j];\n\t\t\t\t\tj0 = Ai[j];\n\t\t\t\t\tj1 = Ai[j + 1];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) {\n\t\t\t\t\t\tif (Aj[k] === l) {\n\t\t\t\t\t\t\ty[l] /= Av[k];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = y[l];\n\t\t\t\t\tfor (k = j0; k < j1; ++k) y[Aj[k]] -= a * Av[k];\n\t\t\t\t\ty[l] = a;\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ccsLUP0 = function ccsLUP0(A, threshold) {\n\t\t\t\tvar m = A[0].length - 1;\n\t\t\t\tvar L = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t],\n\t\t\t\t\tU = [numeric.rep([m + 1], 0), [],\n\t\t\t\t\t\t[]\n\t\t\t\t\t];\n\t\t\t\tvar Li = L[0],\n\t\t\t\t\tLj = L[1],\n\t\t\t\t\tLv = L[2],\n\t\t\t\t\tUi = U[0],\n\t\t\t\t\tUj = U[1],\n\t\t\t\t\tUv = U[2];\n\t\t\t\tvar y = numeric.rep([m], 0),\n\t\t\t\t\txj = numeric.rep([m], 0);\n\t\t\t\tvar i, j, k, j0, j1, a, e, c, d, K;\n\t\t\t\tvar sol = numeric.ccsLPSolve0,\n\t\t\t\t\tmax = Math.max,\n\t\t\t\t\tabs = Math.abs;\n\t\t\t\tvar P = numeric.linspace(0, m - 1),\n\t\t\t\t\tPinv = numeric.linspace(0, m - 1);\n\t\t\t\tvar dfs = new numeric.ccsDFS0(m);\n\t\t\t\tif (typeof threshold === \"undefined\") {\n\t\t\t\t\tthreshold = 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tsol(L, A, y, xj, i, Pinv, P, dfs);\n\t\t\t\t\ta = -1;\n\t\t\t\t\te = -1;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tif (k <= i) continue;\n\t\t\t\t\t\tc = abs(y[P[k]]);\n\t\t\t\t\t\tif (c > a) {\n\t\t\t\t\t\t\te = k;\n\t\t\t\t\t\t\ta = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(y[P[i]]) < threshold * a) {\n\t\t\t\t\t\tj = P[i];\n\t\t\t\t\t\ta = P[e];\n\t\t\t\t\t\tP[i] = a;\n\t\t\t\t\t\tPinv[a] = i;\n\t\t\t\t\t\tP[e] = j;\n\t\t\t\t\t\tPinv[j] = e;\n\t\t\t\t\t}\n\t\t\t\t\ta = Li[i];\n\t\t\t\t\te = Ui[i];\n\t\t\t\t\td = y[P[i]];\n\t\t\t\t\tLj[a] = P[i];\n\t\t\t\t\tLv[a] = 1;\n\t\t\t\t\t++a;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tk = xj[j];\n\t\t\t\t\t\tc = y[P[k]];\n\t\t\t\t\t\txj[j] = 0;\n\t\t\t\t\t\ty[P[k]] = 0;\n\t\t\t\t\t\tif (k <= i) {\n\t\t\t\t\t\t\tUj[e] = k;\n\t\t\t\t\t\t\tUv[e] = c;\n\t\t\t\t\t\t\t++e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLj[a] = P[k];\n\t\t\t\t\t\t\tLv[a] = c / d;\n\t\t\t\t\t\t\t++a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLi[i + 1] = a;\n\t\t\t\t\tUi[i + 1] = e;\n\t\t\t\t}\n\t\t\t\tfor (j = Lj.length - 1; j !== -1; --j) {\n\t\t\t\t\tLj[j] = Pinv[Lj[j]];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tL: L,\n\t\t\t\t\tU: U,\n\t\t\t\t\tP: P,\n\t\t\t\t\tPinv: Pinv\n\t\t\t\t};\n\t\t\t};\n\t\t\tnumeric.ccsLUP = numeric.ccsLUP0;\n\n\t\t\tnumeric.ccsDim = function ccsDim(A) {\n\t\t\t\treturn [numeric.sup(A[1]) + 1, A[0].length - 1];\n\t\t\t};\n\t\t\tnumeric.ccsGetBlock = function ccsGetBlock(A, i, j) {\n\t\t\t\tvar s = numeric.ccsDim(A),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1];\n\t\t\t\tif (typeof i === \"undefined\") {\n\t\t\t\t\ti = numeric.linspace(0, m - 1);\n\t\t\t\t} else if (typeof i === \"number\") {\n\t\t\t\t\ti = [i];\n\t\t\t\t}\n\t\t\t\tif (typeof j === \"undefined\") {\n\t\t\t\t\tj = numeric.linspace(0, n - 1);\n\t\t\t\t} else if (typeof j === \"number\") {\n\t\t\t\t\tj = [j];\n\t\t\t\t}\n\t\t\t\tvar p, p0, p1, P = i.length,\n\t\t\t\t\tq, Q = j.length,\n\t\t\t\t\tr, jq, ip;\n\t\t\t\tvar Bi = numeric.rep([n], 0),\n\t\t\t\t\tBj = [],\n\t\t\t\t\tBv = [],\n\t\t\t\t\tB = [Bi, Bj, Bv];\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar x = numeric.rep([m], 0),\n\t\t\t\t\tcount = 0,\n\t\t\t\t\tflags = numeric.rep([m], 0);\n\t\t\t\tfor (q = 0; q < Q; ++q) {\n\t\t\t\t\tjq = j[q];\n\t\t\t\t\tq0 = Ai[jq];\n\t\t\t\t\tq1 = Ai[jq + 1];\n\t\t\t\t\tfor (p = q0; p < q1; ++p) {\n\t\t\t\t\t\tr = Aj[p];\n\t\t\t\t\t\tflags[r] = 1;\n\t\t\t\t\t\tx[r] = Av[p];\n\t\t\t\t\t}\n\t\t\t\t\tfor (p = 0; p < P; ++p) {\n\t\t\t\t\t\tip = i[p];\n\t\t\t\t\t\tif (flags[ip]) {\n\t\t\t\t\t\t\tBj[count] = p;\n\t\t\t\t\t\t\tBv[count] = x[i[p]];\n\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (p = q0; p < q1; ++p) {\n\t\t\t\t\t\tr = Aj[p];\n\t\t\t\t\t\tflags[r] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tBi[q + 1] = count;\n\t\t\t\t}\n\t\t\t\treturn B;\n\t\t\t};\n\n\t\t\tnumeric.ccsDot = function ccsDot(A, B) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar Bi = B[0],\n\t\t\t\t\tBj = B[1],\n\t\t\t\t\tBv = B[2];\n\t\t\t\tvar sA = numeric.ccsDim(A),\n\t\t\t\t\tsB = numeric.ccsDim(B);\n\t\t\t\tvar m = sA[0],\n\t\t\t\t\tn = sA[1],\n\t\t\t\t\to = sB[1];\n\t\t\t\tvar x = numeric.rep([m], 0),\n\t\t\t\t\tflags = numeric.rep([m], 0),\n\t\t\t\t\txj = Array(m);\n\t\t\t\tvar Ci = numeric.rep([o], 0),\n\t\t\t\t\tCj = [],\n\t\t\t\t\tCv = [],\n\t\t\t\t\tC = [Ci, Cj, Cv];\n\t\t\t\tvar i, j, k, j0, j1, i0, i1, l, p, a, b;\n\t\t\t\tfor (k = 0; k !== o; ++k) {\n\t\t\t\t\tj0 = Bi[k];\n\t\t\t\t\tj1 = Bi[k + 1];\n\t\t\t\t\tp = 0;\n\t\t\t\t\tfor (j = j0; j < j1; ++j) {\n\t\t\t\t\t\ta = Bj[j];\n\t\t\t\t\t\tb = Bv[j];\n\t\t\t\t\t\ti0 = Ai[a];\n\t\t\t\t\t\ti1 = Ai[a + 1];\n\t\t\t\t\t\tfor (i = i0; i < i1; ++i) {\n\t\t\t\t\t\t\tl = Aj[i];\n\t\t\t\t\t\t\tif (flags[l] === 0) {\n\t\t\t\t\t\t\t\txj[p] = l;\n\t\t\t\t\t\t\t\tflags[l] = 1;\n\t\t\t\t\t\t\t\tp = p + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx[l] = x[l] + Av[i] * b;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj0 = Ci[k];\n\t\t\t\t\tj1 = j0 + p;\n\t\t\t\t\tCi[k + 1] = j1;\n\t\t\t\t\tfor (j = p - 1; j !== -1; --j) {\n\t\t\t\t\t\tb = j0 + j;\n\t\t\t\t\t\ti = xj[j];\n\t\t\t\t\t\tCj[b] = i;\n\t\t\t\t\t\tCv[b] = x[i];\n\t\t\t\t\t\tflags[i] = 0;\n\t\t\t\t\t\tx[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tCi[k + 1] = Ci[k] + p;\n\t\t\t\t}\n\t\t\t\treturn C;\n\t\t\t};\n\n\t\t\tnumeric.ccsLUPSolve = function ccsLUPSolve(LUP, B) {\n\t\t\t\tvar L = LUP.L,\n\t\t\t\t\tU = LUP.U,\n\t\t\t\t\tP = LUP.P;\n\t\t\t\tvar Bi = B[0];\n\t\t\t\tvar flag = false;\n\t\t\t\tif (typeof Bi !== \"object\") {\n\t\t\t\t\tB = [\n\t\t\t\t\t\t[0, B.length], numeric.linspace(0, B.length - 1), B\n\t\t\t\t\t];\n\t\t\t\t\tBi = B[0];\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tvar Bj = B[1],\n\t\t\t\t\tBv = B[2];\n\t\t\t\tvar n = L[0].length - 1,\n\t\t\t\t\tm = Bi.length - 1;\n\t\t\t\tvar x = numeric.rep([n], 0),\n\t\t\t\t\txj = Array(n);\n\t\t\t\tvar b = numeric.rep([n], 0),\n\t\t\t\t\tbj = Array(n);\n\t\t\t\tvar Xi = numeric.rep([m + 1], 0),\n\t\t\t\t\tXj = [],\n\t\t\t\t\tXv = [];\n\t\t\t\tvar sol = numeric.ccsTSolve;\n\t\t\t\tvar i, j, j0, j1, k, J, N = 0;\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tk = 0;\n\t\t\t\t\tj0 = Bi[i];\n\t\t\t\t\tj1 = Bi[i + 1];\n\t\t\t\t\tfor (j = j0; j < j1; ++j) {\n\t\t\t\t\t\tJ = LUP.Pinv[Bj[j]];\n\t\t\t\t\t\tbj[k] = J;\n\t\t\t\t\t\tb[J] = Bv[j];\n\t\t\t\t\t\t++k;\n\t\t\t\t\t}\n\t\t\t\t\tbj.length = k;\n\t\t\t\t\tsol(L, b, x, bj, xj);\n\t\t\t\t\tfor (j = bj.length - 1; j !== -1; --j) b[bj[j]] = 0;\n\t\t\t\t\tsol(U, x, b, xj, bj);\n\t\t\t\t\tif (flag) return b;\n\t\t\t\t\tfor (j = xj.length - 1; j !== -1; --j) x[xj[j]] = 0;\n\t\t\t\t\tfor (j = bj.length - 1; j !== -1; --j) {\n\t\t\t\t\t\tJ = bj[j];\n\t\t\t\t\t\tXj[N] = J;\n\t\t\t\t\t\tXv[N] = b[J];\n\t\t\t\t\t\tb[J] = 0;\n\t\t\t\t\t\t++N;\n\t\t\t\t\t}\n\t\t\t\t\tXi[i + 1] = N;\n\t\t\t\t}\n\t\t\t\treturn [Xi, Xj, Xv];\n\t\t\t};\n\n\t\t\tnumeric.ccsbinop = function ccsbinop(body, setup) {\n\t\t\t\tif (typeof setup === \"undefined\") setup = '';\n\t\t\t\treturn numeric.Function('X', 'Y',\n\t\t\t\t\t'var Xi = X[0], Xj = X[1], Xv = X[2];\\n' +\n\t\t\t\t\t'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\\n' +\n\t\t\t\t\t'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\\n' +\n\t\t\t\t\t'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\\n' +\n\t\t\t\t\t'var x = numeric.rep([m],0),y = numeric.rep([m],0);\\n' +\n\t\t\t\t\t'var xk,yk,zk;\\n' +\n\t\t\t\t\t'var i,j,j0,j1,k,p=0;\\n' +\n\t\t\t\t\tsetup +\n\t\t\t\t\t'for(i=0;i<n;++i) {\\n' +\n\t\t\t\t\t'  j0 = Xi[i]; j1 = Xi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) {\\n' +\n\t\t\t\t\t'    k = Xj[j];\\n' +\n\t\t\t\t\t'    x[k] = 1;\\n' +\n\t\t\t\t\t'    Zj[p] = k;\\n' +\n\t\t\t\t\t'    ++p;\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  j0 = Yi[i]; j1 = Yi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) {\\n' +\n\t\t\t\t\t'    k = Yj[j];\\n' +\n\t\t\t\t\t'    y[k] = Yv[j];\\n' +\n\t\t\t\t\t'    if(x[k] === 0) {\\n' +\n\t\t\t\t\t'      Zj[p] = k;\\n' +\n\t\t\t\t\t'      ++p;\\n' +\n\t\t\t\t\t'    }\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  Zi[i+1] = p;\\n' +\n\t\t\t\t\t'  j0 = Xi[i]; j1 = Xi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\\n' +\n\t\t\t\t\t'  j0 = Zi[i]; j1 = Zi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) {\\n' +\n\t\t\t\t\t'    k = Zj[j];\\n' +\n\t\t\t\t\t'    xk = x[k];\\n' +\n\t\t\t\t\t'    yk = y[k];\\n' +\n\t\t\t\t\tbody + '\\n' +\n\t\t\t\t\t'    Zv[j] = zk;\\n' +\n\t\t\t\t\t'  }\\n' +\n\t\t\t\t\t'  j0 = Xi[i]; j1 = Xi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\\n' +\n\t\t\t\t\t'  j0 = Yi[i]; j1 = Yi[i+1];\\n' +\n\t\t\t\t\t'  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\\n' +\n\t\t\t\t\t'}\\n' +\n\t\t\t\t\t'return [Zi,Zj,Zv];'\n\t\t\t\t);\n\t\t\t};\n\n\t\t\t(function() {\n\t\t\t\tvar k, A, B, C;\n\t\t\t\tfor (k in numeric.ops2) {\n\t\t\t\t\tif (isFinite(eval('1' + numeric.ops2[k] + '0'))) A = '[Y[0],Y[1],numeric.' + k + '(X,Y[2])]';\n\t\t\t\t\telse A = 'NaN';\n\t\t\t\t\tif (isFinite(eval('0' + numeric.ops2[k] + '1'))) B = '[X[0],X[1],numeric.' + k + '(X[2],Y)]';\n\t\t\t\t\telse B = 'NaN';\n\t\t\t\t\tif (isFinite(eval('1' + numeric.ops2[k] + '0')) && isFinite(eval('0' + numeric.ops2[k] + '1'))) C = 'numeric.ccs' + k + 'MM(X,Y)';\n\t\t\t\t\telse C = 'NaN';\n\t\t\t\t\tnumeric['ccs' + k + 'MM'] = numeric.ccsbinop('zk = xk ' + numeric.ops2[k] + 'yk;');\n\t\t\t\t\tnumeric['ccs' + k] = numeric.Function('X', 'Y',\n\t\t\t\t\t\t'if(typeof X === \"number\") return ' + A + ';\\n' +\n\t\t\t\t\t\t'if(typeof Y === \"number\") return ' + B + ';\\n' +\n\t\t\t\t\t\t'return ' + C + ';\\n'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}());\n\n\t\t\tnumeric.ccsScatter = function ccsScatter(A) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar n = numeric.sup(Aj) + 1,\n\t\t\t\t\tm = Ai.length;\n\t\t\t\tvar Ri = numeric.rep([n], 0),\n\t\t\t\t\tRj = Array(m),\n\t\t\t\t\tRv = Array(m);\n\t\t\t\tvar counts = numeric.rep([n], 0),\n\t\t\t\t\ti;\n\t\t\t\tfor (i = 0; i < m; ++i) counts[Aj[i]]++;\n\t\t\t\tfor (i = 0; i < n; ++i) Ri[i + 1] = Ri[i] + counts[i];\n\t\t\t\tvar ptr = Ri.slice(0),\n\t\t\t\t\tk, Aii;\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tAii = Aj[i];\n\t\t\t\t\tk = ptr[Aii];\n\t\t\t\t\tRj[k] = Ai[i];\n\t\t\t\t\tRv[k] = Av[i];\n\t\t\t\t\tptr[Aii] = ptr[Aii] + 1;\n\t\t\t\t}\n\t\t\t\treturn [Ri, Rj, Rv];\n\t\t\t};\n\n\t\t\tnumeric.ccsGather = function ccsGather(A) {\n\t\t\t\tvar Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2];\n\t\t\t\tvar n = Ai.length - 1,\n\t\t\t\t\tm = Aj.length;\n\t\t\t\tvar Ri = Array(m),\n\t\t\t\t\tRj = Array(m),\n\t\t\t\t\tRv = Array(m);\n\t\t\t\tvar i, j, j0, j1, p;\n\t\t\t\tp = 0;\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tj0 = Ai[i];\n\t\t\t\t\tj1 = Ai[i + 1];\n\t\t\t\t\tfor (j = j0; j !== j1; ++j) {\n\t\t\t\t\t\tRj[p] = i;\n\t\t\t\t\t\tRi[p] = Aj[j];\n\t\t\t\t\t\tRv[p] = Av[j];\n\t\t\t\t\t\t++p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [Ri, Rj, Rv];\n\t\t\t};\n\n\t\t\t// The following sparse linear algebra routines are deprecated.\n\n\t\t\tnumeric.sdim = function dim(A, ret, k) {\n\t\t\t\tif (typeof ret === \"undefined\") {\n\t\t\t\t\tret = [];\n\t\t\t\t}\n\t\t\t\tif (typeof A !== \"object\") return ret;\n\t\t\t\tif (typeof k === \"undefined\") {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tif (!(k in ret)) {\n\t\t\t\t\tret[k] = 0;\n\t\t\t\t}\n\t\t\t\tif (A.length > ret[k]) ret[k] = A.length;\n\t\t\t\tvar i;\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (A.hasOwnProperty(i)) dim(A[i], ret, k + 1);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sclone = function clone(A, k, n) {\n\t\t\t\tif (typeof k === \"undefined\") {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tif (typeof n === \"undefined\") {\n\t\t\t\t\tn = numeric.sdim(A).length;\n\t\t\t\t}\n\t\t\t\tvar i, ret = Array(A.length);\n\t\t\t\tif (k === n - 1) {\n\t\t\t\t\tfor (i in A) {\n\t\t\t\t\t\tif (A.hasOwnProperty(i)) ret[i] = A[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (A.hasOwnProperty(i)) ret[i] = clone(A[i], k + 1, n);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdiag = function diag(d) {\n\t\t\t\tvar n = d.length,\n\t\t\t\t\ti, ret = Array(n),\n\t\t\t\t\ti1, i2, i3;\n\t\t\t\tfor (i = n - 1; i >= 1; i -= 2) {\n\t\t\t\t\ti1 = i - 1;\n\t\t\t\t\tret[i] = [];\n\t\t\t\t\tret[i][i] = d[i];\n\t\t\t\t\tret[i1] = [];\n\t\t\t\t\tret[i1][i1] = d[i1];\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tret[0] = [];\n\t\t\t\t\tret[0][0] = d[i];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sidentity = function identity(n) {\n\t\t\t\treturn numeric.sdiag(numeric.rep([n], 1));\n\t\t\t};\n\n\t\t\tnumeric.stranspose = function transpose(A) {\n\t\t\t\tvar ret = [],\n\t\t\t\t\tn = A.length,\n\t\t\t\t\ti, j, Ai;\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (!(A.hasOwnProperty(i))) continue;\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\tif (!(Ai.hasOwnProperty(j))) continue;\n\t\t\t\t\t\tif (typeof ret[j] !== \"object\") {\n\t\t\t\t\t\t\tret[j] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret[j][i] = Ai[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sLUP = function LUP(A, tol) {\n\t\t\t\tthrow new Error(\"The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.\");\n\t\t\t};\n\n\t\t\tnumeric.sdotMM = function dotMM(A, B) {\n\t\t\t\tvar p = A.length,\n\t\t\t\t\tq = B.length,\n\t\t\t\t\tBT = numeric.stranspose(B),\n\t\t\t\t\tr = BT.length,\n\t\t\t\t\tAi, BTk;\n\t\t\t\tvar i, j, k, accum;\n\t\t\t\tvar ret = Array(p),\n\t\t\t\t\treti;\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\treti = [];\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\tfor (k = r - 1; k >= 0; k--) {\n\t\t\t\t\t\taccum = 0;\n\t\t\t\t\t\tBTk = BT[k];\n\t\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\t\tif (!(Ai.hasOwnProperty(j))) continue;\n\t\t\t\t\t\t\tif (j in BTk) {\n\t\t\t\t\t\t\t\taccum += Ai[j] * BTk[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accum) reti[k] = accum;\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = reti;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdotMV = function dotMV(A, x) {\n\t\t\t\tvar p = A.length,\n\t\t\t\t\tAi, i, j;\n\t\t\t\tvar ret = Array(p),\n\t\t\t\t\taccum;\n\t\t\t\tfor (i = p - 1; i >= 0; i--) {\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\taccum = 0;\n\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\tif (!(Ai.hasOwnProperty(j))) continue;\n\t\t\t\t\t\tif (x[j]) accum += Ai[j] * x[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (accum) ret[i] = accum;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdotVM = function dotMV(x, A) {\n\t\t\t\tvar i, j, Ai, alpha;\n\t\t\t\tvar ret = [],\n\t\t\t\t\taccum;\n\t\t\t\tfor (i in x) {\n\t\t\t\t\tif (!x.hasOwnProperty(i)) continue;\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\talpha = x[i];\n\t\t\t\t\tfor (j in Ai) {\n\t\t\t\t\t\tif (!Ai.hasOwnProperty(j)) continue;\n\t\t\t\t\t\tif (!ret[j]) {\n\t\t\t\t\t\t\tret[j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret[j] += alpha * Ai[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdotVV = function dotVV(x, y) {\n\t\t\t\tvar i, ret = 0;\n\t\t\t\tfor (i in x) {\n\t\t\t\t\tif (x[i] && y[i]) ret += x[i] * y[i];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.sdot = function dot(A, B) {\n\t\t\t\tvar m = numeric.sdim(A).length,\n\t\t\t\t\tn = numeric.sdim(B).length;\n\t\t\t\tvar k = m * 1000 + n;\n\t\t\t\tswitch (k) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn A * B;\n\t\t\t\t\tcase 1001:\n\t\t\t\t\t\treturn numeric.sdotVV(A, B);\n\t\t\t\t\tcase 2001:\n\t\t\t\t\t\treturn numeric.sdotMV(A, B);\n\t\t\t\t\tcase 1002:\n\t\t\t\t\t\treturn numeric.sdotVM(A, B);\n\t\t\t\t\tcase 2002:\n\t\t\t\t\t\treturn numeric.sdotMM(A, B);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('numeric.sdot not implemented for tensors of order ' + m + ' and ' + n);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnumeric.sscatter = function scatter(V) {\n\t\t\t\tvar n = V[0].length,\n\t\t\t\t\tVij, i, j, m = V.length,\n\t\t\t\t\tA = [],\n\t\t\t\t\tAj;\n\t\t\t\tfor (i = n - 1; i >= 0; --i) {\n\t\t\t\t\tif (!V[m - 1][i]) continue;\n\t\t\t\t\tAj = A;\n\t\t\t\t\tfor (j = 0; j < m - 2; j++) {\n\t\t\t\t\t\tVij = V[j][i];\n\t\t\t\t\t\tif (!Aj[Vij]) Aj[Vij] = [];\n\t\t\t\t\t\tAj = Aj[Vij];\n\t\t\t\t\t}\n\t\t\t\t\tAj[V[j][i]] = V[j + 1][i];\n\t\t\t\t}\n\t\t\t\treturn A;\n\t\t\t};\n\n\t\t\tnumeric.sgather = function gather(A, ret, k) {\n\t\t\t\tif (typeof ret === \"undefined\") ret = [];\n\t\t\t\tif (typeof k === \"undefined\") k = [];\n\t\t\t\tvar n, i, Ai;\n\t\t\t\tn = k.length;\n\t\t\t\tfor (i in A) {\n\t\t\t\t\tif (A.hasOwnProperty(i)) {\n\t\t\t\t\t\tk[n] = parseInt(i);\n\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\tif (typeof Ai === \"number\") {\n\t\t\t\t\t\t\tif (Ai) {\n\t\t\t\t\t\t\t\tif (ret.length === 0) {\n\t\t\t\t\t\t\t\t\tfor (i = n + 1; i >= 0; --i) ret[i] = [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (i = n; i >= 0; --i) ret[i].push(k[i]);\n\t\t\t\t\t\t\t\tret[n + 1].push(Ai);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else gather(Ai, ret, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k.length > n) k.pop();\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\t// 6. Coordinate matrices\n\t\t\tnumeric.cLU = function LU(A) {\n\t\t\t\tvar I = A[0],\n\t\t\t\t\tJ = A[1],\n\t\t\t\t\tV = A[2];\n\t\t\t\tvar p = I.length,\n\t\t\t\t\tm = 0,\n\t\t\t\t\ti, j, k, a, b, c;\n\t\t\t\tfor (i = 0; i < p; i++)\n\t\t\t\t\tif (I[i] > m) m = I[i];\n\t\t\t\tm++;\n\t\t\t\tvar L = Array(m),\n\t\t\t\t\tU = Array(m),\n\t\t\t\t\tleft = numeric.rep([m], Infinity),\n\t\t\t\t\tright = numeric.rep([m], -Infinity);\n\t\t\t\tvar Ui, Uj, alpha;\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\ti = I[k];\n\t\t\t\t\tj = J[k];\n\t\t\t\t\tif (j < left[i]) left[i] = j;\n\t\t\t\t\tif (j > right[i]) right[i] = j;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m - 1; i++) {\n\t\t\t\t\tif (right[i] > right[i + 1]) right[i + 1] = right[i];\n\t\t\t\t}\n\t\t\t\tfor (i = m - 1; i >= 1; i--) {\n\t\t\t\t\tif (left[i] < left[i - 1]) left[i - 1] = left[i];\n\t\t\t\t}\n\t\t\t\tvar countL = 0,\n\t\t\t\t\tcountU = 0;\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\tU[i] = numeric.rep([right[i] - left[i] + 1], 0);\n\t\t\t\t\tL[i] = numeric.rep([i - left[i]], 0);\n\t\t\t\t\tcountL += i - left[i] + 1;\n\t\t\t\t\tcountU += right[i] - i + 1;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\ti = I[k];\n\t\t\t\t\tU[i][J[k] - left[i]] = V[k];\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < m - 1; i++) {\n\t\t\t\t\ta = i - left[i];\n\t\t\t\t\tUi = U[i];\n\t\t\t\t\tfor (j = i + 1; left[j] <= i && j < m; j++) {\n\t\t\t\t\t\tb = i - left[j];\n\t\t\t\t\t\tc = right[i] - i;\n\t\t\t\t\t\tUj = U[j];\n\t\t\t\t\t\talpha = Uj[b] / Ui[a];\n\t\t\t\t\t\tif (alpha) {\n\t\t\t\t\t\t\tfor (k = 1; k <= c; k++) {\n\t\t\t\t\t\t\t\tUj[k + b] -= alpha * Ui[k + a];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tL[j][i - left[j]] = alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar Ui = [],\n\t\t\t\t\tUj = [],\n\t\t\t\t\tUv = [],\n\t\t\t\t\tLi = [],\n\t\t\t\t\tLj = [],\n\t\t\t\t\tLv = [];\n\t\t\t\tvar p, q, foo;\n\t\t\t\tp = 0;\n\t\t\t\tq = 0;\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\ta = left[i];\n\t\t\t\t\tb = right[i];\n\t\t\t\t\tfoo = U[i];\n\t\t\t\t\tfor (j = i; j <= b; j++) {\n\t\t\t\t\t\tif (foo[j - a]) {\n\t\t\t\t\t\t\tUi[p] = i;\n\t\t\t\t\t\t\tUj[p] = j;\n\t\t\t\t\t\t\tUv[p] = foo[j - a];\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfoo = L[i];\n\t\t\t\t\tfor (j = a; j < i; j++) {\n\t\t\t\t\t\tif (foo[j - a]) {\n\t\t\t\t\t\t\tLi[q] = i;\n\t\t\t\t\t\t\tLj[q] = j;\n\t\t\t\t\t\t\tLv[q] = foo[j - a];\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLi[q] = i;\n\t\t\t\t\tLj[q] = i;\n\t\t\t\t\tLv[q] = 1;\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tU: [Ui, Uj, Uv],\n\t\t\t\t\tL: [Li, Lj, Lv]\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.cLUsolve = function LUsolve(lu, b) {\n\t\t\t\tvar L = lu.L,\n\t\t\t\t\tU = lu.U,\n\t\t\t\t\tret = numeric.clone(b);\n\t\t\t\tvar Li = L[0],\n\t\t\t\t\tLj = L[1],\n\t\t\t\t\tLv = L[2];\n\t\t\t\tvar Ui = U[0],\n\t\t\t\t\tUj = U[1],\n\t\t\t\t\tUv = U[2];\n\t\t\t\tvar p = Ui.length,\n\t\t\t\t\tq = Li.length;\n\t\t\t\tvar m = ret.length,\n\t\t\t\t\ti, j, k;\n\t\t\t\tk = 0;\n\t\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t\twhile (Lj[k] < i) {\n\t\t\t\t\t\tret[i] -= Lv[k] * ret[Lj[k]];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tk = p - 1;\n\t\t\t\tfor (i = m - 1; i >= 0; i--) {\n\t\t\t\t\twhile (Uj[k] > i) {\n\t\t\t\t\t\tret[i] -= Uv[k] * ret[Uj[k]];\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t\tret[i] /= Uv[k];\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.cgrid = function grid(n, shape) {\n\t\t\t\tif (typeof n === \"number\") n = [n, n];\n\t\t\t\tvar ret = numeric.rep(n, -1);\n\t\t\t\tvar i, j, count;\n\t\t\t\tif (typeof shape !== \"function\") {\n\t\t\t\t\tswitch (shape) {\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\tshape = function(i, j) {\n\t\t\t\t\t\t\t\treturn (i >= n[0] / 2 || j < n[1] / 2);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tshape = function(i, j) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 1; i < n[0] - 1; i++)\n\t\t\t\t\tfor (j = 1; j < n[1] - 1; j++)\n\t\t\t\t\t\tif (shape(i, j)) {\n\t\t\t\t\t\t\tret[i][j] = count;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tnumeric.cdelsq = function delsq(g) {\n\t\t\t\tvar dir = [\n\t\t\t\t\t[-1, 0],\n\t\t\t\t\t[0, -1],\n\t\t\t\t\t[0, 1],\n\t\t\t\t\t[1, 0]\n\t\t\t\t];\n\t\t\t\tvar s = numeric.dim(g),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1],\n\t\t\t\t\ti, j, k, p, q;\n\t\t\t\tvar Li = [],\n\t\t\t\t\tLj = [],\n\t\t\t\t\tLv = [];\n\t\t\t\tfor (i = 1; i < m - 1; i++)\n\t\t\t\t\tfor (j = 1; j < n - 1; j++) {\n\t\t\t\t\t\tif (g[i][j] < 0) continue;\n\t\t\t\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tp = i + dir[k][0];\n\t\t\t\t\t\t\tq = j + dir[k][1];\n\t\t\t\t\t\t\tif (g[p][q] < 0) continue;\n\t\t\t\t\t\t\tLi.push(g[i][j]);\n\t\t\t\t\t\t\tLj.push(g[p][q]);\n\t\t\t\t\t\t\tLv.push(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLi.push(g[i][j]);\n\t\t\t\t\t\tLj.push(g[i][j]);\n\t\t\t\t\t\tLv.push(4);\n\t\t\t\t\t}\n\t\t\t\treturn [Li, Lj, Lv];\n\t\t\t};\n\n\t\t\tnumeric.cdotMV = function dotMV(A, x) {\n\t\t\t\tvar ret, Ai = A[0],\n\t\t\t\t\tAj = A[1],\n\t\t\t\t\tAv = A[2],\n\t\t\t\t\tk, p = Ai.length,\n\t\t\t\t\tN;\n\t\t\t\tN = 0;\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\tif (Ai[k] > N) N = Ai[k];\n\t\t\t\t}\n\t\t\t\tN++;\n\t\t\t\tret = numeric.rep([N], 0);\n\t\t\t\tfor (k = 0; k < p; k++) {\n\t\t\t\t\tret[Ai[k]] += Av[k] * x[Aj[k]];\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\t// 7. Splines\n\n\t\t\tnumeric.Spline = function Spline(x, yl, yr, kl, kr) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.yl = yl;\n\t\t\t\tthis.yr = yr;\n\t\t\t\tthis.kl = kl;\n\t\t\t\tthis.kr = kr;\n\t\t\t};\n\t\t\tnumeric.Spline.prototype._at = function _at(x1, p) {\n\t\t\t\tvar x = this.x;\n\t\t\t\tvar yl = this.yl;\n\t\t\t\tvar yr = this.yr;\n\t\t\t\tvar kl = this.kl;\n\t\t\t\tvar kr = this.kr;\n\t\t\t\tvar x1, a, b, t;\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tmul = numeric.mul;\n\t\t\t\ta = sub(mul(kl[p], x[p + 1] - x[p]), sub(yr[p + 1], yl[p]));\n\t\t\t\tb = add(mul(kr[p + 1], x[p] - x[p + 1]), sub(yr[p + 1], yl[p]));\n\t\t\t\tt = (x1 - x[p]) / (x[p + 1] - x[p]);\n\t\t\t\tvar s = t * (1 - t);\n\t\t\t\treturn add(add(add(mul(1 - t, yl[p]), mul(t, yr[p + 1])), mul(a, s * (1 - t))), mul(b, s * t));\n\t\t\t};\n\t\t\tnumeric.Spline.prototype.at = function at(x0) {\n\t\t\t\tif (typeof x0 === \"number\") {\n\t\t\t\t\tvar x = this.x;\n\t\t\t\t\tvar n = x.length;\n\t\t\t\t\tvar p, q, mid, floor = Math.floor,\n\t\t\t\t\t\ta, b, t;\n\t\t\t\t\tp = 0;\n\t\t\t\t\tq = n - 1;\n\t\t\t\t\twhile (q - p > 1) {\n\t\t\t\t\t\tmid = floor((p + q) / 2);\n\t\t\t\t\t\tif (x[mid] <= x0) p = mid;\n\t\t\t\t\t\telse q = mid;\n\t\t\t\t\t}\n\t\t\t\t\treturn this._at(x0, p);\n\t\t\t\t}\n\t\t\t\tvar n = x0.length,\n\t\t\t\t\ti, ret = Array(n);\n\t\t\t\tfor (i = n - 1; i !== -1; --i) ret[i] = this.at(x0[i]);\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.Spline.prototype.diff = function diff() {\n\t\t\t\tvar x = this.x;\n\t\t\t\tvar yl = this.yl;\n\t\t\t\tvar yr = this.yr;\n\t\t\t\tvar kl = this.kl;\n\t\t\t\tvar kr = this.kr;\n\t\t\t\tvar n = yl.length;\n\t\t\t\tvar i, dx, dy;\n\t\t\t\tvar zl = kl,\n\t\t\t\t\tzr = kr,\n\t\t\t\t\tpl = Array(n),\n\t\t\t\t\tpr = Array(n);\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tdiv = numeric.div,\n\t\t\t\t\tsub = numeric.sub;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\tdx = x[i + 1] - x[i];\n\t\t\t\t\tdy = sub(yr[i + 1], yl[i]);\n\t\t\t\t\tpl[i] = div(add(mul(dy, 6), mul(kl[i], -4 * dx), mul(kr[i + 1], -2 * dx)), dx * dx);\n\t\t\t\t\tpr[i + 1] = div(add(mul(dy, -6), mul(kl[i], 2 * dx), mul(kr[i + 1], 4 * dx)), dx * dx);\n\t\t\t\t}\n\t\t\t\treturn new numeric.Spline(x, zl, zr, pl, pr);\n\t\t\t};\n\t\t\tnumeric.Spline.prototype.roots = function roots() {\n\t\t\t\tfunction sqr(x) {\n\t\t\t\t\treturn x * x;\n\t\t\t\t}\n\n\t\t\t\tfunction heval(y0, y1, k0, k1, x) {\n\t\t\t\t\tvar A = k0 * 2 - (y1 - y0);\n\t\t\t\t\tvar B = -k1 * 2 + (y1 - y0);\n\t\t\t\t\tvar t = (x + 1) * 0.5;\n\t\t\t\t\tvar s = t * (1 - t);\n\t\t\t\t\treturn (1 - t) * y0 + t * y1 + A * s * (1 - t) + B * s * t;\n\t\t\t\t}\n\t\t\t\tvar ret = [];\n\t\t\t\tvar x = this.x,\n\t\t\t\t\tyl = this.yl,\n\t\t\t\t\tyr = this.yr,\n\t\t\t\t\tkl = this.kl,\n\t\t\t\t\tkr = this.kr;\n\t\t\t\tif (typeof yl[0] === \"number\") {\n\t\t\t\t\tyl = [yl];\n\t\t\t\t\tyr = [yr];\n\t\t\t\t\tkl = [kl];\n\t\t\t\t\tkr = [kr];\n\t\t\t\t}\n\t\t\t\tvar m = yl.length,\n\t\t\t\t\tn = x.length - 1,\n\t\t\t\t\ti, j, k, y, s, t;\n\t\t\t\tvar ai, bi, ci, di, ret = Array(m),\n\t\t\t\t\tri, k0, k1, y0, y1, A, B, D, dx, cx, stops, z0, z1, zm, t0, t1, tm;\n\t\t\t\tvar sqrt = Math.sqrt;\n\t\t\t\tfor (i = 0; i !== m; ++i) {\n\t\t\t\t\tai = yl[i];\n\t\t\t\t\tbi = yr[i];\n\t\t\t\t\tci = kl[i];\n\t\t\t\t\tdi = kr[i];\n\t\t\t\t\tri = [];\n\t\t\t\t\tfor (j = 0; j !== n; j++) {\n\t\t\t\t\t\tif (j > 0 && bi[j] * ai[j] < 0) ri.push(x[j]);\n\t\t\t\t\t\tdx = (x[j + 1] - x[j]);\n\t\t\t\t\t\tcx = x[j];\n\t\t\t\t\t\ty0 = ai[j];\n\t\t\t\t\t\ty1 = bi[j + 1];\n\t\t\t\t\t\tk0 = ci[j] / dx;\n\t\t\t\t\t\tk1 = di[j + 1] / dx;\n\t\t\t\t\t\tD = sqr(k0 - k1 + 3 * (y0 - y1)) + 12 * k1 * y0;\n\t\t\t\t\t\tA = k1 + 3 * y0 + 2 * k0 - 3 * y1;\n\t\t\t\t\t\tB = 3 * (k1 + k0 + 2 * (y0 - y1));\n\t\t\t\t\t\tif (D <= 0) {\n\t\t\t\t\t\t\tz0 = A / B;\n\t\t\t\t\t\t\tif (z0 > x[j] && z0 < x[j + 1]) stops = [x[j], z0, x[j + 1]];\n\t\t\t\t\t\t\telse stops = [x[j], x[j + 1]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tz0 = (A - sqrt(D)) / B;\n\t\t\t\t\t\t\tz1 = (A + sqrt(D)) / B;\n\t\t\t\t\t\t\tstops = [x[j]];\n\t\t\t\t\t\t\tif (z0 > x[j] && z0 < x[j + 1]) stops.push(z0);\n\t\t\t\t\t\t\tif (z1 > x[j] && z1 < x[j + 1]) stops.push(z1);\n\t\t\t\t\t\t\tstops.push(x[j + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt0 = stops[0];\n\t\t\t\t\t\tz0 = this._at(t0, j);\n\t\t\t\t\t\tfor (k = 0; k < stops.length - 1; k++) {\n\t\t\t\t\t\t\tt1 = stops[k + 1];\n\t\t\t\t\t\t\tz1 = this._at(t1, j);\n\t\t\t\t\t\t\tif (z0 === 0) {\n\t\t\t\t\t\t\t\tri.push(t0);\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tz0 = z1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (z1 === 0 || z0 * z1 > 0) {\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tz0 = z1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar side = 0;\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\ttm = (z0 * t1 - z1 * t0) / (z0 - z1);\n\t\t\t\t\t\t\t\tif (tm <= t0 || tm >= t1) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tzm = this._at(tm, j);\n\t\t\t\t\t\t\t\tif (zm * z1 > 0) {\n\t\t\t\t\t\t\t\t\tt1 = tm;\n\t\t\t\t\t\t\t\t\tz1 = zm;\n\t\t\t\t\t\t\t\t\tif (side === -1) z0 *= 0.5;\n\t\t\t\t\t\t\t\t\tside = -1;\n\t\t\t\t\t\t\t\t} else if (zm * z0 > 0) {\n\t\t\t\t\t\t\t\t\tt0 = tm;\n\t\t\t\t\t\t\t\t\tz0 = zm;\n\t\t\t\t\t\t\t\t\tif (side === 1) z1 *= 0.5;\n\t\t\t\t\t\t\t\t\tside = 1;\n\t\t\t\t\t\t\t\t} else break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tri.push(tm);\n\t\t\t\t\t\t\tt0 = stops[k + 1];\n\t\t\t\t\t\t\tz0 = this._at(t0, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (z1 === 0) ri.push(t1);\n\t\t\t\t\t}\n\t\t\t\t\tret[i] = ri;\n\t\t\t\t}\n\t\t\t\tif (typeof this.yl[0] === \"number\") return ret[0];\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tnumeric.spline = function spline(x, y, k1, kn) {\n\t\t\t\tvar n = x.length,\n\t\t\t\t\tb = [],\n\t\t\t\t\tdx = [],\n\t\t\t\t\tdy = [];\n\t\t\t\tvar i;\n\t\t\t\tvar sub = numeric.sub,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tadd = numeric.add;\n\t\t\t\tfor (i = n - 2; i >= 0; i--) {\n\t\t\t\t\tdx[i] = x[i + 1] - x[i];\n\t\t\t\t\tdy[i] = sub(y[i + 1], y[i]);\n\t\t\t\t}\n\t\t\t\tif (typeof k1 === \"string\" || typeof kn === \"string\") {\n\t\t\t\t\tk1 = kn = \"periodic\";\n\t\t\t\t}\n\t\t\t\t// Build sparse tridiagonal system\n\t\t\t\tvar T = [\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tswitch (typeof k1) {\n\t\t\t\t\tcase \"undefined\":\n\t\t\t\t\t\tb[0] = mul(3 / (dx[0] * dx[0]), dy[0]);\n\t\t\t\t\t\tT[0].push(0, 0);\n\t\t\t\t\t\tT[1].push(0, 1);\n\t\t\t\t\t\tT[2].push(2 / dx[0], 1 / dx[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\tb[0] = add(mul(3 / (dx[n - 2] * dx[n - 2]), dy[n - 2]), mul(3 / (dx[0] * dx[0]), dy[0]));\n\t\t\t\t\t\tT[0].push(0, 0, 0);\n\t\t\t\t\t\tT[1].push(n - 2, 0, 1);\n\t\t\t\t\t\tT[2].push(1 / dx[n - 2], 2 / dx[n - 2] + 2 / dx[0], 1 / dx[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb[0] = k1;\n\t\t\t\t\t\tT[0].push(0);\n\t\t\t\t\t\tT[1].push(0);\n\t\t\t\t\t\tT[2].push(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i < n - 1; i++) {\n\t\t\t\t\tb[i] = add(mul(3 / (dx[i - 1] * dx[i - 1]), dy[i - 1]), mul(3 / (dx[i] * dx[i]), dy[i]));\n\t\t\t\t\tT[0].push(i, i, i);\n\t\t\t\t\tT[1].push(i - 1, i, i + 1);\n\t\t\t\t\tT[2].push(1 / dx[i - 1], 2 / dx[i - 1] + 2 / dx[i], 1 / dx[i]);\n\t\t\t\t}\n\t\t\t\tswitch (typeof kn) {\n\t\t\t\t\tcase \"undefined\":\n\t\t\t\t\t\tb[n - 1] = mul(3 / (dx[n - 2] * dx[n - 2]), dy[n - 2]);\n\t\t\t\t\t\tT[0].push(n - 1, n - 1);\n\t\t\t\t\t\tT[1].push(n - 2, n - 1);\n\t\t\t\t\t\tT[2].push(1 / dx[n - 2], 2 / dx[n - 2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\tT[1][T[1].length - 1] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb[n - 1] = kn;\n\t\t\t\t\t\tT[0].push(n - 1);\n\t\t\t\t\t\tT[1].push(n - 1);\n\t\t\t\t\t\tT[2].push(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (typeof b[0] !== \"number\") b = numeric.transpose(b);\n\t\t\t\telse b = [b];\n\t\t\t\tvar k = Array(b.length);\n\t\t\t\tif (typeof k1 === \"string\") {\n\t\t\t\t\tfor (i = k.length - 1; i !== -1; --i) {\n\t\t\t\t\t\tk[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)), b[i]);\n\t\t\t\t\t\tk[i][n - 1] = k[i][0];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = k.length - 1; i !== -1; --i) {\n\t\t\t\t\t\tk[i] = numeric.cLUsolve(numeric.cLU(T), b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (typeof y[0] === \"number\") k = k[0];\n\t\t\t\telse k = numeric.transpose(k);\n\t\t\t\treturn new numeric.Spline(x, y, y, k, k);\n\t\t\t};\n\n\t\t\t// 8. FFT\n\t\t\tnumeric.fftpow2 = function fftpow2(x, y) {\n\t\t\t\tvar n = x.length;\n\t\t\t\tif (n === 1) return;\n\t\t\t\tvar cos = Math.cos,\n\t\t\t\t\tsin = Math.sin,\n\t\t\t\t\ti, j;\n\t\t\t\tvar xe = Array(n / 2),\n\t\t\t\t\tye = Array(n / 2),\n\t\t\t\t\txo = Array(n / 2),\n\t\t\t\t\tyo = Array(n / 2);\n\t\t\t\tj = n / 2;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\txo[j] = x[i];\n\t\t\t\t\tyo[j] = y[i];\n\t\t\t\t\t--i;\n\t\t\t\t\txe[j] = x[i];\n\t\t\t\t\tye[j] = y[i];\n\t\t\t\t}\n\t\t\t\tfftpow2(xe, ye);\n\t\t\t\tfftpow2(xo, yo);\n\t\t\t\tj = n / 2;\n\t\t\t\tvar t, k = (-6.2831853071795864769252867665590057683943387987502116419 / n),\n\t\t\t\t\tci, si;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\tif (j === -1) j = n / 2 - 1;\n\t\t\t\t\tt = k * i;\n\t\t\t\t\tci = cos(t);\n\t\t\t\t\tsi = sin(t);\n\t\t\t\t\tx[i] = xe[j] + ci * xo[j] - si * yo[j];\n\t\t\t\t\ty[i] = ye[j] + ci * yo[j] + si * xo[j];\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric._ifftpow2 = function _ifftpow2(x, y) {\n\t\t\t\tvar n = x.length;\n\t\t\t\tif (n === 1) return;\n\t\t\t\tvar cos = Math.cos,\n\t\t\t\t\tsin = Math.sin,\n\t\t\t\t\ti, j;\n\t\t\t\tvar xe = Array(n / 2),\n\t\t\t\t\tye = Array(n / 2),\n\t\t\t\t\txo = Array(n / 2),\n\t\t\t\t\tyo = Array(n / 2);\n\t\t\t\tj = n / 2;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\txo[j] = x[i];\n\t\t\t\t\tyo[j] = y[i];\n\t\t\t\t\t--i;\n\t\t\t\t\txe[j] = x[i];\n\t\t\t\t\tye[j] = y[i];\n\t\t\t\t}\n\t\t\t\t_ifftpow2(xe, ye);\n\t\t\t\t_ifftpow2(xo, yo);\n\t\t\t\tj = n / 2;\n\t\t\t\tvar t, k = (6.2831853071795864769252867665590057683943387987502116419 / n),\n\t\t\t\t\tci, si;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t--j;\n\t\t\t\t\tif (j === -1) j = n / 2 - 1;\n\t\t\t\t\tt = k * i;\n\t\t\t\t\tci = cos(t);\n\t\t\t\t\tsi = sin(t);\n\t\t\t\t\tx[i] = xe[j] + ci * xo[j] - si * yo[j];\n\t\t\t\t\ty[i] = ye[j] + ci * yo[j] + si * xo[j];\n\t\t\t\t}\n\t\t\t};\n\t\t\tnumeric.ifftpow2 = function ifftpow2(x, y) {\n\t\t\t\tnumeric._ifftpow2(x, y);\n\t\t\t\tnumeric.diveq(x, x.length);\n\t\t\t\tnumeric.diveq(y, y.length);\n\t\t\t};\n\t\t\tnumeric.convpow2 = function convpow2(ax, ay, bx, by) {\n\t\t\t\tnumeric.fftpow2(ax, ay);\n\t\t\t\tnumeric.fftpow2(bx, by);\n\t\t\t\tvar i, n = ax.length,\n\t\t\t\t\taxi, bxi, ayi, byi;\n\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\taxi = ax[i];\n\t\t\t\t\tayi = ay[i];\n\t\t\t\t\tbxi = bx[i];\n\t\t\t\t\tbyi = by[i];\n\t\t\t\t\tax[i] = axi * bxi - ayi * byi;\n\t\t\t\t\tay[i] = axi * byi + ayi * bxi;\n\t\t\t\t}\n\t\t\t\tnumeric.ifftpow2(ax, ay);\n\t\t\t};\n\t\t\tnumeric.T.prototype.fft = function fft() {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tvar n = x.length,\n\t\t\t\t\tlog = Math.log,\n\t\t\t\t\tlog2 = log(2),\n\t\t\t\t\tp = Math.ceil(log(2 * n - 1) / log2),\n\t\t\t\t\tm = Math.pow(2, p);\n\t\t\t\tvar cx = numeric.rep([m], 0),\n\t\t\t\t\tcy = numeric.rep([m], 0),\n\t\t\t\t\tcos = Math.cos,\n\t\t\t\t\tsin = Math.sin;\n\t\t\t\tvar k, c = (-3.141592653589793238462643383279502884197169399375105820 / n),\n\t\t\t\t\tt;\n\t\t\t\tvar a = numeric.rep([m], 0),\n\t\t\t\t\tb = numeric.rep([m], 0),\n\t\t\t\t\tnhalf = Math.floor(n / 2);\n\t\t\t\tfor (k = 0; k < n; k++) a[k] = x[k];\n\t\t\t\tif (typeof y !== \"undefined\")\n\t\t\t\t\tfor (k = 0; k < n; k++) b[k] = y[k];\n\t\t\t\tcx[0] = 1;\n\t\t\t\tfor (k = 1; k <= m / 2; k++) {\n\t\t\t\t\tt = c * k * k;\n\t\t\t\t\tcx[k] = cos(t);\n\t\t\t\t\tcy[k] = sin(t);\n\t\t\t\t\tcx[m - k] = cos(t);\n\t\t\t\t\tcy[m - k] = sin(t);\n\t\t\t\t}\n\t\t\t\tvar X = new numeric.T(a, b),\n\t\t\t\t\tY = new numeric.T(cx, cy);\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tnumeric.convpow2(X.x, X.y, numeric.clone(Y.x), numeric.neg(Y.y));\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tX.x.length = n;\n\t\t\t\tX.y.length = n;\n\t\t\t\treturn X;\n\t\t\t};\n\t\t\tnumeric.T.prototype.ifft = function ifft() {\n\t\t\t\tvar x = this.x,\n\t\t\t\t\ty = this.y;\n\t\t\t\tvar n = x.length,\n\t\t\t\t\tlog = Math.log,\n\t\t\t\t\tlog2 = log(2),\n\t\t\t\t\tp = Math.ceil(log(2 * n - 1) / log2),\n\t\t\t\t\tm = Math.pow(2, p);\n\t\t\t\tvar cx = numeric.rep([m], 0),\n\t\t\t\t\tcy = numeric.rep([m], 0),\n\t\t\t\t\tcos = Math.cos,\n\t\t\t\t\tsin = Math.sin;\n\t\t\t\tvar k, c = (3.141592653589793238462643383279502884197169399375105820 / n),\n\t\t\t\t\tt;\n\t\t\t\tvar a = numeric.rep([m], 0),\n\t\t\t\t\tb = numeric.rep([m], 0),\n\t\t\t\t\tnhalf = Math.floor(n / 2);\n\t\t\t\tfor (k = 0; k < n; k++) a[k] = x[k];\n\t\t\t\tif (typeof y !== \"undefined\")\n\t\t\t\t\tfor (k = 0; k < n; k++) b[k] = y[k];\n\t\t\t\tcx[0] = 1;\n\t\t\t\tfor (k = 1; k <= m / 2; k++) {\n\t\t\t\t\tt = c * k * k;\n\t\t\t\t\tcx[k] = cos(t);\n\t\t\t\t\tcy[k] = sin(t);\n\t\t\t\t\tcx[m - k] = cos(t);\n\t\t\t\t\tcy[m - k] = sin(t);\n\t\t\t\t}\n\t\t\t\tvar X = new numeric.T(a, b),\n\t\t\t\t\tY = new numeric.T(cx, cy);\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tnumeric.convpow2(X.x, X.y, numeric.clone(Y.x), numeric.neg(Y.y));\n\t\t\t\tX = X.mul(Y);\n\t\t\t\tX.x.length = n;\n\t\t\t\tX.y.length = n;\n\t\t\t\treturn X.div(n);\n\t\t\t};\n\n\t\t\t//9. Unconstrained optimization\n\t\t\tnumeric.gradient = function gradient(f, x) {\n\t\t\t\tvar n = x.length;\n\t\t\t\tvar f0 = f(x);\n\t\t\t\tif (isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');\n\t\t\t\tvar max = Math.max;\n\t\t\t\tvar i, x0 = numeric.clone(x),\n\t\t\t\t\tf1, f2, J = Array(n);\n\t\t\t\tvar div = numeric.div,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\terrest, roundoff, max = Math.max,\n\t\t\t\t\teps = 1e-3,\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\tmin = Math.min;\n\t\t\t\tvar t0, t1, t2, it = 0,\n\t\t\t\t\td1, d2, N;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tvar h = max(1e-6 * f0, 1e-8);\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t++it;\n\t\t\t\t\t\tif (it > 20) {\n\t\t\t\t\t\t\tthrow new Error(\"Numerical gradient fails\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx0[i] = x[i] + h;\n\t\t\t\t\t\tf1 = f(x0);\n\t\t\t\t\t\tx0[i] = x[i] - h;\n\t\t\t\t\t\tf2 = f(x0);\n\t\t\t\t\t\tx0[i] = x[i];\n\t\t\t\t\t\tif (isNaN(f1) || isNaN(f2)) {\n\t\t\t\t\t\t\th /= 16;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJ[i] = (f1 - f2) / (2 * h);\n\t\t\t\t\t\tt0 = x[i] - h;\n\t\t\t\t\t\tt1 = x[i];\n\t\t\t\t\t\tt2 = x[i] + h;\n\t\t\t\t\t\td1 = (f1 - f0) / h;\n\t\t\t\t\t\td2 = (f0 - f2) / h;\n\t\t\t\t\t\tN = max(abs(J[i]), abs(f0), abs(f1), abs(f2), abs(t0), abs(t1), abs(t2), 1e-8);\n\t\t\t\t\t\terrest = min(max(abs(d1 - J[i]), abs(d2 - J[i]), abs(d1 - d2)) / N, h / N);\n\t\t\t\t\t\tif (errest > eps) {\n\t\t\t\t\t\t\th /= 16;\n\t\t\t\t\t\t} else break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn J;\n\t\t\t};\n\n\t\t\tnumeric.uncmin = function uncmin(f, x0, tol, gradient, maxit, callback) {\n\t\t\t\tvar grad = numeric.gradient;\n\t\t\t\tif (typeof tol === \"undefined\") {\n\t\t\t\t\ttol = 1e-8;\n\t\t\t\t}\n\t\t\t\tif (typeof gradient === \"undefined\") {\n\t\t\t\t\tgradient = function(x) {\n\t\t\t\t\t\treturn grad(f, x);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof maxit === \"undefined\") maxit = 1000;\n\t\t\t\tx0 = numeric.clone(x0);\n\t\t\t\tvar n = x0.length;\n\t\t\t\tvar f0 = f(x0),\n\t\t\t\t\tf1, df0;\n\t\t\t\tif (isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');\n\t\t\t\tvar max = Math.max,\n\t\t\t\t\tnorm2 = numeric.norm2;\n\t\t\t\ttol = max(tol, numeric.epsilon);\n\t\t\t\tvar step, g0, g1, H1 = numeric.identity(n);\n\t\t\t\tvar dot = numeric.dot,\n\t\t\t\t\tinv = numeric.inv,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tadd = numeric.add,\n\t\t\t\t\tten = numeric.tensor,\n\t\t\t\t\tdiv = numeric.div,\n\t\t\t\t\tmul = numeric.mul;\n\t\t\t\tvar all = numeric.all,\n\t\t\t\t\tisfinite = numeric.isFinite,\n\t\t\t\t\tneg = numeric.neg;\n\t\t\t\tvar it = 0,\n\t\t\t\t\ti, s, x1, y, Hy, Hs, ys, i0, t, nstep, t1, t2;\n\t\t\t\tvar msg = \"\";\n\t\t\t\tg0 = gradient(x0);\n\t\t\t\twhile (it < maxit) {\n\t\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\t\tif (callback(it, x0, f0, g0, H1)) {\n\t\t\t\t\t\t\tmsg = \"Callback returned true\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!all(isfinite(g0))) {\n\t\t\t\t\t\tmsg = \"Gradient has Infinity or NaN\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstep = neg(dot(H1, g0));\n\t\t\t\t\tif (!all(isfinite(step))) {\n\t\t\t\t\t\tmsg = \"Search direction has Infinity or NaN\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnstep = norm2(step);\n\t\t\t\t\tif (nstep < tol) {\n\t\t\t\t\t\tmsg = \"Newton step smaller than tol\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt = 1;\n\t\t\t\t\tdf0 = dot(g0, step);\n\t\t\t\t\t// line search\n\t\t\t\t\tx1 = x0;\n\t\t\t\t\twhile (it < maxit) {\n\t\t\t\t\t\tif (t * nstep < tol) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = mul(step, t);\n\t\t\t\t\t\tx1 = add(x0, s);\n\t\t\t\t\t\tf1 = f(x1);\n\t\t\t\t\t\tif (f1 - f0 >= 0.1 * t * df0 || isNaN(f1)) {\n\t\t\t\t\t\t\tt *= 0.5;\n\t\t\t\t\t\t\t++it;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (t * nstep < tol) {\n\t\t\t\t\t\tmsg = \"Line search step size smaller than tol\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (it === maxit) {\n\t\t\t\t\t\tmsg = \"maxit reached during line search\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tg1 = gradient(x1);\n\t\t\t\t\ty = sub(g1, g0);\n\t\t\t\t\tys = dot(y, s);\n\t\t\t\t\tHy = dot(H1, y);\n\t\t\t\t\tH1 = sub(add(H1,\n\t\t\t\t\t\t\tmul(\n\t\t\t\t\t\t\t\t(ys + dot(y, Hy)) / (ys * ys),\n\t\t\t\t\t\t\t\tten(s, s))),\n\t\t\t\t\t\tdiv(add(ten(Hy, s), ten(s, Hy)), ys));\n\t\t\t\t\tx0 = x1;\n\t\t\t\t\tf0 = f1;\n\t\t\t\t\tg0 = g1;\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tsolution: x0,\n\t\t\t\t\tf: f0,\n\t\t\t\t\tgradient: g0,\n\t\t\t\t\tinvHessian: H1,\n\t\t\t\t\titerations: it,\n\t\t\t\t\tmessage: msg\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// 10. Ode solver (Dormand-Prince)\n\t\t\tnumeric.Dopri = function Dopri(x, y, f, ymid, iterations, msg, events) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.f = f;\n\t\t\t\tthis.ymid = ymid;\n\t\t\t\tthis.iterations = iterations;\n\t\t\t\tthis.events = events;\n\t\t\t\tthis.message = msg;\n\t\t\t};\n\t\t\tnumeric.Dopri.prototype._at = function _at(xi, j) {\n\t\t\t\tfunction sqr(x) {\n\t\t\t\t\treturn x * x;\n\t\t\t\t}\n\t\t\t\tvar sol = this;\n\t\t\t\tvar xs = sol.x;\n\t\t\t\tvar ys = sol.y;\n\t\t\t\tvar k1 = sol.f;\n\t\t\t\tvar ymid = sol.ymid;\n\t\t\t\tvar n = xs.length;\n\t\t\t\tvar x0, x1, xh, y0, y1, yh, xi;\n\t\t\t\tvar floor = Math.floor,\n\t\t\t\t\th;\n\t\t\t\tvar c = 0.5;\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tp, q, w;\n\t\t\t\tx0 = xs[j];\n\t\t\t\tx1 = xs[j + 1];\n\t\t\t\ty0 = ys[j];\n\t\t\t\ty1 = ys[j + 1];\n\t\t\t\th = x1 - x0;\n\t\t\t\txh = x0 + c * h;\n\t\t\t\tyh = ymid[j];\n\t\t\t\tp = sub(k1[j], mul(y0, 1 / (x0 - xh) + 2 / (x0 - x1)));\n\t\t\t\tq = sub(k1[j + 1], mul(y1, 1 / (x1 - xh) + 2 / (x1 - x0)));\n\t\t\t\tw = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),\n\t\t\t\t\tsqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),\n\t\t\t\t\tsqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),\n\t\t\t\t\t(xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),\n\t\t\t\t\t(xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0 - x1) / (x1 - xh)\n\t\t\t\t];\n\t\t\t\treturn add(add(add(add(mul(y0, w[0]),\n\t\t\t\t\t\t\t\tmul(yh, w[1])),\n\t\t\t\t\t\t\tmul(y1, w[2])),\n\t\t\t\t\t\tmul(p, w[3])),\n\t\t\t\t\tmul(q, w[4]));\n\t\t\t};\n\t\t\tnumeric.Dopri.prototype.at = function at(x) {\n\t\t\t\tvar i, j, k, floor = Math.floor;\n\t\t\t\tif (typeof x !== \"number\") {\n\t\t\t\t\tvar n = x.length,\n\t\t\t\t\t\tret = Array(n);\n\t\t\t\t\tfor (i = n - 1; i !== -1; --i) {\n\t\t\t\t\t\tret[i] = this.at(x[i]);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tvar x0 = this.x;\n\t\t\t\ti = 0;\n\t\t\t\tj = x0.length - 1;\n\t\t\t\twhile (j - i > 1) {\n\t\t\t\t\tk = floor(0.5 * (i + j));\n\t\t\t\t\tif (x0[k] <= x) i = k;\n\t\t\t\t\telse j = k;\n\t\t\t\t}\n\t\t\t\treturn this._at(x, i);\n\t\t\t};\n\n\t\t\tnumeric.dopri = function dopri(x0, x1, y0, f, tol, maxit, event) {\n\t\t\t\tif (typeof tol === \"undefined\") {\n\t\t\t\t\ttol = 1e-6;\n\t\t\t\t}\n\t\t\t\tif (typeof maxit === \"undefined\") {\n\t\t\t\t\tmaxit = 1000;\n\t\t\t\t}\n\t\t\t\tvar xs = [x0],\n\t\t\t\t\tys = [y0],\n\t\t\t\t\tk1 = [f(x0, y0)],\n\t\t\t\t\tk2, k3, k4, k5, k6, k7, ymid = [];\n\t\t\t\tvar A2 = 1 / 5;\n\t\t\t\tvar A3 = [3 / 40, 9 / 40];\n\t\t\t\tvar A4 = [44 / 45, -56 / 15, 32 / 9];\n\t\t\t\tvar A5 = [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729];\n\t\t\t\tvar A6 = [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656];\n\t\t\t\tvar b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84];\n\t\t\t\tvar bm = [0.5 * 6025192743 / 30085553152,\n\t\t\t\t\t0,\n\t\t\t\t\t0.5 * 51252292925 / 65400821598,\n\t\t\t\t\t0.5 * -2691868925 / 45128329728,\n\t\t\t\t\t0.5 * 187940372067 / 1594534317056,\n\t\t\t\t\t0.5 * -1776094331 / 19743644256,\n\t\t\t\t\t0.5 * 11237099 / 235043384\n\t\t\t\t];\n\t\t\t\tvar c = [1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];\n\t\t\t\tvar e = [-71 / 57600, 0, 71 / 16695, -71 / 1920, 17253 / 339200, -22 / 525, 1 / 40];\n\t\t\t\tvar i = 0,\n\t\t\t\t\ter, j;\n\t\t\t\tvar h = (x1 - x0) / 10;\n\t\t\t\tvar it = 0;\n\t\t\t\tvar add = numeric.add,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\ty1, erinf;\n\t\t\t\tvar max = Math.max,\n\t\t\t\t\tmin = Math.min,\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\tnorminf = numeric.norminf,\n\t\t\t\t\tpow = Math.pow;\n\t\t\t\tvar any = numeric.any,\n\t\t\t\t\tlt = numeric.lt,\n\t\t\t\t\tand = numeric.and,\n\t\t\t\t\tsub = numeric.sub;\n\t\t\t\tvar e0, e1, ev;\n\t\t\t\tvar ret = new numeric.Dopri(xs, ys, k1, ymid, -1, \"\");\n\t\t\t\tif (typeof event === \"function\") e0 = event(x0, y0);\n\t\t\t\twhile (x0 < x1 && it < maxit) {\n\t\t\t\t\t++it;\n\t\t\t\t\tif (x0 + h > x1) h = x1 - x0;\n\t\t\t\t\tk2 = f(x0 + c[0] * h, add(y0, mul(A2 * h, k1[i])));\n\t\t\t\t\tk3 = f(x0 + c[1] * h, add(add(y0, mul(A3[0] * h, k1[i])), mul(A3[1] * h, k2)));\n\t\t\t\t\tk4 = f(x0 + c[2] * h, add(add(add(y0, mul(A4[0] * h, k1[i])), mul(A4[1] * h, k2)), mul(A4[2] * h, k3)));\n\t\t\t\t\tk5 = f(x0 + c[3] * h, add(add(add(add(y0, mul(A5[0] * h, k1[i])), mul(A5[1] * h, k2)), mul(A5[2] * h, k3)), mul(A5[3] * h, k4)));\n\t\t\t\t\tk6 = f(x0 + c[4] * h, add(add(add(add(add(y0, mul(A6[0] * h, k1[i])), mul(A6[1] * h, k2)), mul(A6[2] * h, k3)), mul(A6[3] * h, k4)), mul(A6[4] * h, k5)));\n\t\t\t\t\ty1 = add(add(add(add(add(y0, mul(k1[i], h * b[0])), mul(k3, h * b[2])), mul(k4, h * b[3])), mul(k5, h * b[4])), mul(k6, h * b[5]));\n\t\t\t\t\tk7 = f(x0 + h, y1);\n\t\t\t\t\ter = add(add(add(add(add(mul(k1[i], h * e[0]), mul(k3, h * e[2])), mul(k4, h * e[3])), mul(k5, h * e[4])), mul(k6, h * e[5])), mul(k7, h * e[6]));\n\t\t\t\t\tif (typeof er === \"number\") erinf = abs(er);\n\t\t\t\t\telse erinf = norminf(er);\n\t\t\t\t\tif (erinf > tol) { // reject\n\t\t\t\t\t\th = 0.2 * h * pow(tol / erinf, 0.25);\n\t\t\t\t\t\tif (x0 + h === x0) {\n\t\t\t\t\t\t\tret.msg = \"Step size became too small\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tymid[i] = add(add(add(add(add(add(y0,\n\t\t\t\t\t\t\t\t\t\t\tmul(k1[i], h * bm[0])),\n\t\t\t\t\t\t\t\t\t\tmul(k3, h * bm[2])),\n\t\t\t\t\t\t\t\t\tmul(k4, h * bm[3])),\n\t\t\t\t\t\t\t\tmul(k5, h * bm[4])),\n\t\t\t\t\t\t\tmul(k6, h * bm[5])),\n\t\t\t\t\t\tmul(k7, h * bm[6]));\n\t\t\t\t\t++i;\n\t\t\t\t\txs[i] = x0 + h;\n\t\t\t\t\tys[i] = y1;\n\t\t\t\t\tk1[i] = k7;\n\t\t\t\t\tif (typeof event === \"function\") {\n\t\t\t\t\t\tvar yi, xl = x0,\n\t\t\t\t\t\t\txr = x0 + 0.5 * h,\n\t\t\t\t\t\t\txi;\n\t\t\t\t\t\te1 = event(xr, ymid[i - 1]);\n\t\t\t\t\t\tev = and(lt(e0, 0), lt(0, e1));\n\t\t\t\t\t\tif (!any(ev)) {\n\t\t\t\t\t\t\txl = xr;\n\t\t\t\t\t\t\txr = x0 + h;\n\t\t\t\t\t\t\te0 = e1;\n\t\t\t\t\t\t\te1 = event(xr, y1);\n\t\t\t\t\t\t\tev = and(lt(e0, 0), lt(0, e1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (any(ev)) {\n\t\t\t\t\t\t\tvar xc, yc, en, ei;\n\t\t\t\t\t\t\tvar side = 0,\n\t\t\t\t\t\t\t\tsl = 1.0,\n\t\t\t\t\t\t\t\tsr = 1.0;\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tif (typeof e0 === \"number\") xi = (sr * e1 * xl - sl * e0 * xr) / (sr * e1 - sl * e0);\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\txi = xr;\n\t\t\t\t\t\t\t\t\tfor (j = e0.length - 1; j !== -1; --j) {\n\t\t\t\t\t\t\t\t\t\tif (e0[j] < 0 && e1[j] > 0) xi = min(xi, (sr * e1[j] * xl - sl * e0[j] * xr) / (sr * e1[j] - sl * e0[j]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (xi <= xl || xi >= xr) break;\n\t\t\t\t\t\t\t\tyi = ret._at(xi, i - 1);\n\t\t\t\t\t\t\t\tei = event(xi, yi);\n\t\t\t\t\t\t\t\ten = and(lt(e0, 0), lt(0, ei));\n\t\t\t\t\t\t\t\tif (any(en)) {\n\t\t\t\t\t\t\t\t\txr = xi;\n\t\t\t\t\t\t\t\t\te1 = ei;\n\t\t\t\t\t\t\t\t\tev = en;\n\t\t\t\t\t\t\t\t\tsr = 1.0;\n\t\t\t\t\t\t\t\t\tif (side === -1) sl *= 0.5;\n\t\t\t\t\t\t\t\t\telse sl = 1.0;\n\t\t\t\t\t\t\t\t\tside = -1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\txl = xi;\n\t\t\t\t\t\t\t\t\te0 = ei;\n\t\t\t\t\t\t\t\t\tsl = 1.0;\n\t\t\t\t\t\t\t\t\tif (side === 1) sr *= 0.5;\n\t\t\t\t\t\t\t\t\telse sr = 1.0;\n\t\t\t\t\t\t\t\t\tside = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ty1 = ret._at(0.5 * (x0 + xi), i - 1);\n\t\t\t\t\t\t\tret.f[i] = f(xi, yi);\n\t\t\t\t\t\t\tret.x[i] = xi;\n\t\t\t\t\t\t\tret.y[i] = yi;\n\t\t\t\t\t\t\tret.ymid[i - 1] = y1;\n\t\t\t\t\t\t\tret.events = ev;\n\t\t\t\t\t\t\tret.iterations = it;\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx0 += h;\n\t\t\t\t\ty0 = y1;\n\t\t\t\t\te0 = e1;\n\t\t\t\t\th = min(0.8 * h * pow(tol / erinf, 0.25), 4 * h);\n\t\t\t\t}\n\t\t\t\tret.iterations = it;\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\t// 11. Ax = b\n\t\t\tnumeric.LU = function(A, fast) {\n\t\t\t\tfast = fast || false;\n\n\t\t\t\tvar abs = Math.abs;\n\t\t\t\tvar i, j, k, absAjk, Akk, Ak, Pk, Ai;\n\t\t\t\tvar max;\n\t\t\t\tvar n = A.length,\n\t\t\t\t\tn1 = n - 1;\n\t\t\t\tvar P = new Array(n);\n\t\t\t\tif (!fast) A = numeric.clone(A);\n\n\t\t\t\tfor (k = 0; k < n; ++k) {\n\t\t\t\t\tPk = k;\n\t\t\t\t\tAk = A[k];\n\t\t\t\t\tmax = abs(Ak[k]);\n\t\t\t\t\tfor (j = k + 1; j < n; ++j) {\n\t\t\t\t\t\tabsAjk = abs(A[j][k]);\n\t\t\t\t\t\tif (max < absAjk) {\n\t\t\t\t\t\t\tmax = absAjk;\n\t\t\t\t\t\t\tPk = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tP[k] = Pk;\n\n\t\t\t\t\tif (Pk != k) {\n\t\t\t\t\t\tA[k] = A[Pk];\n\t\t\t\t\t\tA[Pk] = Ak;\n\t\t\t\t\t\tAk = A[k];\n\t\t\t\t\t}\n\n\t\t\t\t\tAkk = Ak[k];\n\n\t\t\t\t\tfor (i = k + 1; i < n; ++i) {\n\t\t\t\t\t\tA[i][k] /= Akk;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = k + 1; i < n; ++i) {\n\t\t\t\t\t\tAi = A[i];\n\t\t\t\t\t\tfor (j = k + 1; j < n1; ++j) {\n\t\t\t\t\t\t\tAi[j] -= Ai[k] * Ak[j];\n\t\t\t\t\t\t\t++j;\n\t\t\t\t\t\t\tAi[j] -= Ai[k] * Ak[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === n1) Ai[j] -= Ai[k] * Ak[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tLU: A,\n\t\t\t\t\tP: P\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.LUsolve = function LUsolve(LUP, b) {\n\t\t\t\tvar i, j;\n\t\t\t\tvar LU = LUP.LU;\n\t\t\t\tvar n = LU.length;\n\t\t\t\tvar x = numeric.clone(b);\n\t\t\t\tvar P = LUP.P;\n\t\t\t\tvar Pi, LUi, LUii;\n\n\t\t\t\tfor (i = n - 1; i !== -1; --i) x[i] = b[i];\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tPi = P[i];\n\t\t\t\t\tif (P[i] !== i) {\n\t\t\t\t\t\ttmp = x[i];\n\t\t\t\t\t\tx[i] = x[Pi];\n\t\t\t\t\t\tx[Pi] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tLUi = LU[i];\n\t\t\t\t\tfor (j = 0; j < i; ++j) {\n\t\t\t\t\t\tx[i] -= x[j] * LUi[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (i = n - 1; i >= 0; --i) {\n\t\t\t\t\tLUi = LU[i];\n\t\t\t\t\tfor (j = i + 1; j < n; ++j) {\n\t\t\t\t\t\tx[i] -= x[j] * LUi[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tx[i] /= LUi[i];\n\t\t\t\t}\n\n\t\t\t\treturn x;\n\t\t\t};\n\n\t\t\tnumeric.solve = function solve(A, b, fast) {\n\t\t\t\treturn numeric.LUsolve(numeric.LU(A, fast), b);\n\t\t\t};\n\n\t\t\t// 12. Linear programming\n\t\t\tnumeric.echelonize = function echelonize(A) {\n\t\t\t\tvar s = numeric.dim(A),\n\t\t\t\t\tm = s[0],\n\t\t\t\t\tn = s[1];\n\t\t\t\tvar I = numeric.identity(m);\n\t\t\t\tvar P = Array(m);\n\t\t\t\tvar i, j, k, l, Ai, Ii, Z, a;\n\t\t\t\tvar abs = Math.abs;\n\t\t\t\tvar diveq = numeric.diveq;\n\t\t\t\tA = numeric.clone(A);\n\t\t\t\tfor (i = 0; i < m; ++i) {\n\t\t\t\t\tk = 0;\n\t\t\t\t\tAi = A[i];\n\t\t\t\t\tIi = I[i];\n\t\t\t\t\tfor (j = 1; j < n; ++j)\n\t\t\t\t\t\tif (abs(Ai[k]) < abs(Ai[j])) k = j;\n\t\t\t\t\tP[i] = k;\n\t\t\t\t\tdiveq(Ii, Ai[k]);\n\t\t\t\t\tdiveq(Ai, Ai[k]);\n\t\t\t\t\tfor (j = 0; j < m; ++j)\n\t\t\t\t\t\tif (j !== i) {\n\t\t\t\t\t\t\tZ = A[j];\n\t\t\t\t\t\t\ta = Z[k];\n\t\t\t\t\t\t\tfor (l = n - 1; l !== -1; --l) Z[l] -= Ai[l] * a;\n\t\t\t\t\t\t\tZ = I[j];\n\t\t\t\t\t\t\tfor (l = m - 1; l !== -1; --l) Z[l] -= Ii[l] * a;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tI: I,\n\t\t\t\t\tA: A,\n\t\t\t\t\tP: P\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric._solveLP = function _solveLP(c, A, b, tol, maxit, x) {\n\t\t\t\tvar sum = numeric.sum,\n\t\t\t\t\tlog = numeric.log,\n\t\t\t\t\tmul = numeric.mul,\n\t\t\t\t\tsub = numeric.sub,\n\t\t\t\t\tdot = numeric.dot,\n\t\t\t\t\tdiv = numeric.div,\n\t\t\t\t\tadd = numeric.add;\n\t\t\t\tvar m = c.length,\n\t\t\t\t\tn = b.length,\n\t\t\t\t\ty;\n\t\t\t\tvar unbounded = false,\n\t\t\t\t\tcb;\n\t\t\t\tif (typeof tol === \"undefined\") tol = numeric.epsilon;\n\t\t\t\tif (typeof maxit === \"undefined\") maxit = 1000;\n\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\tvar c0 = numeric.rep([m], 0).concat([1]);\n\t\t\t\t\tvar J = numeric.rep([n, 1], -1);\n\t\t\t\t\tvar A0 = numeric.blockMatrix([\n\t\t\t\t\t\t[A, J]\n\t\t\t\t\t]);\n\t\t\t\t\tvar b0 = b;\n\t\t\t\t\ty = numeric.rep([m], 0).concat(Math.max(0, numeric.sup(numeric.neg(b))) + 1);\n\t\t\t\t\tvar x0 = _solveLP(c0, A0, b0, tol, maxit, y);\n\t\t\t\t\tx = numeric.clone(x0.solution);\n\t\t\t\t\tx.length = m;\n\t\t\t\t\tvar foo = numeric.inf(sub(b, dot(A, x)));\n\t\t\t\t\tif (foo < 0) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsolution: NaN,\n\t\t\t\t\t\t\tmessage: \"Infeasible\"\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcb = function cb(it, x0, f0, g0, H1) {\n\t\t\t\t\t\tvar s = dot(c, g0),\n\t\t\t\t\t\t\tAg0 = dot(A, g0),\n\t\t\t\t\t\t\ti;\n\t\t\t\t\t\tfor (i = n - 1; i !== -1; --i)\n\t\t\t\t\t\t\tif (s * Ag0[i] < 0) return false;\n\t\t\t\t\t\tunbounded = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcb = function cb(it, x0, f0, g0, H1) {\n\t\t\t\t\t\tif (x0[m - 1] >= 0) return false;\n\t\t\t\t\t\tunbounded = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar alpha = 1.0;\n\t\t\t\tvar f0, df0;\n\t\t\t\twhile (1) {\n\t\t\t\t\tf0 = function(z) {\n\t\t\t\t\t\treturn sub(dot(c, z), mul(alpha, sum(log(sub(b, dot(A, z))))));\n\t\t\t\t\t};\n\t\t\t\t\tdf0 = function(z) {\n\t\t\t\t\t\treturn add(c, mul(alpha, dot(div(1, sub(b, dot(A, z))), A)));\n\t\t\t\t\t};\n\t\t\t\t\ty = numeric.uncmin(f0, x, alpha, df0, maxit, cb).solution;\n\t\t\t\t\tif (unbounded) return {\n\t\t\t\t\t\tsolution: y,\n\t\t\t\t\t\tmessage: \"Unbounded\"\n\t\t\t\t\t};\n\t\t\t\t\tif (alpha < tol) return {\n\t\t\t\t\t\tsolution: y,\n\t\t\t\t\t\tmessage: \"\"\n\t\t\t\t\t};\n\t\t\t\t\tx = y;\n\t\t\t\t\talpha *= 0.01;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnumeric.solveLP = function solveLP(c, A, b, Aeq, beq, tol, maxit) {\n\t\t\t\tif (typeof Aeq === \"undefined\") return numeric._solveLP(c, A, b, tol, maxit, x);\n\t\t\t\tvar m = Aeq.length,\n\t\t\t\t\tn = Aeq[0].length,\n\t\t\t\t\to = A.length;\n\t\t\t\tvar B = numeric.echelonize(Aeq);\n\t\t\t\tvar flags = numeric.rep([n], 0);\n\t\t\t\tvar P = B.P;\n\t\t\t\tvar Q = [];\n\t\t\t\tvar i;\n\t\t\t\tfor (i = P.length - 1; i !== -1; --i) flags[P[i]] = 1;\n\t\t\t\tfor (i = n - 1; i !== -1; --i)\n\t\t\t\t\tif (flags[i] === 0) Q.push(i);\n\t\t\t\tvar g = numeric.getRange;\n\t\t\t\tvar I = numeric.linspace(0, m - 1),\n\t\t\t\t\tJ = numeric.linspace(0, o - 1);\n\t\t\t\tvar Aeq2 = g(Aeq, I, Q),\n\t\t\t\t\tA1 = g(A, J, P),\n\t\t\t\t\tA2 = g(A, J, Q),\n\t\t\t\t\tdot = numeric.dot,\n\t\t\t\t\tsub = numeric.sub;\n\t\t\t\tvar A3 = dot(A1, B.I);\n\t\t\t\tvar A4 = sub(A2, dot(A3, Aeq2)),\n\t\t\t\t\tb4 = sub(b, dot(A3, beq));\n\t\t\t\tvar c1 = Array(P.length),\n\t\t\t\t\tc2 = Array(Q.length);\n\t\t\t\tfor (i = P.length - 1; i !== -1; --i) c1[i] = c[P[i]];\n\t\t\t\tfor (i = Q.length - 1; i !== -1; --i) c2[i] = c[Q[i]];\n\t\t\t\tvar c4 = sub(c2, dot(c1, dot(B.I, Aeq2)));\n\t\t\t\tvar S = numeric._solveLP(c4, A4, b4, tol, maxit);\n\t\t\t\tvar x2 = S.solution;\n\t\t\t\tvar x1 = dot(B.I, sub(beq, dot(Aeq2, x2)));\n\t\t\t\tvar x = Array(c.length);\n\t\t\t\tfor (i = P.length - 1; i !== -1; --i) x[P[i]] = x1[i];\n\t\t\t\tfor (i = Q.length - 1; i !== -1; --i) x[Q[i]] = x2[i];\n\t\t\t\treturn {\n\t\t\t\t\tsolution: x,\n\t\t\t\t\tmessage: S.message\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tnumeric.MPStoLP = function MPStoLP(MPS) {\n\t\t\t\tif (MPS instanceof String) {\n\t\t\t\t\tMPS.split('\\n');\n\t\t\t\t}\n\t\t\t\tvar state = 0;\n\t\t\t\tvar states = ['Initial state', 'NAME', 'ROWS', 'COLUMNS', 'RHS', 'BOUNDS', 'ENDATA'];\n\t\t\t\tvar n = MPS.length;\n\t\t\t\tvar i, j, z, N = 0,\n\t\t\t\t\trows = {},\n\t\t\t\t\tsign = [],\n\t\t\t\t\trl = 0,\n\t\t\t\t\tvars = {},\n\t\t\t\t\tnv = 0;\n\t\t\t\tvar name;\n\t\t\t\tvar c = [],\n\t\t\t\t\tA = [],\n\t\t\t\t\tb = [];\n\n\t\t\t\tfunction err(e) {\n\t\t\t\t\tthrow new Error('MPStoLP: ' + e + '\\nLine ' + i + ': ' + MPS[i] + '\\nCurrent state: ' + states[state] + '\\n');\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tz = MPS[i];\n\t\t\t\t\tvar w0 = z.match(/\\S*/g);\n\t\t\t\t\tvar w = [];\n\t\t\t\t\tfor (j = 0; j < w0.length; ++j)\n\t\t\t\t\t\tif (w0[j] !== \"\") w.push(w0[j]);\n\t\t\t\t\tif (w.length === 0) continue;\n\t\t\t\t\tfor (j = 0; j < states.length; ++j)\n\t\t\t\t\t\tif (z.substr(0, states[j].length) === states[j]) break;\n\t\t\t\t\tif (j < states.length) {\n\t\t\t\t\t\tstate = j;\n\t\t\t\t\t\tif (j === 1) {\n\t\t\t\t\t\t\tname = w[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === 6) return {\n\t\t\t\t\t\t\tname: name,\n\t\t\t\t\t\t\tc: c,\n\t\t\t\t\t\t\tA: numeric.transpose(A),\n\t\t\t\t\t\t\tb: b,\n\t\t\t\t\t\t\trows: rows,\n\t\t\t\t\t\t\tvars: vars\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\terr('Unexpected line');\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tswitch (w[0]) {\n\t\t\t\t\t\t\t\tcase 'N':\n\t\t\t\t\t\t\t\t\tif (N === 0) N = w[1];\n\t\t\t\t\t\t\t\t\telse err('Two or more N rows');\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\t\t\trows[w[1]] = rl;\n\t\t\t\t\t\t\t\t\tsign[rl] = 1;\n\t\t\t\t\t\t\t\t\tb[rl] = 0;\n\t\t\t\t\t\t\t\t\t++rl;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'G':\n\t\t\t\t\t\t\t\t\trows[w[1]] = rl;\n\t\t\t\t\t\t\t\t\tsign[rl] = -1;\n\t\t\t\t\t\t\t\t\tb[rl] = 0;\n\t\t\t\t\t\t\t\t\t++rl;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'E':\n\t\t\t\t\t\t\t\t\trows[w[1]] = rl;\n\t\t\t\t\t\t\t\t\tsign[rl] = 0;\n\t\t\t\t\t\t\t\t\tb[rl] = 0;\n\t\t\t\t\t\t\t\t\t++rl;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\terr('Parse error ' + numeric.prettyPrint(w));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tif (!vars.hasOwnProperty(w[0])) {\n\t\t\t\t\t\t\t\tvars[w[0]] = nv;\n\t\t\t\t\t\t\t\tc[nv] = 0;\n\t\t\t\t\t\t\t\tA[nv] = numeric.rep([rl], 0);\n\t\t\t\t\t\t\t\t++nv;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar p = vars[w[0]];\n\t\t\t\t\t\t\tfor (j = 1; j < w.length; j += 2) {\n\t\t\t\t\t\t\t\tif (w[j] === N) {\n\t\t\t\t\t\t\t\t\tc[p] = parseFloat(w[j + 1]);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar q = rows[w[j]];\n\t\t\t\t\t\t\t\tA[p][q] = (sign[q] < 0 ? -1 : 1) * parseFloat(w[j + 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfor (j = 1; j < w.length; j += 2) b[rows[w[j]]] = (sign[rows[w[j]]] < 0 ? -1 : 1) * parseFloat(w[j + 1]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t/*FIXME*/\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\terr('Internal error');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terr('Reached end of file without ENDATA');\n\t\t\t};\n\t\t\t// seedrandom.js version 2.0.\n\t\t\t// Author: David Bau 4/2/2011\n\t\t\t//\n\t\t\t// Defines a method Math.seedrandom() that, when called, substitutes\n\t\t\t// an explicitly seeded RC4-based algorithm for Math.random().  Also\n\t\t\t// supports automatic seeding from local or network sources of entropy.\n\t\t\t//\n\t\t\t// Usage:\n\t\t\t//\n\t\t\t//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>\n\t\t\t//\n\t\t\t//   Math.seedrandom('yipee'); Sets Math.random to a function that is\n\t\t\t//                             initialized using the given explicit seed.\n\t\t\t//\n\t\t\t//   Math.seedrandom();        Sets Math.random to a function that is\n\t\t\t//                             seeded using the current time, dom state,\n\t\t\t//                             and other accumulated local entropy.\n\t\t\t//                             The generated seed string is returned.\n\t\t\t//\n\t\t\t//   Math.seedrandom('yowza', true);\n\t\t\t//                             Seeds using the given explicit seed mixed\n\t\t\t//                             together with accumulated entropy.\n\t\t\t//\n\t\t\t//   <script src=\"http://bit.ly/srandom-512\"></script>\n\t\t\t//                             Seeds using physical random bits downloaded\n\t\t\t//                             from random.org.\n\t\t\t//\n\t\t\t//   <script src=\"https://jsonlib.appspot.com/urandom?callback=Math.seedrandom\">\n\t\t\t//   </script>                 Seeds using urandom bits from call.jsonlib.com,\n\t\t\t//                             which is faster than random.org.\n\t\t\t//\n\t\t\t// Examples:\n\t\t\t//\n\t\t\t//   Math.seedrandom(\"hello\");            // Use \"hello\" as the seed.\n\t\t\t//   document.write(Math.random());       // Always 0.5463663768140734\n\t\t\t//   document.write(Math.random());       // Always 0.43973793770592234\n\t\t\t//   var rng1 = Math.random;              // Remember the current prng.\n\t\t\t//\n\t\t\t//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.\n\t\t\t//   document.write(Math.random());       // Pretty much unpredictable.\n\t\t\t//\n\t\t\t//   Math.random = rng1;                  // Continue \"hello\" prng sequence.\n\t\t\t//   document.write(Math.random());       // Always 0.554769432473455\n\t\t\t//\n\t\t\t//   Math.seedrandom(autoseed);           // Restart at the previous seed.\n\t\t\t//   document.write(Math.random());       // Repeat the 'unpredictable' value.\n\t\t\t//\n\t\t\t// Notes:\n\t\t\t//\n\t\t\t// Each time seedrandom('arg') is called, entropy from the passed seed\n\t\t\t// is accumulated in a pool to help generate future seeds for the\n\t\t\t// zero-argument form of Math.seedrandom, so entropy can be injected over\n\t\t\t// time by calling seedrandom with explicit data repeatedly.\n\t\t\t//\n\t\t\t// On speed - This javascript implementation of Math.random() is about\n\t\t\t// 3-10x slower than the built-in Math.random() because it is not native\n\t\t\t// code, but this is typically fast enough anyway.  Seeding is more expensive,\n\t\t\t// especially if you use auto-seeding.  Some details (timings on Chrome 4):\n\t\t\t//\n\t\t\t// Our Math.random()            - avg less than 0.002 milliseconds per call\n\t\t\t// seedrandom('explicit')       - avg less than 0.5 milliseconds per call\n\t\t\t// seedrandom('explicit', true) - avg less than 2 milliseconds per call\n\t\t\t// seedrandom()                 - avg about 38 milliseconds per call\n\t\t\t//\n\t\t\t// LICENSE (BSD):\n\t\t\t//\n\t\t\t// Copyright 2010 David Bau, all rights reserved.\n\t\t\t//\n\t\t\t// Redistribution and use in source and binary forms, with or without\n\t\t\t// modification, are permitted provided that the following conditions are met:\n\t\t\t// \n\t\t\t//   1. Redistributions of source code must retain the above copyright\n\t\t\t//      notice, this list of conditions and the following disclaimer.\n\t\t\t//\n\t\t\t//   2. Redistributions in binary form must reproduce the above copyright\n\t\t\t//      notice, this list of conditions and the following disclaimer in the\n\t\t\t//      documentation and/or other materials provided with the distribution.\n\t\t\t// \n\t\t\t//   3. Neither the name of this module nor the names of its contributors may\n\t\t\t//      be used to endorse or promote products derived from this software\n\t\t\t//      without specific prior written permission.\n\t\t\t// \n\t\t\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t\t\t// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t\t\t// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t\t\t// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t\t\t// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t\t\t// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t\t\t// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t\t\t// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t\t\t// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t\t\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t\t\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t\t\t//\n\t\t\t/**\n\t\t\t * All code is in an anonymous closure to keep the global namespace clean.\n\t\t\t *\n\t\t\t * @param {number=} overflow \n\t\t\t * @param {number=} startdenom\n\t\t\t */\n\n\t\t\t// Patched by Seb so that seedrandom.js does not pollute the Math object.\n\t\t\t// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%\n\t\t\t// slower.\n\t\t\tnumeric.seedrandom = {\n\t\t\t\tpow: Math.pow,\n\t\t\t\trandom: Math.random\n\t\t\t};\n\n\t\t\t(function(pool, math, width, chunks, significance, overflow, startdenom) {\n\n\n\t\t\t\t//\n\t\t\t\t// seedrandom()\n\t\t\t\t// This is the seedrandom function described above.\n\t\t\t\t//\n\t\t\t\tmath['seedrandom'] = function seedrandom(seed, use_entropy) {\n\t\t\t\t\tvar key = [];\n\t\t\t\t\tvar arc4;\n\n\t\t\t\t\t// Flatten the seed string or build one from local entropy if needed.\n\t\t\t\t\tseed = mixkey(flatten(\n\t\t\t\t\t\tuse_entropy ? [seed, pool] :\n\t\t\t\t\t\targuments.length ? seed : [new Date().getTime(), pool, window], 3), key);\n\n\t\t\t\t\t// Use the seed to initialize an ARC4 generator.\n\t\t\t\t\tarc4 = new ARC4(key);\n\n\t\t\t\t\t// Mix the randomness into accumulated entropy.\n\t\t\t\t\tmixkey(arc4.S, pool);\n\n\t\t\t\t\t// Override Math.random\n\n\t\t\t\t\t// This function returns a random double in [0, 1) that contains\n\t\t\t\t\t// randomness in every bit of the mantissa of the IEEE 754 value.\n\n\t\t\t\t\tmath['random'] = function random() { // Closure to return a random double:\n\t\t\t\t\t\tvar n = arc4.g(chunks); // Start with a numerator n < 2 ^ 48\n\t\t\t\t\t\tvar d = startdenom; //   and denominator d = 2 ^ 48.\n\t\t\t\t\t\tvar x = 0; //   and no 'extra last byte'.\n\t\t\t\t\t\twhile (n < significance) { // Fill up all significant digits by\n\t\t\t\t\t\t\tn = (n + x) * width; //   shifting numerator and\n\t\t\t\t\t\t\td *= width; //   denominator and generating a\n\t\t\t\t\t\t\tx = arc4.g(1); //   new least-significant-byte.\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (n >= overflow) { // To avoid rounding up, before adding\n\t\t\t\t\t\t\tn /= 2; //   last byte, shift everything\n\t\t\t\t\t\t\td /= 2; //   right using integer math until\n\t\t\t\t\t\t\tx >>>= 1; //   we have exactly the desired bits.\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (n + x) / d; // Form the number within [0, 1).\n\t\t\t\t\t};\n\n\t\t\t\t\t// Return the seed that was used\n\t\t\t\t\treturn seed;\n\t\t\t\t};\n\n\t\t\t\t//\n\t\t\t\t// ARC4\n\t\t\t\t//\n\t\t\t\t// An ARC4 implementation.  The constructor takes a key in the form of\n\t\t\t\t// an array of at most (width) integers that should be 0 <= x < (width).\n\t\t\t\t//\n\t\t\t\t// The g(count) method returns a pseudorandom integer that concatenates\n\t\t\t\t// the next (count) outputs from ARC4.  Its return value is a number x\n\t\t\t\t// that is in the range 0 <= x < (width ^ count).\n\t\t\t\t//\n\t\t\t\t/** @constructor */\n\t\t\t\tfunction ARC4(key) {\n\t\t\t\t\tvar t, u, me = this,\n\t\t\t\t\t\tkeylen = key.length;\n\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\tj = me.i = me.j = me.m = 0;\n\t\t\t\t\tme.S = [];\n\t\t\t\t\tme.c = [];\n\n\t\t\t\t\t// The empty key [] is treated as [0].\n\t\t\t\t\tif (!keylen) {\n\t\t\t\t\t\tkey = [keylen++];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set up S using the standard key scheduling algorithm.\n\t\t\t\t\twhile (i < width) {\n\t\t\t\t\t\tme.S[i] = i++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < width; i++) {\n\t\t\t\t\t\tt = me.S[i];\n\t\t\t\t\t\tj = lowbits(j + t + key[i % keylen]);\n\t\t\t\t\t\tu = me.S[j];\n\t\t\t\t\t\tme.S[i] = u;\n\t\t\t\t\t\tme.S[j] = t;\n\t\t\t\t\t}\n\n\t\t\t\t\t// The \"g\" method returns the next (count) outputs as one number.\n\t\t\t\t\tme.g = function getnext(count) {\n\t\t\t\t\t\tvar s = me.S;\n\t\t\t\t\t\tvar i = lowbits(me.i + 1);\n\t\t\t\t\t\tvar t = s[i];\n\t\t\t\t\t\tvar j = lowbits(me.j + t);\n\t\t\t\t\t\tvar u = s[j];\n\t\t\t\t\t\ts[i] = u;\n\t\t\t\t\t\ts[j] = t;\n\t\t\t\t\t\tvar r = s[lowbits(t + u)];\n\t\t\t\t\t\twhile (--count) {\n\t\t\t\t\t\t\ti = lowbits(i + 1);\n\t\t\t\t\t\t\tt = s[i];\n\t\t\t\t\t\t\tj = lowbits(j + t);\n\t\t\t\t\t\t\tu = s[j];\n\t\t\t\t\t\t\ts[i] = u;\n\t\t\t\t\t\t\ts[j] = t;\n\t\t\t\t\t\t\tr = r * width + s[lowbits(t + u)];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tme.i = i;\n\t\t\t\t\t\tme.j = j;\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t};\n\t\t\t\t\t// For robust unpredictability discard an initial batch of values.\n\t\t\t\t\t// See http://www.rsa.com/rsalabs/node.asp?id=2009\n\t\t\t\t\tme.g(width);\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// flatten()\n\t\t\t\t// Converts an object tree to nested arrays of strings.\n\t\t\t\t//\n\t\t\t\t/** @param {Object=} result \n\t\t\t\t * @param {string=} prop\n\t\t\t\t * @param {string=} typ */\n\t\t\t\tfunction flatten(obj, depth, result, prop, typ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t\ttyp = typeof(obj);\n\t\t\t\t\tif (depth && typ == 'object') {\n\t\t\t\t\t\tfor (prop in obj) {\n\t\t\t\t\t\t\tif (prop.indexOf('S') < 5) { // Avoid FF3 bug (local/sessionStorage)\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult.push(flatten(obj[prop], depth - 1));\n\t\t\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn (result.length ? result : obj + (typ != 'string' ? '\\0' : ''));\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// mixkey()\n\t\t\t\t// Mixes a string seed into a key that is an array of integers, and\n\t\t\t\t// returns a shortened string seed that is equivalent to the result key.\n\t\t\t\t//\n\t\t\t\t/** @param {number=} smear \n\t\t\t\t * @param {number=} j */\n\t\t\t\tfunction mixkey(seed, key, smear, j) {\n\t\t\t\t\tseed += ''; // Ensure the seed is a string\n\t\t\t\t\tsmear = 0;\n\t\t\t\t\tfor (j = 0; j < seed.length; j++) {\n\t\t\t\t\t\tkey[lowbits(j)] =\n\t\t\t\t\t\t\tlowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));\n\t\t\t\t\t}\n\t\t\t\t\tseed = '';\n\t\t\t\t\tfor (j in key) {\n\t\t\t\t\t\tseed += String.fromCharCode(key[j]);\n\t\t\t\t\t}\n\t\t\t\t\treturn seed;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// lowbits()\n\t\t\t\t// A quick \"n mod width\" for width a power of 2.\n\t\t\t\t//\n\t\t\t\tfunction lowbits(n) {\n\t\t\t\t\treturn n & (width - 1);\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// The following constants are related to IEEE 754 limits.\n\t\t\t\t//\n\t\t\t\tstartdenom = math.pow(width, chunks);\n\t\t\t\tsignificance = math.pow(2, significance);\n\t\t\t\toverflow = significance * 2;\n\n\t\t\t\t//\n\t\t\t\t// When seedrandom.js is loaded, we immediately mix a few bits\n\t\t\t\t// from the built-in RNG into the entropy pool.  Because we do\n\t\t\t\t// not want to intefere with determinstic PRNG state later,\n\t\t\t\t// seedrandom will not call math.random on its own again after\n\t\t\t\t// initialization.\n\t\t\t\t//\n\t\t\t\tmixkey(math.random(), pool);\n\n\t\t\t\t// End anonymous scope, and pass initial values.\n\t\t\t}(\n\t\t\t\t[], // pool: entropy pool starts empty\n\t\t\t\tnumeric.seedrandom, // math: package containing random, pow, and seedrandom\n\t\t\t\t256, // width: each RC4 output is 0 <= x < 256\n\t\t\t\t6, // chunks: at least six RC4 outputs for each double\n\t\t\t\t52 // significance: there are 52 significant digits in a double\n\t\t\t));\n\t\t\t/* This file is a slightly modified version of quadprog.js from Alberto Santini.\n\t\t\t * It has been slightly modified by SÃ©bastien Loisel to make sure that it handles\n\t\t\t * 0-based Arrays instead of 1-based Arrays.\n\t\t\t * License is in resources/LICENSE.quadprog */\n\t\t\t(function(exports) {\n\n\t\t\t\tfunction base0to1(A) {\n\t\t\t\t\tif (typeof A !== \"object\") {\n\t\t\t\t\t\treturn A;\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\ti, n = A.length;\n\t\t\t\t\tfor (i = 0; i < n; i++) ret[i + 1] = base0to1(A[i]);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tfunction base1to0(A) {\n\t\t\t\t\tif (typeof A !== \"object\") {\n\t\t\t\t\t\treturn A;\n\t\t\t\t\t}\n\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\ti, n = A.length;\n\t\t\t\t\tfor (i = 1; i < n; i++) ret[i - 1] = base1to0(A[i]);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tfunction dpori(a, lda, n) {\n\t\t\t\t\tvar i, j, k, kp1, t;\n\n\t\t\t\t\tfor (k = 1; k <= n; k = k + 1) {\n\t\t\t\t\t\ta[k][k] = 1 / a[k][k];\n\t\t\t\t\t\tt = -a[k][k];\n\t\t\t\t\t\t//~ dscal(k - 1, t, a[1][k], 1);\n\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\ta[i][k] = t * a[i][k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tkp1 = k + 1;\n\t\t\t\t\t\tif (n < kp1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = kp1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tt = a[k][j];\n\t\t\t\t\t\t\ta[k][j] = 0;\n\t\t\t\t\t\t\t//~ daxpy(k, t, a[1][k], 1, a[1][j], 1);\n\t\t\t\t\t\t\tfor (i = 1; i <= k; i = i + 1) {\n\t\t\t\t\t\t\t\ta[i][j] = a[i][j] + (t * a[i][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction dposl(a, lda, n, b) {\n\t\t\t\t\tvar i, k, kb, t;\n\n\t\t\t\t\tfor (k = 1; k <= n; k = k + 1) {\n\t\t\t\t\t\t//~ t = ddot(k - 1, a[1][k], 1, b[1], 1);\n\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\tt = t + (a[i][k] * b[i]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tb[k] = (b[k] - t) / a[k][k];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (kb = 1; kb <= n; kb = kb + 1) {\n\t\t\t\t\t\tk = n + 1 - kb;\n\t\t\t\t\t\tb[k] = b[k] / a[k][k];\n\t\t\t\t\t\tt = -b[k];\n\t\t\t\t\t\t//~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);\n\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\tb[i] = b[i] + (t * a[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction dpofa(a, lda, n, info) {\n\t\t\t\t\tvar i, j, jm1, k, t, s;\n\n\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\tinfo[1] = j;\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t\tjm1 = j - 1;\n\t\t\t\t\t\tif (jm1 < 1) {\n\t\t\t\t\t\t\ts = a[j][j] - s;\n\t\t\t\t\t\t\tif (s <= 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ta[j][j] = Math.sqrt(s);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (k = 1; k <= jm1; k = k + 1) {\n\t\t\t\t\t\t\t\t//~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);\n\t\t\t\t\t\t\t\tt = a[k][j];\n\t\t\t\t\t\t\t\tfor (i = 1; i < k; i = i + 1) {\n\t\t\t\t\t\t\t\t\tt = t - (a[i][j] * a[i][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt = t / a[k][k];\n\t\t\t\t\t\t\t\ta[k][j] = t;\n\t\t\t\t\t\t\t\ts = s + t * t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = a[j][j] - s;\n\t\t\t\t\t\t\tif (s <= 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ta[j][j] = Math.sqrt(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo[1] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,\n\t\t\t\t\tbvec, fdamat, q, meq, iact, nact, iter, work, ierr) {\n\n\t\t\t\t\tvar i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,\n\t\t\t\t\t\ttemp, sum, t1, tt, gc, gs, nu,\n\t\t\t\t\t\tt1inf, t2min,\n\t\t\t\t\t\tvsmall, tmpa, tmpb,\n\t\t\t\t\t\tgo;\n\n\t\t\t\t\tr = Math.min(n, q);\n\t\t\t\t\tl = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;\n\n\t\t\t\t\tvsmall = 1.0e-60;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tvsmall = vsmall + vsmall;\n\t\t\t\t\t\ttmpa = 1 + 0.1 * vsmall;\n\t\t\t\t\t\ttmpb = 1 + 0.2 * vsmall;\n\t\t\t\t\t} while (tmpa <= 1 || tmpb <= 1);\n\n\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\twork[i] = dvec[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = n + 1; i <= l; i = i + 1) {\n\t\t\t\t\t\twork[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\tiact[i] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo = [];\n\n\t\t\t\t\tif (ierr[1] === 0) {\n\t\t\t\t\t\tdpofa(dmat, fddmat, n, info);\n\t\t\t\t\t\tif (info[1] !== 0) {\n\t\t\t\t\t\t\tierr[1] = 2;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdposl(dmat, fddmat, n, dvec);\n\t\t\t\t\t\tdpori(dmat, fddmat, n);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tsol[j] = 0;\n\t\t\t\t\t\t\tfor (i = 1; i <= j; i = i + 1) {\n\t\t\t\t\t\t\t\tsol[j] = sol[j] + dmat[i][j] * dvec[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tdvec[j] = 0;\n\t\t\t\t\t\t\tfor (i = j; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\tdvec[j] = dvec[j] + dmat[j][i] * sol[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcrval[1] = 0;\n\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\tsol[j] = dvec[j];\n\t\t\t\t\t\tcrval[1] = crval[1] + work[j] * sol[j];\n\t\t\t\t\t\twork[j] = 0;\n\t\t\t\t\t\tfor (i = j + 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\tdmat[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcrval[1] = -crval[1] / 2;\n\t\t\t\t\tierr[1] = 0;\n\n\t\t\t\t\tiwzv = n;\n\t\t\t\t\tiwrv = iwzv + n;\n\t\t\t\t\tiwuv = iwrv + r;\n\t\t\t\t\tiwrm = iwuv + r + 1;\n\t\t\t\t\tiwsv = iwrm + (r * (r + 1)) / 2;\n\t\t\t\t\tiwnbv = iwsv + q;\n\n\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tsum = sum + amat[j][i] * amat[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[iwnbv + i] = Math.sqrt(sum);\n\t\t\t\t\t}\n\t\t\t\t\tnact = 0;\n\t\t\t\t\titer[1] = 0;\n\t\t\t\t\titer[2] = 0;\n\n\t\t\t\t\tfunction fn_goto_50() {\n\t\t\t\t\t\titer[1] = iter[1] + 1;\n\n\t\t\t\t\t\tl = iwsv;\n\t\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\t\tl = l + 1;\n\t\t\t\t\t\t\tsum = -bvec[i];\n\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\tsum = sum + amat[j][i] * sol[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (Math.abs(sum) < vsmall) {\n\t\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i > meq) {\n\t\t\t\t\t\t\t\twork[l] = sum;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twork[l] = -Math.abs(sum);\n\t\t\t\t\t\t\t\tif (sum > 0) {\n\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\tamat[j][i] = -amat[j][i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbvec[i] = -bvec[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\twork[iwsv + iact[i]] = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnvl = 0;\n\t\t\t\t\t\ttemp = 0;\n\t\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\t\tif (work[iwsv + i] < temp * work[iwnbv + i]) {\n\t\t\t\t\t\t\t\tnvl = i;\n\t\t\t\t\t\t\t\ttemp = work[iwsv + i] / work[iwnbv + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nvl === 0) {\n\t\t\t\t\t\t\treturn 999;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_55() {\n\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\tsum = sum + dmat[j][i] * amat[j][nvl];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork[i] = sum;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tl1 = iwzv;\n\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\twork[l1 + i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = nact + 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\twork[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt1inf = true;\n\t\t\t\t\t\tfor (i = nact; i >= 1; i = i - 1) {\n\t\t\t\t\t\t\tsum = work[i];\n\t\t\t\t\t\t\tl = iwrm + (i * (i + 3)) / 2;\n\t\t\t\t\t\t\tl1 = l - i;\n\t\t\t\t\t\t\tfor (j = i + 1; j <= nact; j = j + 1) {\n\t\t\t\t\t\t\t\tsum = sum - work[l] * work[iwrv + j];\n\t\t\t\t\t\t\t\tl = l + j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum = sum / work[l1];\n\t\t\t\t\t\t\twork[iwrv + i] = sum;\n\t\t\t\t\t\t\tif (iact[i] < meq) {\n\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (sum < 0) {\n\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt1inf = false;\n\t\t\t\t\t\t\tit1 = i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!t1inf) {\n\t\t\t\t\t\t\tt1 = work[iwuv + it1] / work[iwrv + it1];\n\t\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\tif (iact[i] < meq) {\n\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (work[iwrv + i] < 0) {\n\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttemp = work[iwuv + i] / work[iwrv + i];\n\t\t\t\t\t\t\t\tif (temp < t1) {\n\t\t\t\t\t\t\t\t\tt1 = temp;\n\t\t\t\t\t\t\t\t\tit1 = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor (i = iwzv + 1; i <= iwzv + n; i = i + 1) {\n\t\t\t\t\t\t\tsum = sum + work[i] * work[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Math.abs(sum) <= vsmall) {\n\t\t\t\t\t\t\tif (t1inf) {\n\t\t\t\t\t\t\t\tierr[1] = 1;\n\t\t\t\t\t\t\t\t// GOTO 999\n\t\t\t\t\t\t\t\treturn 999;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\t\twork[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twork[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;\n\t\t\t\t\t\t\t\t// GOTO 700\n\t\t\t\t\t\t\t\treturn 700;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\tsum = sum + work[iwzv + i] * amat[i][nvl];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttt = -work[iwsv + nvl] / sum;\n\t\t\t\t\t\t\tt2min = true;\n\t\t\t\t\t\t\tif (!t1inf) {\n\t\t\t\t\t\t\t\tif (t1 < tt) {\n\t\t\t\t\t\t\t\t\ttt = t1;\n\t\t\t\t\t\t\t\t\tt2min = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\tsol[i] = sol[i] + tt * work[iwzv + i];\n\t\t\t\t\t\t\t\tif (Math.abs(sol[i]) < vsmall) {\n\t\t\t\t\t\t\t\t\tsol[i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcrval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);\n\t\t\t\t\t\t\tfor (i = 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\twork[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;\n\n\t\t\t\t\t\t\tif (t2min) {\n\t\t\t\t\t\t\t\tnact = nact + 1;\n\t\t\t\t\t\t\t\tiact[nact] = nvl;\n\n\t\t\t\t\t\t\t\tl = iwrm + ((nact - 1) * nact) / 2 + 1;\n\t\t\t\t\t\t\t\tfor (i = 1; i <= nact - 1; i = i + 1) {\n\t\t\t\t\t\t\t\t\twork[l] = work[i];\n\t\t\t\t\t\t\t\t\tl = l + 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (nact === n) {\n\t\t\t\t\t\t\t\t\twork[l] = work[n];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (i = n; i >= nact + 1; i = i - 1) {\n\t\t\t\t\t\t\t\t\t\tif (work[i] === 0) {\n\t\t\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tgc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));\n\t\t\t\t\t\t\t\t\t\tgs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));\n\t\t\t\t\t\t\t\t\t\tif (work[i - 1] >= 0) {\n\t\t\t\t\t\t\t\t\t\t\ttemp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ttemp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tgc = work[i - 1] / temp;\n\t\t\t\t\t\t\t\t\t\tgs = work[i] / temp;\n\n\t\t\t\t\t\t\t\t\t\tif (gc === 1) {\n\t\t\t\t\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (gc === 0) {\n\t\t\t\t\t\t\t\t\t\t\twork[i - 1] = gs * temp;\n\t\t\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\t\t\ttemp = dmat[j][i - 1];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i - 1] = dmat[j][i];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i] = temp;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twork[i - 1] = temp;\n\t\t\t\t\t\t\t\t\t\t\tnu = gs / (1 + gc);\n\t\t\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\t\t\ttemp = gc * dmat[j][i - 1] + gs * dmat[j][i];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];\n\t\t\t\t\t\t\t\t\t\t\t\tdmat[j][i - 1] = temp;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twork[l] = work[nact];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsum = -bvec[nvl];\n\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\tsum = sum + sol[j] * amat[j][nvl];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nvl > meq) {\n\t\t\t\t\t\t\t\t\twork[iwsv + nvl] = sum;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twork[iwsv + nvl] = -Math.abs(sum);\n\t\t\t\t\t\t\t\t\tif (sum > 0) {\n\t\t\t\t\t\t\t\t\t\tfor (j = 1; j <= n; j = j + 1) {\n\t\t\t\t\t\t\t\t\t\t\tamat[j][nvl] = -amat[j][nvl];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbvec[nvl] = -bvec[nvl];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// GOTO 700\n\t\t\t\t\t\t\t\treturn 700;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_797() {\n\t\t\t\t\t\tl = iwrm + (it1 * (it1 + 1)) / 2 + 1;\n\t\t\t\t\t\tl1 = l + it1;\n\t\t\t\t\t\tif (work[l1] === 0) {\n\t\t\t\t\t\t\t// GOTO 798\n\t\t\t\t\t\t\treturn 798;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));\n\t\t\t\t\t\tgs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));\n\t\t\t\t\t\tif (work[l1 - 1] >= 0) {\n\t\t\t\t\t\t\ttemp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgc = work[l1 - 1] / temp;\n\t\t\t\t\t\tgs = work[l1] / temp;\n\n\t\t\t\t\t\tif (gc === 1) {\n\t\t\t\t\t\t\t// GOTO 798\n\t\t\t\t\t\t\treturn 798;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gc === 0) {\n\t\t\t\t\t\t\tfor (i = it1 + 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = work[l1 - 1];\n\t\t\t\t\t\t\t\twork[l1 - 1] = work[l1];\n\t\t\t\t\t\t\t\twork[l1] = temp;\n\t\t\t\t\t\t\t\tl1 = l1 + i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = dmat[i][it1];\n\t\t\t\t\t\t\t\tdmat[i][it1] = dmat[i][it1 + 1];\n\t\t\t\t\t\t\t\tdmat[i][it1 + 1] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnu = gs / (1 + gc);\n\t\t\t\t\t\t\tfor (i = it1 + 1; i <= nact; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = gc * work[l1 - 1] + gs * work[l1];\n\t\t\t\t\t\t\t\twork[l1] = nu * (work[l1 - 1] + temp) - work[l1];\n\t\t\t\t\t\t\t\twork[l1 - 1] = temp;\n\t\t\t\t\t\t\t\tl1 = l1 + i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\t\t\ttemp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];\n\t\t\t\t\t\t\t\tdmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];\n\t\t\t\t\t\t\t\tdmat[i][it1] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_798() {\n\t\t\t\t\t\tl1 = l - it1;\n\t\t\t\t\t\tfor (i = 1; i <= it1; i = i + 1) {\n\t\t\t\t\t\t\twork[l1] = work[l];\n\t\t\t\t\t\t\tl = l + 1;\n\t\t\t\t\t\t\tl1 = l1 + 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork[iwuv + it1] = work[iwuv + it1 + 1];\n\t\t\t\t\t\tiact[it1] = iact[it1 + 1];\n\t\t\t\t\t\tit1 = it1 + 1;\n\t\t\t\t\t\tif (it1 < nact) {\n\t\t\t\t\t\t\t// GOTO 797\n\t\t\t\t\t\t\treturn 797;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction fn_goto_799() {\n\t\t\t\t\t\twork[iwuv + nact] = work[iwuv + nact + 1];\n\t\t\t\t\t\twork[iwuv + nact + 1] = 0;\n\t\t\t\t\t\tiact[nact] = 0;\n\t\t\t\t\t\tnact = nact - 1;\n\t\t\t\t\t\titer[2] = iter[2] + 1;\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tgo = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tgo = fn_goto_50();\n\t\t\t\t\t\tif (go === 999) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tgo = fn_goto_55();\n\t\t\t\t\t\t\tif (go === 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (go === 999) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (go === 700) {\n\t\t\t\t\t\t\t\tif (it1 === nact) {\n\t\t\t\t\t\t\t\t\tfn_goto_799();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\t\tfn_goto_797();\n\t\t\t\t\t\t\t\t\t\tgo = fn_goto_798();\n\t\t\t\t\t\t\t\t\t\tif (go !== 797) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfn_goto_799();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {\n\t\t\t\t\tDmat = base0to1(Dmat);\n\t\t\t\t\tdvec = base0to1(dvec);\n\t\t\t\t\tAmat = base0to1(Amat);\n\t\t\t\t\tvar i, n, q,\n\t\t\t\t\t\tnact, r,\n\t\t\t\t\t\tcrval = [],\n\t\t\t\t\t\tiact = [],\n\t\t\t\t\t\tsol = [],\n\t\t\t\t\t\twork = [],\n\t\t\t\t\t\titer = [],\n\t\t\t\t\t\tmessage;\n\n\t\t\t\t\tmeq = meq || 0;\n\t\t\t\t\tfactorized = factorized ? base0to1(factorized) : [undefined, 0];\n\t\t\t\t\tbvec = bvec ? base0to1(bvec) : [];\n\n\t\t\t\t\t// In Fortran the array index starts from 1\n\t\t\t\t\tn = Dmat.length - 1;\n\t\t\t\t\tq = Amat[1].length - 1;\n\n\t\t\t\t\tif (!bvec) {\n\t\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\t\tbvec[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 1; i <= q; i = i + 1) {\n\t\t\t\t\t\tiact[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tnact = 0;\n\t\t\t\t\tr = Math.min(n, q);\n\t\t\t\t\tfor (i = 1; i <= n; i = i + 1) {\n\t\t\t\t\t\tsol[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcrval[1] = 0;\n\t\t\t\t\tfor (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {\n\t\t\t\t\t\twork[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 1; i <= 2; i = i + 1) {\n\t\t\t\t\t\titer[i] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tqpgen2(Dmat, dvec, n, n, sol, crval, Amat,\n\t\t\t\t\t\tbvec, n, q, meq, iact, nact, iter, work, factorized);\n\n\t\t\t\t\tmessage = \"\";\n\t\t\t\t\tif (factorized[1] === 1) {\n\t\t\t\t\t\tmessage = \"constraints are inconsistent, no solution!\";\n\t\t\t\t\t}\n\t\t\t\t\tif (factorized[1] === 2) {\n\t\t\t\t\t\tmessage = \"matrix D in quadratic function is not positive definite!\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsolution: base1to0(sol),\n\t\t\t\t\t\tvalue: base1to0(crval),\n\t\t\t\t\t\tunconstrained_solution: base1to0(dvec),\n\t\t\t\t\t\titerations: base1to0(iter),\n\t\t\t\t\t\tiact: base1to0(iact),\n\t\t\t\t\t\tmessage: message\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\texports.solveQP = solveQP;\n\t\t\t}(numeric));\n\t\t\t/*\n\t\t\tShanti Rao sent me this routine by private email. I had to modify it\n\t\t\tslightly to work on Arrays instead of using a Matrix object.\n\t\t\tIt is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py\n\t\t\t*/\n\n\t\t\tnumeric.svd = function svd(A) {\n\t\t\t\tvar temp;\n\t\t\t\t//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)\n\t\t\t\tvar prec = numeric.epsilon; //Math.pow(2,-52) // assumes double prec\n\t\t\t\tvar tolerance = 1.e-64 / prec;\n\t\t\t\tvar itmax = 50;\n\t\t\t\tvar c = 0;\n\t\t\t\tvar i = 0;\n\t\t\t\tvar j = 0;\n\t\t\t\tvar k = 0;\n\t\t\t\tvar l = 0;\n\n\t\t\t\tvar u = numeric.clone(A);\n\t\t\t\tvar m = u.length;\n\n\t\t\t\tvar n = u[0].length;\n\n\t\t\t\tif (m < n) throw \"Need more rows than columns\";\n\n\t\t\t\tvar e = new Array(n);\n\t\t\t\tvar q = new Array(n);\n\t\t\t\tfor (i = 0; i < n; i++) e[i] = q[i] = 0.0;\n\t\t\t\tvar v = numeric.rep([n, n], 0);\n\t\t\t\t//\tv.zero();\n\n\t\t\t\tfunction pythag(a, b) {\n\t\t\t\t\ta = Math.abs(a);\n\t\t\t\t\tb = Math.abs(b);\n\t\t\t\t\tif (a > b)\n\t\t\t\t\t\treturn a * Math.sqrt(1.0 + (b * b / a / a));\n\t\t\t\t\telse if (b == 0.0)\n\t\t\t\t\t\treturn a;\n\t\t\t\t\treturn b * Math.sqrt(1.0 + (a * a / b / b));\n\t\t\t\t}\n\n\t\t\t\t//Householder's reduction to bidiagonal form\n\n\t\t\t\tvar f = 0.0;\n\t\t\t\tvar g = 0.0;\n\t\t\t\tvar h = 0.0;\n\t\t\t\tvar x = 0.0;\n\t\t\t\tvar y = 0.0;\n\t\t\t\tvar z = 0.0;\n\t\t\t\tvar s = 0.0;\n\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\te[i] = g;\n\t\t\t\t\ts = 0.0;\n\t\t\t\t\tl = i + 1;\n\t\t\t\t\tfor (j = i; j < m; j++)\n\t\t\t\t\t\ts += (u[j][i] * u[j][i]);\n\t\t\t\t\tif (s <= tolerance)\n\t\t\t\t\t\tg = 0.0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tf = u[i][i];\n\t\t\t\t\t\tg = Math.sqrt(s);\n\t\t\t\t\t\tif (f >= 0.0) g = -g;\n\t\t\t\t\t\th = f * g - s;\n\t\t\t\t\t\tu[i][i] = f - g;\n\t\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = i; k < m; k++)\n\t\t\t\t\t\t\t\ts += u[k][i] * u[k][j];\n\t\t\t\t\t\t\tf = s / h;\n\t\t\t\t\t\t\tfor (k = i; k < m; k++)\n\t\t\t\t\t\t\t\tu[k][j] += f * u[k][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq[i] = g;\n\t\t\t\t\ts = 0.0;\n\t\t\t\t\tfor (j = l; j < n; j++)\n\t\t\t\t\t\ts = s + u[i][j] * u[i][j];\n\t\t\t\t\tif (s <= tolerance)\n\t\t\t\t\t\tg = 0.0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tf = u[i][i + 1];\n\t\t\t\t\t\tg = Math.sqrt(s);\n\t\t\t\t\t\tif (f >= 0.0) g = -g;\n\t\t\t\t\t\th = f * g - s;\n\t\t\t\t\t\tu[i][i + 1] = f - g;\n\t\t\t\t\t\tfor (j = l; j < n; j++) e[j] = u[i][j] / h;\n\t\t\t\t\t\tfor (j = l; j < m; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\ts += (u[j][k] * u[i][k]);\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\tu[j][k] += s * e[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ty = Math.abs(q[i]) + Math.abs(e[i]);\n\t\t\t\t\tif (y > x)\n\t\t\t\t\t\tx = y;\n\t\t\t\t}\n\n\t\t\t\t// accumulation of right hand gtransformations\n\t\t\t\tfor (i = n - 1; i != -1; i += -1) {\n\t\t\t\t\tif (g != 0.0) {\n\t\t\t\t\t\th = g * u[i][i + 1];\n\t\t\t\t\t\tfor (j = l; j < n; j++)\n\t\t\t\t\t\t\tv[j][i] = u[i][j] / h;\n\t\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\ts += u[i][k] * v[k][j];\n\t\t\t\t\t\t\tfor (k = l; k < n; k++)\n\t\t\t\t\t\t\t\tv[k][j] += (s * v[k][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\tv[i][j] = 0;\n\t\t\t\t\t\tv[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tv[i][i] = 1;\n\t\t\t\t\tg = e[i];\n\t\t\t\t\tl = i;\n\t\t\t\t}\n\n\t\t\t\t// accumulation of left hand transformations\n\t\t\t\tfor (i = n - 1; i != -1; i += -1) {\n\t\t\t\t\tl = i + 1;\n\t\t\t\t\tg = q[i];\n\t\t\t\t\tfor (j = l; j < n; j++)\n\t\t\t\t\t\tu[i][j] = 0;\n\t\t\t\t\tif (g != 0.0) {\n\t\t\t\t\t\th = u[i][i] * g;\n\t\t\t\t\t\tfor (j = l; j < n; j++) {\n\t\t\t\t\t\t\ts = 0.0;\n\t\t\t\t\t\t\tfor (k = l; k < m; k++) s += u[k][i] * u[k][j];\n\t\t\t\t\t\t\tf = s / h;\n\t\t\t\t\t\t\tfor (k = i; k < m; k++) u[k][j] += f * u[k][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = i; j < m; j++) u[j][i] = u[j][i] / g;\n\t\t\t\t\t} else\n\t\t\t\t\t\tfor (j = i; j < m; j++) u[j][i] = 0;\n\t\t\t\t\tu[i][i] += 1;\n\t\t\t\t}\n\n\t\t\t\t// diagonalization of the bidiagonal form\n\t\t\t\tprec = prec * x;\n\t\t\t\tfor (k = n - 1; k != -1; k += -1) {\n\t\t\t\t\tfor (var iteration = 0; iteration < itmax; iteration++) { // test f splitting\n\t\t\t\t\t\tvar test_convergence = false;\n\t\t\t\t\t\tfor (l = k; l != -1; l += -1) {\n\t\t\t\t\t\t\tif (Math.abs(e[l]) <= prec) {\n\t\t\t\t\t\t\t\ttest_convergence = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (Math.abs(q[l - 1]) <= prec)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!test_convergence) { // cancellation of e[l] if l>0\n\t\t\t\t\t\t\tc = 0.0;\n\t\t\t\t\t\t\ts = 1.0;\n\t\t\t\t\t\t\tvar l1 = l - 1;\n\t\t\t\t\t\t\tfor (i = l; i < k + 1; i++) {\n\t\t\t\t\t\t\t\tf = s * e[i];\n\t\t\t\t\t\t\t\te[i] = c * e[i];\n\t\t\t\t\t\t\t\tif (Math.abs(f) <= prec)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tg = q[i];\n\t\t\t\t\t\t\t\th = pythag(f, g);\n\t\t\t\t\t\t\t\tq[i] = h;\n\t\t\t\t\t\t\t\tc = g / h;\n\t\t\t\t\t\t\t\ts = -f / h;\n\t\t\t\t\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\t\t\t\t\ty = u[j][l1];\n\t\t\t\t\t\t\t\t\tz = u[j][i];\n\t\t\t\t\t\t\t\t\tu[j][l1] = y * c + (z * s);\n\t\t\t\t\t\t\t\t\tu[j][i] = -y * s + (z * c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// test f convergence\n\t\t\t\t\t\tz = q[k];\n\t\t\t\t\t\tif (l == k) { //convergence\n\t\t\t\t\t\t\tif (z < 0.0) { //q[k] is made non-negative\n\t\t\t\t\t\t\t\tq[k] = -z;\n\t\t\t\t\t\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\t\t\t\t\t\tv[j][k] = -v[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak; //break out of iteration loop and move on to next k value\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (iteration >= itmax - 1)\n\t\t\t\t\t\t\tthrow 'Error: no convergence.';\n\t\t\t\t\t\t// shift from bottom 2x2 minor\n\t\t\t\t\t\tx = q[l];\n\t\t\t\t\t\ty = q[k - 1];\n\t\t\t\t\t\tg = e[k - 1];\n\t\t\t\t\t\th = e[k];\n\t\t\t\t\t\tf = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n\t\t\t\t\t\tg = pythag(f, 1.0);\n\t\t\t\t\t\tif (f < 0.0)\n\t\t\t\t\t\t\tf = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tf = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\n\t\t\t\t\t\t// next QR transformation\n\t\t\t\t\t\tc = 1.0;\n\t\t\t\t\t\ts = 1.0;\n\t\t\t\t\t\tfor (i = l + 1; i < k + 1; i++) {\n\t\t\t\t\t\t\tg = e[i];\n\t\t\t\t\t\t\ty = q[i];\n\t\t\t\t\t\t\th = s * g;\n\t\t\t\t\t\t\tg = c * g;\n\t\t\t\t\t\t\tz = pythag(f, h);\n\t\t\t\t\t\t\te[i - 1] = z;\n\t\t\t\t\t\t\tc = f / z;\n\t\t\t\t\t\t\ts = h / z;\n\t\t\t\t\t\t\tf = x * c + g * s;\n\t\t\t\t\t\t\tg = -x * s + g * c;\n\t\t\t\t\t\t\th = y * s;\n\t\t\t\t\t\t\ty = y * c;\n\t\t\t\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tx = v[j][i - 1];\n\t\t\t\t\t\t\t\tz = v[j][i];\n\t\t\t\t\t\t\t\tv[j][i - 1] = x * c + z * s;\n\t\t\t\t\t\t\t\tv[j][i] = -x * s + z * c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tz = pythag(f, h);\n\t\t\t\t\t\t\tq[i - 1] = z;\n\t\t\t\t\t\t\tc = f / z;\n\t\t\t\t\t\t\ts = h / z;\n\t\t\t\t\t\t\tf = c * g + s * y;\n\t\t\t\t\t\t\tx = -s * g + c * y;\n\t\t\t\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\t\t\t\ty = u[j][i - 1];\n\t\t\t\t\t\t\t\tz = u[j][i];\n\t\t\t\t\t\t\t\tu[j][i - 1] = y * c + z * s;\n\t\t\t\t\t\t\t\tu[j][i] = -y * s + z * c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\te[l] = 0.0;\n\t\t\t\t\t\te[k] = f;\n\t\t\t\t\t\tq[k] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//vt= transpose(v)\n\t\t\t\t//return (u,q,vt)\n\t\t\t\tfor (i = 0; i < q.length; i++)\n\t\t\t\t\tif (q[i] < prec) q[i] = 0;\n\n\t\t\t\t//sort eigenvalues\t\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\t//writeln(q)\n\t\t\t\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (q[j] < q[i]) {\n\t\t\t\t\t\t\t//  writeln(i,'-',j)\n\t\t\t\t\t\t\tc = q[j];\n\t\t\t\t\t\t\tq[j] = q[i];\n\t\t\t\t\t\t\tq[i] = c;\n\t\t\t\t\t\t\tfor (k = 0; k < u.length; k++) {\n\t\t\t\t\t\t\t\ttemp = u[k][i];\n\t\t\t\t\t\t\t\tu[k][i] = u[k][j];\n\t\t\t\t\t\t\t\tu[k][j] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (k = 0; k < v.length; k++) {\n\t\t\t\t\t\t\t\ttemp = v[k][i];\n\t\t\t\t\t\t\t\tv[k][i] = v[k][j];\n\t\t\t\t\t\t\t\tv[k][j] = temp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\t   u.swapCols(i,j)\n\t\t\t\t\t\t\t//\t   v.swapCols(i,j)\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tU: u,\n\t\t\t\t\tS: q,\n\t\t\t\t\tV: v\n\t\t\t\t};\n\t\t\t};\n\t\t}","name":"Collage Script","documentation":"Use method:\n```\nrunCollage()\n```\n\n\nCollage.jsx\nCopyright (c) 2012 Motion Boutique\n\nPhotobook layout with selected layers","tags":["Compositions","Collage"],"snippet_prefix":"collage","is_snippet":false,"include_id":"collage","is_include":true,"last_update":1608623677156},{"_id":"Composition-Helper-1608555333201","code":"function findComp(compName){\n  var myComp;\n  for (var i = 1; i <= app.project.numItems; i++) {\n    if ((app.project.item(i) instanceof CompItem) && (app.project.item(i).name === compName)) {\n        if(myComp){\n          alert(\"ERROR: Duplicate Composition Found!\\nPlease change your composition name into something unique for \" + myComp.name + \" so that it will be able to find uniquely.\");\n          myComp = undefined;\n          break;\n        }\n        myComp = app.project.item(i);\n      }\n  }\n  \n  return myComp;\n}\n\nfunction addFolder(name){\n  return app.project.items.addFolder(name);\n}\n\nfunction addCompFromFolder(folder,name,width,height,pixelAspect,duration,frameRate){\n  return folder.items.addComp(name, width, height, pixelAspect, duration, frameRate);\n}\n\nfunction addCompFromActiveComp(name, width, height, pixelAspect, duration, frameRate){\n  var currentComp, newComp;\n  currentComp = findComp(app.project.activeItem.name);\n  newComp = app.project.items.addComp(name, width, height, pixelAspect, duration, frameRate);\n  return currentComp.layers.add(newComp);\n}\n\nfunction addCompFromSelectedComp(comp, name, width, height, pixelAspect, duration, frameRate){\n  var newComp = app.project.items.addComp(name, width, height, pixelAspect, duration, frameRate);\n  return comp.layers.add(newComp);\n}\n\nfunction addSolid(comp, name, width, height, pixelAspect, duration) {\n\tvar solid = comp.layers.addSolid([1, 1, 1], name, width, height, pixelAspect, duration);\n\treturn solid;\n}\n\nfunction addNullLayer(comp, layerName) {\n\tvar NULL_LAYER = comp.layers.addNull();\n\tNULL_LAYER.name = layerName;\n\treturn NULL_LAYER;\n}","name":"Composition Helper","documentation":"### Compositions Helper\n\n`findComp(compName)` - Returns Composition\n\n`addFolder(name)` - Returns Folder Object\n\n`addCompFromFolder(folder, name, width, height, pixelAspect, duration, frameRate)` - Returns New Composition\n\n`addCompFromActiveComp(name, width, height, pixelAspect, duration, frameRate)` - Returns New Composition\n\n`addCompFromSelectedComp(comp, name, width, height, pixelAspect, duration, frameRate)` - Returns Passed Composition\n\n`addSolid(comp, name, width, height, pixelAspect, duration)` - Returns Solid Layer\n\n`addNullLayer(comp, layerName)` - Returns Null Layer","snippet_prefix":"","is_snippet":false,"include_id":"composition","is_include":true,"last_update":1611483506982},{"_id":"Composition-Ratio-Calculator-1608553692810","code":"function calculateRatio(num_1, num_2){\n    for(num=num_2; num>1; num--) {\n        if((num_1 % num) == 0 && (num_2 % num) == 0) {\n            num_1=num_1/num;\n            num_2=num_2/num;\n        }\n    }\n    var ratio = num_1+\":\"+num_2;\n    return ratio;\n}\n\nfunction getRectangleWidthHeight(aspectRatio, area){\n  if(typeof aspectRatio === \"string\"){\n    aspectRatio = aspectRatio.split(\":\");\n  }\n  \n  var convert = (area * aspectRatio[1]) / aspectRatio[0];\n  var height = Math.round(Math.sqrt(convert));\n  var width = Math.round(area/height);\n  return [width, height];\n}","name":"Composition Ratio Calculator","documentation":"[Reference Formula](http://mathcentral.uregina.ca/QQ/database/QQ.09.15/h/colum1.html)\n\nThis is a composition ratio calculator to determine the ratio of your composition size.\n\nAttributes:\n\ncalculateRatio(`num_1`, `num_2`)\n\ngetRectangleWidthHeight(`aspectRatio`, `area`)","snippet_prefix":"ratio","is_snippet":true,"include_id":"ratio_calculator","is_include":true,"last_update":1608553744703},{"_id":"Controller-Helper-1608554320479","code":"function findControllerName(name) {\n\tvar layerName = \"\";\n\tvar controller = {\n\t\tpoint3D: \"ADBE Point3D Control\",\n\t\tangle: \"ADBE Angle Control\",\n\t\tcheckbox: \"ADBE Checkbox Control\",\n\t\tcolor: \"ADBE Color Control\",\n\t\tlayer: \"ADBE Layer Control\",\n\t\tpoint: \"ADBE Point Control\",\n\t\tslider: \"ADBE Slider Control\"\n\t};\n\n\tfor (var control in controller) {\n\t\tvar sanitize = control.replace(/ADBE/g).replace(/Control/g).trim();\n\t\tvar nameReg = new RegExp(name, \"g\");\n\t\tif (sanitize.match(nameReg)) {\n\t\t\tlayerName = controller[control];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn layerName;\n}\n\nfunction addController(controlLayer, targerLayer, effect, controller) {\n\tvar AE_Controller = findControllerName(controller.controllerType);\n\t// Get Value from target layer\n\tif (effect.effectName){\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(effect.effectName).value;\n\t} else {\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(1).value;\n\t}\n\t\n\tvar slider_control = controlLayer.Effects.addProperty(AE_Controller);\n\tif (controller.controllerName && controller.controllerName.length > 0) {\n\t\tslider_control.name = controller.controllerName;\n\t}\n\t\n\t// Apply value on slider controller\n\tslider_control.property(1).setValue(getValue);\n\t\n\t// Set expression on targetLayer\n\tif (effect.effectName) {\n\t\ttargerLayer.Effects.property(effect.effectType)(effect.effectName).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t} else {\n\t\ttargerLayer.Effects.property(effect.effectType)(1).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t}\n}","name":"Controller Helper","documentation":"## Find Controller Name\n`findControllerName(**Controller Name : string**)` -> Returns Controller Name\n\n## Add Controller Method\n> [Effect Names](https://after-effects-scripting-guide.readthedocs.io/matchnames/effects/firstparty/)\n```\naddController(controlLayer, targetLayer, {\n\teffectType: <Effect Name : string>,\n        effectName: <Rename Effect : string>\n}, {\n\tcontrollerType: <Controller Type : 'slider' , 'point3d', 'angle', 'color', 'checkbox', 'layer'>,\n\tcontrollerName: <Rename Controller : string>\n});\n```\n-> Returns Controller","snippet_prefix":"controllerHelper","is_snippet":true,"include_id":"controller","is_include":true,"last_update":1608558584650},{"_id":"Insert-Multiple-Videos-to-Compositions-1610870162057","code":"require(\"composition\");\nvar project = app.project;\nvar projectSelection = project.selection ? project.selection : [];\nvar selectedComps = project.activeItem ? project.activeItem.selectedLayers : [];\nvar projectVideoErrTxt = \"You must select any videos in your Project Panel\";\nvar selectedCompsErrTxt = \"You must select any compositions in your current comp\";\nvar random = _ bool: Random Selection to Selected Compositions? _;\nvar quickRun = _ bool: Run from Visual Mode? _;\n\nfunction insertVidsToComps(error){\n  if(error){\n      try{\n        // Did not select any layers compositions in Comp\n        if(selectedComps.length == 0 && projectSelection.length > 0){\n          throw Error(selectedCompsErrTxt + \" to get started.\");\n        }\n        \n        // Did not select any videos in Project Panel\n        if(projectSelection.length == 0 && selectedComps.length > 0) {\n            throw Error(projectVideoErrTxt + \" to get started.\");\n        }\n        \n        // Did not select both videos in Project Panel & Compositions in current Composition\n        if(projectSelection.length == 0 && selectedComps.length == 0){\n          throw Error(projectVideoErrTxt + \" & \" + selectedCompsErrTxt + \" to get started.\");\n        }\n        \n        start();\n    }catch(e){\n      alert(e);\n    }\n  }else {\n    start();\n  }\n}\n\nfunction start(random){\n  app.beginUndoGroup(\"insertVidsToComps\");\n  var projectSelectionRand = [];\n  var projectSelectionNorm = 0;\n  for(var comps = 0; comps < selectedComps.length; comps++){\n    var theComp = findComp(selectedComps[comps].name);\n    if(random){\n      var total = projectSelection.length;\n      while(true){\n          if(projectSelectionRand.length === total && comps === selectedComps.length){\n              break;\n          }\n          var generator = Math.round(Math.random() * total);\n          if(projectSelectionRand.indexOf(generator) > -1){\n              continue;\n          }\n          \n          // Begins Code\n          if(projectSelection[generator]){\n            theComp.layers.add(projectSelection[generator]); \n            projectSelectionRand.push(generator);\n            break; \n          }else{\n            projectSelectionRand = []\n            continue;\n          }\n      }\n    }else if(!random) {\n      if(projectSelection[projectSelectionNorm]){\n        theComp.layers.add(projectSelection[projectSelectionNorm]);\n        projectSelectionNorm++ \n      }else{\n        projectSelectionNorm = 0;\n        theComp.layers.add(projectSelection[projectSelectionNorm]);\n      }\n    }\n  }\n  \n  app.endUndoGroup();\n}\n\nif(quickRun){\n  start(random); \n}","name":"Insert Multiple Videos into Compositions","documentation":"This is to fasten your workflow by selecting multiple compositions AND multiple videos in Project Panel to insert all videos into selected compositions.\n## Attributes:\n`random` -> True/False\n\n## Function:\n`start(random)` - Returns nothing","tags":["Compositions","Multiple","Videos"],"include_id":"multiple_videos_into_comp","is_include":true,"last_update":1611479324957},{"_id":"Remove-All-Layers-inside-Composition-1611550153222","code":"require(\"composition\");\nvar run = _ bool: Running from visual mode? _;\nvar totalComps = 0;\nvar totalLayers = 0;\nvar totalCompString = \"\\nTotal Comp that has been running: \\n\";\nvar totalLayersString = \"\\nTotal Layers that has been deleted: \\n\";\napp.beginUndoGroup(\"Remove All Layers inside Comp\");\ntry{\n  if(run){\n    if(app.project.selection.length > 0){\n      removeAllProjectSelection(); \n    }\n    if(app.project.activeItem.selectedLayers.length > 0){\n      removeAllLayerSelection();  \n    }\n    \n    if(totalLayers > 0 || totalComp > 0){\n      alert(\"Report!\" + totalCompString + totalComps + \" compositions.\" + totalLayersString + totalLayers + \" layers.\" );\n    }\n  } \n}catch(e){\n  alert(e)\n}\napp.endUndoGroup();\n\nfunction removeAllProjectSelection(customProjectSelection){\n  var projectSelection = customProjectSelection ? customProjectSelection : app.project.selection;\n  for(var project = 0; project < projectSelection.length; project++){\n    var myComp = findComp(projectSelection[project].name)\n    for(var projectLayers = myComp.numLayers; projectLayers >= 1; projectLayers--){\n      try{\n        myComp.layers[projectLayers].remove();\n        totalLayers++; \n      }catch(e){\n        throw Error(\"Unable to remove layer: \" + myComp.layers[projectLayers].name);\n      }\n    }\n    totalComps++;\n  }\n}\n\nfunction removeAllLayerSelection(customSelectedLayers){\n  var layerSelection = customSelectedLayers ? customSelectedLayers : app.project.activeItem.selectedLayers;\n  for(var layer = 0; layer < layerSelection.length; layer++){\n    var myComp = findComp(layerSelection[layer].name);\n    for(var compLayers = myComp.numLayers; compLayers >= 1; compLayers--){\n      try{\n        myComp.layers[compLayers].remove();\n        totalLayers++;\n      }catch(e){\n        throw Error(\"Unable to remove layer: \" + myComp.layers[compLayers].name);\n      }\n    }\n    totalComps++;\n  }\n}","name":"Remove All Layers inside Composition","documentation":"This is to remove all layers inside comp:\n# Method:\n`removeAllProjectSelection(customProjectSelection)` -> Remove Project Selection\n`removeAllLayerSelection(customSelectedLayers)` -> Remove Layer Selection\n\n## Attributes:\n`customProjectSelection` -> Array of `app.project.selection`. You can pass your own array of selected projects as attribute.\n`customSelectedLayers` -> Array of `app.project.activeItem.selectedLayers`. You can pass your own array of selected layers as attribute.","tags":["Compositions","Layer","Multiple"],"include_id":"remove_all_layers","is_include":true,"last_update":1611565039477}]},{"_id":"Default-1588045113736","name":"My Code","type":"script","expressions":[{"_id":"AI-to-AE-1595922381748","code":"var docRef=activeDocument;\r\nalert(Object.stringify(docRef));\r\nvar layerCount=docRef.layers.length;\r\nvar currentComp = app.project.activeItem;\r\nalert(\"Current Comp\" + currentComp);\r\nfor(i=layerCount-1;i>=0;i--)\r\n{\r\n\tvar currLayer=docRef.layers[i]; \r\n\tif(currLayer.layers.length>0){\r\n\r\n\t\tfor(j=currLayer.layers.length-1;j>=0;j--){\r\n  \t  currLayer.layers[j].move(currLayer,ElementPlacement.PLACEAFTER);\r\n  \t}\r\n  \ttry{\r\n  \t  currentComp.layers.add(currLayer); \r\n  \t}catch(e){\r\n  \t  alert(e);\r\n  \t}\r\n  }\r\n}\r\n","name":"AI to AE","documentation":"This is for transform complicated AI vector files to AE instantly. Like Overload AXE plugin.","tags":["Import","Adobe Illustrator"],"last_update":1595924733620},{"_id":"Divide-Compositions-1590999177068","code":"var comp = app.project.selection;\nvar MUTEAUDIO = _ bool: Mute Audio ? _;\nvar compSec = _ number *: Number of seconds on each Divide Compositions _;\nvar fastForward = _ bool: Enable fast forward ? _;\nvar fastForwardDifference = _ number: Time in seconds to fast forward _;\nvar rotateValue = _ number: Rotate Compositions ? (HINTS: 90, 180, 270) _;\nvar timeRemappingPropertyName = \"ADBE Time Remapping\";\n\nvar ROTATION = {\n\tVERTICAL: 90,\n\tHORIZONTAL: 180,\n\tINVERTVERTICAL: 270\n}\n\nif (comp.length === 0) {\n\talert(\"You didn't select any compositions in Project Panel. Please select atleast one\");\n} else {\n\tapp.beginUndoGroup(\"Divide Compositions\");\n\tmain();\n\tapp.endUndoGroup();\n}\n\nfunction rotation(comp, layer, rotation) {\n\tvar width = comp.width;\n\tvar height = comp.height;\n\tvar posX = layer.Transform.property(\"Position\").value[0];\n\tvar posY = layer.Transform.property(\"Position\").value[1];\n\tif (ROTATION.VERTICAL == rotation) {\n\t\tcomp.width = height;\n\t\tcomp.height = width;\n\t\tlayer.Transform.property(\"Rotation\").setValue(rotation);\n\t\tlayer.Transform.property(\"Position\").setValue([posY, posX]);\n\t\treturn;\n\t} else if (ROTATION.INVERTVERTICAL == rotation) {\n\t\tcomp.width = height;\n\t\tcomp.height = width;\n\t\tlayer.Transform.property(\"Rotation\").setValue(rotation);\n\t\tlayer.Transform.property(\"Position\").setValue([posY, posX]);\n\t\treturn;\n\t} else if (ROTATION.HORIZONTAL == rotation) {\n\t\tlayer.Transform.property(\"Rotation\").setValue(rotation);\n\t\treturn;\n\t} else {\n\t\twrite(\"ERROR ROTATE: \" + comp.name);\n\t}\n}\n\nfunction rotateName(compName, rotation) {\n\tif (ROTATION.VERTICAL == rotation) {\n\t\treturn compName + \" - ROTATE \" + rotation + \"°\";\n\t} else if (ROTATION.INVERTVERTICAL == rotation) {\n\t\treturn compName + \" - ROTATE \" + rotation + \"°\";\n\t} else if (ROTATION.HORIZONTAL == rotation) {\n\t\treturn compName + \" - ROTATE \" + rotation + \"°\";\n\t} else {\n\t\treturn compName;\n\t}\n}\n\nfunction main() {\n\tfor (var i = 0; i < comp.length; i++) {\n\t\tvar compName = comp[i].name.replace(/\\.[^\\/\\.]+$/, \"\");\n\t\tif (rotateValue) {\n\t\t\tcompName = rotateName(compName, rotateValue);\n\t\t}\n\t\tvar folder = app.project.items.addFolder(compName);\n\t\tvar remaining = calculateDivide(fastForward, compSec, fastForwardDifference);\n\t\tvar compTimeDivide = comp[i].duration / remaining;\n\t\tvar startTime = 0;\n\t\tvar lastTime = comp[i].duration;\n\t\tfor (var numComp = 0; numComp < compTimeDivide; numComp++) {\n\t\t\t// If it reaches limit, reset fastForwardStart & fastForwardEnd value\n\t\t\tif (lastTime < 0) {\n\t\t\t\tfastForwardStart = undefined;\n\t\t\t\tfastForwardEnd = undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Adding new comp in a folder\n\t\t\tvar newComp = folder.items.addComp(compName + \"-\" + numComp, comp[i].width, comp[i].height, comp[i].pixelAspect, compSec, comp[i].frameRate);\n\t\t\tnewComp.layers.add(comp[i]);\n\t\t\tvar layer = newComp.layer(comp[i].name);\n\t\t\tlayer.startTime -= startTime;\n\n\t\t\tif (rotateValue) {\n\t\t\t\trotation(newComp, layer, rotateValue);\n\t\t\t}\n\n\t\t\t// If user wants to mute audio\n\t\t\tif (MUTEAUDIO) {\n\t\t\t\tlayer.audioEnabled = false;\n\t\t\t}\n\n\t\t\t// If fast forward enabled\n\t\t\tif (fastForward && layer.canSetTimeRemapEnabled) {\n\t\t\t\tvar fastForwardStart = fastForwardEnd ? fastForwardEnd : startTime;\n\n\t\t\t\t// Calculate at the end of fastForwardEnd value\n\t\t\t\tif (numComp > 1 && fastForwardEnd) {\n\t\t\t\t\tfastForwardEnd = fastForwardEnd + fastForwardDifference;\n\t\t\t\t} else {\n\t\t\t\t\tvar fastForwardEnd = startTime + compSec + fastForwardDifference;\n\t\t\t\t}\n\n\t\t\t\t// If it reaches the maximum of compositions duration\n\t\t\t\tif (fastForwardEnd > comp[i].duration) {\n\t\t\t\t\tfastForwardEnd = comp[i].duration;\n\t\t\t\t}\n\n\n\t\t\t\t// Time remapping starts\n\t\t\t\tlayer.timeRemapEnabled = true;\n\t\t\t\tvar newFirstKeyIndex = layer.property(timeRemappingPropertyName).addKey(newComp.displayStartTime);\n\t\t\t\tvar newLastKeyIndex = layer.property(timeRemappingPropertyName).addKey(newComp.displayStartTime + newComp.duration);\n\t\t\t\tlayer.property(timeRemappingPropertyName).setValueAtKey(newFirstKeyIndex, fastForwardStart);\n\t\t\t\tlayer.property(timeRemappingPropertyName).setValueAtKey(newLastKeyIndex, fastForwardEnd);\n\n\t\t\t\t// Will decrease it lastTime to exit the loop\n\t\t\t\tlastTime -= fastForwardDifference;\n\t\t\t}\n\n\t\t\t// Will increase startTime to continue doing adding newComp at the number of seconds input\n\t\t\tstartTime += compSec;\n\t\t}\n\t}\n}\n\n\n// Function to calculate remaining of time based on number of compositions set.\nfunction calculateDivide(enable, compSec, difference) {\n\tif (enable) {\n\t\tvar remaining = compSec - difference;\n\t\tif (remaining > 0) {\n\t\t\treturn remaining\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\treturn compSec;\n\t}\n}","name":"Divide Compositions","documentation":"Ever wonder to divide your lengthy compositions into a specific number of seconds? Try to figuring out how to post on Instagram Story or whatsoever? Try this script!\n\nP/s : You can also fast forward video in number of seconds. Try it out!","tags":["Compositions","Duration","Divide"],"last_update":1608636253288},{"_id":"Motion-Trail-1588228261142","code":"app.beginUndoGroup(\"Undo Motion Trail\");\n\nvar targetLayer = _ layer: Target Layer _;\nvar renameLayer = _ string: Rename Layer _;\nvar labelColor = _ number: Label Color(Option: 1 - 16) _;\nvar numOfFramesDelay = _ number: Number of Frames Delay _;\nvar opacityFactor = _ number: Opacity Factor(Try 0.75) _;\nvar numOfRepeatLayer = _ number: Number of Repeat Layer(Optional) _;\n\nclearOutput();\n\nif (targetLayer) {\n\tvar layer = app.project.activeItem.layer(targetLayer.name);\n\tvar nullLayer = app.project.activeItem.layers.addNull();\n\tnullLayer.name = renameLayer.length > 0 ? renameLayer + \" Controller\" : layer.name + \" Controller\";\n\tlayer.label = labelColor;\n\tnullLayer.label = labelColor;\n\n\tif (renameLayer.length > 0) {\n\t\tlayer.name = renameLayer;\n\t}\n\n\t// Add slider control\n\tvar sliderFrame = nullLayer.Effects.addProperty(\"ADBE Slider Control\");\n\tsliderFrame.name = \"Number of Frames Delay\";\n\tsliderFrame.property(\"Slider\").setValue(numOfFramesDelay);\n\t//Apply to position\n\tvar posExpression = \"var delay = thisComp.layer(\\\"\" + nullLayer.name + \"\\\").effect(\\\"\" + sliderFrame.name + \"\\\")(1); //number of frames to delay \\nvar d = delay*thisComp.frameDuration*(index - 1); \\nthisComp.layer(1).position.valueAtTime(time - d);\";\n\n\tvar sliderOpac = nullLayer.Effects.addProperty(\"ADBE Slider Control\");\n\tsliderOpac.name = \"Opacity Factor\";\n\tsliderOpac.property(\"Slider\").setValue(opacityFactor);\n\t//Apply to Opacity\n\tvar opacExpression = \"var opacityFactor = thisComp.layer(\\\"\" + nullLayer.name + \"\\\").effect(\\\"\" + sliderOpac.name + \"\\\")(1); \\nMath.pow(opacityFactor,index - 1)*100;\";\n\n\ttry {\n\t\t// Add expression\n\t\tlayer.property(\"Transform\").property(\"Position\").expression = posExpression;\n\t\tlayer.property(\"Transform\").property(\"Opacity\").expression = opacExpression;\n\t} catch (e) {\n\t\talert(e);\n\t}\n\n\t// Parent all layer to null layer so that it can animate position property and all\n\t// \tapp.project.activeItem.layer(layer.name).parent = nullLayer;\n\n\tif (numOfRepeatLayer > 0) {\n\t\tfor (var i = 0; i < numOfRepeatLayer; i++) {\n\t\t\tvar duplicateLayer = layer.duplicate();\n\t\t}\n\t}\n}\n\nwriteLn(\"Script successful added to layer name:\\n'\" + layer.name + \"'.\")\napp.endUndoGroup();","name":"Motion Trail","documentation":"You can apply this to any layer! It will do motion trail for you when you had set keyframe on Position property.","tags":["Motion Trail","Trail"],"last_update":1591380434089},{"_id":"RAW-Beautify-1591342857540","code":"require(\"stringReplace\");\nrequire(\"controller\");\nvar selections = app.project.selection;\nvar customName = _ string: Custom Compositions Name Prefix _;\nvar postfix = _ bool: Enable custom name as postfix ? _;\nvar nobeColorRemap =  _ bool: Use Nobe Color Remap Plugin? (You must have Nobe Color Remap plugin to work, if not Hue/Saturation effect will be use) _;\nvar nullController = _ bool: Need Controller ? (NULL layer) _;\nvar DARK_MaskRadius = _ number *: Dark Mask Radius(Minimum = 1) _;\nvar DARK_MaskAmount = _ number *: Dark Mask Amount(Minimum = 50) _;\nvar LIGHT_MaskRadius = _ number *: Light Mask Radius(Minimum = 0.5) _;\nvar LIGHT_MaskAmount = _ number *: Light Mask Amount(Minimum = 50) _;\nvar BRIGHTNESS_CONTROL = _ bool: Need Brightness Control ? _;\nvar BRIGHTNESS_VALUE = _ number: Brightness Value _;\nvar CONTRAST_VALUE = _ number: Contrast Value _;\nvar SOFT_LIGHT = BlendingMode.SOFT_LIGHT;\nvar LIGHTEN = BlendingMode.LIGHTEN;\nvar unsharpMask = \"ADBE Unsharp Mask2\";\nvar hue = \"ADBE HUE SATURATION\";\nvar brightness = \"ADBE Brightness & Contrast 2\";\nvar nobeColorRemapEffect = \"Nobe Color Remap\";\nvar status = \"\";\n\nif (selections.length === 0) {\n\talert(\"You did not select any compositions in Project Panel\");\n} else {\n\tapp.beginUndoGroup(\"RAW Color Compositions\");\n\tmain();\n\tif(status.length > 0){\n\t  alert(status);\n\t}\n\tapp.endUndoGroup();\n}\n\n\nfunction addController(controlLayer, targerLayer, effect, controller) {\n\tvar AE_Controller = findControllerName(controller.controllerType);\n\t// Get Value from target layer\n\tif (effect.effectName){\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(effect.effectName).value;\n\t} else {\n\t  var getValue = targerLayer.Effects.property(effect.effectType)(1).value;\n\t}\n\t\n\tvar slider_control = controlLayer.Effects.addProperty(AE_Controller);\n\tif (controller.controllerName && controller.controllerName.length > 0) {\n\t\tslider_control.name = controller.controllerName;\n\t}\n\t\n\t// Apply value on slider controller\n\tslider_control.property(1).setValue(getValue);\n\t\n\t// Set expression on targetLayer\n\tif (effect.effectName) {\n\t\ttargerLayer.Effects.property(effect.effectType)(effect.effectName).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t} else {\n\t\ttargerLayer.Effects.property(effect.effectType)(1).expression = \"thisComp.layer(\\\"\" + controlLayer.name + \"\\\").effect(\\\"\" + slider_control.name + \"\\\")(1)\";\n\t}\n}\n\nfunction main() {\n\tfor (var numComp = 0; numComp < selections.length; numComp++) {\n\t\tvar naming = removeExtensionName(selections[numComp].name);\n\t\tif (customName && customName.length > 0) {\n\t\t\tnaming = !postfix ? customName + \" - \" + removeExtensionName(selections[numComp].name) : removeExtensionName(selections[numComp].name) + \" - \" + customName;\n\t\t}\n\t\tvar newComp = app.project.items.addComp(naming, selections[numComp].width, selections[numComp].height, selections[numComp].pixelAspect, selections[numComp].duration, selections[numComp].frameRate);\n\t\tnewComp.layers.add(selections[numComp]);\n\t\tvar layer = newComp.layer(selections[numComp].name);\n\t\tvar secondLayer = layer.duplicate();\n\t\tsecondLayer.blendingMode = SOFT_LIGHT;\n\n\t\tif (nullController) {\n\t\t\tvar NULL_LAYER = addNullLayer(newComp, \"CONTROLLER\");\n\t\t}\n\n\t\ttry {\n\t\t\tvar DARK = addAdjustmentLayer(newComp, selections[numComp], \"DARK\");\n\t\t\tvar DARK_MASK1 = DARK.Effects.addProperty(unsharpMask);\n\t\t\tDARK_MASK1.property(\"radius\").setValue(DARK_MaskRadius);\n\t\t\tDARK_MASK1.property(\"amount\").setValue(DARK_MaskAmount);\n\n\t\t\tvar LIGHT = addAdjustmentLayer(newComp, selections[numComp], \"LIGHT\");\n\t\t\tLIGHT.blendingMode = LIGHTEN;\n\n\t\t\t// Start with mask 2 first because my format is always like that\n\t\t\tvar LIGHT_MASK2 = LIGHT.Effects.addProperty(unsharpMask);\n\t\t\tLIGHT_MASK2.property(\"radius\").setValue(LIGHT_MaskRadius * 2);\n\t\t\tLIGHT_MASK2.property(\"amount\").setValue(LIGHT_MaskAmount * 2);\n\n\t\t\tvar LIGHT_MASK1 = LIGHT.Effects.addProperty(unsharpMask);\n\t\t\tLIGHT_MASK1.property(\"radius\").setValue(LIGHT_MaskRadius);\n\t\t\tLIGHT_MASK1.property(\"amount\").setValue(LIGHT_MaskAmount);\n\n\t\t\tvar HUE = addAdjustmentLayer(newComp, selections[numComp], \"HUE\");\n\t\t\t\n\t\t\t// Apply Color Effect to adjustment layer\n\t\t\tif(nobeColorRemap){\n\t\t\t  if(HUE.Effects.canAddProperty(nobeColorRemapEffect)){\n\t\t\t    var HUE_EFFECT = HUE.Effects.addProperty(nobeColorRemapEffect);\n\t\t\t  } else {\n\t\t\t    var HUE_EFFECT = HUE.Effects.addProperty(hue);\n\t\t\t    status = nobeColorRemapEffect + \" Plugin is not available\";\n\t\t\t  }\n\t\t\t} else {\n\t\t\t  var HUE_EFFECT = HUE.Effects.addProperty(hue);\n\t\t\t}\n\n\t\t\tif (NULL_LAYER) {\n\t\t\t\t// 1\n\t\t\t\taddController(NULL_LAYER, DARK, {\n\t\t\t\t\teffectType: unsharpMask\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask (Dark)\"\n\t\t\t\t});\n\t\t\t\taddController(NULL_LAYER, DARK, {\n\t\t\t\t  effectType:\"Unsharp Mask\",\n\t\t\t\t  effectName:\"Radius\"\n\t\t\t\t}, {\n\t\t\t\t  controllerType: \"slider\",\n\t\t\t\t  controllerName: \"Unsharp Mask Radius (Dark)\"\n\t\t\t\t})\n\t\t\t\t// 2\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask\",\n\t\t\t\t\teffectName: \"Amount\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask (High Light)\"\n\t\t\t\t});\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask\",\n\t\t\t\t\teffectName: \"Radius\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask Radius (High Light)\"\n\t\t\t\t});\n\t\t\t\t// 3\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask 2\",\n\t\t\t\t\teffectName: \"Amount\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask (Low Light)\"\n\t\t\t\t});\n\t\t\t\taddController(NULL_LAYER, LIGHT, {\n\t\t\t\t\teffectType: \"Unsharp Mask 2\",\n\t\t\t\t\teffectName: \"Radius\"\n\t\t\t\t}, {\n\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\tcontrollerName: \"Unsharp Mask Radius (Low Light)\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (BRIGHTNESS_CONTROL) {\n\t\t\t\tvar BRIGHTNESS_LAYER = addBrightnessControl(newComp, selections[numComp], \"BRIGHTNESS\");\n\t\t\t\tBRIGHTNESS_LAYER.blendingMode = LIGHTEN;\n\t\t\t\tBRIGHTNESS_LAYER.Effects.property(brightness).property(\"Brightness\").setValue(BRIGHTNESS_VALUE ? BRIGHTNESS_VALUE : 0);\n\t\t\t\tBRIGHTNESS_LAYER.Effects.property(brightness).property(\"Contrast\").setValue(CONTRAST_VALUE ? CONTRAST_VALUE : 0);\n\n\t\t\t\tif (NULL_LAYER) {\n\t\t\t\t\t// 1\n\t\t\t\t\taddController(NULL_LAYER, BRIGHTNESS_LAYER, {\n\t\t\t\t\t\teffectType: \"Brightness & Contrast\",\n\t\t\t\t\t\teffectName: \"Brightness\"\n\t\t\t\t\t}, {\n\t\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\t\tcontrollerName: \"Brightness\"\n\t\t\t\t\t})\n\t\t\t\t\t// 2\n\t\t\t\t\taddController(NULL_LAYER, BRIGHTNESS_LAYER, {\n\t\t\t\t\t\teffectType: \"Brightness & Contrast\",\n\t\t\t\t\t\teffectName: \"Contrast\"\n\t\t\t\t\t}, {\n\t\t\t\t\t\tcontrollerType: \"slider\",\n\t\t\t\t\t\tcontrollerName: \"Contrast\"\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\talert(e);\n\t\t}\n\t\t\n  \tif (NULL_LAYER) {\n  \t\tNULL_LAYER.moveToBeginning()\n  \t}\n\t}\n}\n\nfunction addBrightnessControl(comp, selectionComp, layerName) {\n\tvar BRIGHTNESS_ADJUSTMENT = addAdjustmentLayer(comp, selectionComp, layerName);\n\tBRIGHTNESS_ADJUSTMENT.Effects.addProperty(brightness);\n\treturn BRIGHTNESS_ADJUSTMENT;\n}\n\nfunction addAdjustmentLayer(comp, selectionComp, layerName) {\n\tvar ADJUSTMENTLAYER = comp.layers.addSolid([1, 1, 1], layerName, selectionComp.width, selectionComp.height, selectionComp.pixelAspect, selectionComp.duration);\n\t// Enable Adjustment layer\n\tADJUSTMENTLAYER.adjustmentLayer = true;\n\treturn ADJUSTMENTLAYER;\n}\n\nfunction addNullLayer(comp, layerName) {\n\tvar NULL_LAYER = comp.layers.addNull();\n\tNULL_LAYER.name = layerName\n\treturn NULL_LAYER;\n}","name":"RAW Beautify","documentation":"My custom beautify from RAW Canon video intake.","is_snippet":false,"is_include":false,"last_update":1608478774180},{"_id":"Remove-Extension-Name-1591343769822","code":"function removeExtensionName(theString) {\n\treturn theString.replace(/\\.[^\\/\\.]+$/, \"\");\n}","name":"Remove Extension Name","documentation":"removeExtensionName(**string**)\n__Returns:__\n**string**","tags":["Remove","Extension","File Type"],"include_id":"stringReplace","is_include":true,"last_update":1591344603474},{"_id":"Rename-Composition-Layer-1611492467513","code":"var selectedLayers = app.project.activeItem.selectedLayers;\nvar makeItSourceName = _ bool: Make it source name ? _;\nvar prefixOrSuffix = _ bool: Prefix / Suffix(Checked: Prefix) _;\nvar preAndSuf = _ string: Prefix / Suffix _;\nvar rename = _ string *: Name _;\nvar serializeType = _ bool: Serialize: BEFORE / AFTER(Checked: Before) _;\nvar separator = _ string: Separator _;\nvar report = \"\";\n\n// Serialize\nif (!preAndSuf) {\n\tpreAndSuf = \"\"\n}\n\nif (!separator) {\n\tseparator = \"\"\n}\n\napp.beginUndoGroup(\"Renaming Layer\");\nstart();\napp.endUndoGroup();\n\nfunction start() {\n  var num = 1;\n\tfor (var i = 0; i < selectedLayers.length; i++) {\n\t\tvar renameSerialized = \"\"\n\t\tswitch (true) {\n\t\t\tcase serializeType === true && prefixOrSuffix === true:\n\t\t\t\trenameSerialized = separator.length > 0 ? num + separator + preAndSuf + separator + rename : num + preAndSuf + rename;\n\t\t\t\tbreak;\n\n\t\t\tcase serializeType === false && prefixOrSuffix === false:\n\t\t\t\trenameSerialized = separator.length > 0 ? rename + separator + preAndSuf + separator + num : rename + preAndSuf + num;\n\t\t\t\tbreak;\n\n\t\t\tcase serializeType === true && prefixOrSuffix === false:\n\t\t\t\trenameSerialized = separator.length > 0 ? num + separator + preAndSuf + separator + rename : num + preAndSuf + rename;\n\t\t\t\tbreak;\n\n\t\t\tcase serializeType === false && prefixOrSuffix === true:\n\t\t\t\trenameSerialized = separator.length > 0 ? rename + separator + preAndSuf + separator + num : rename + preAndSuf + num;\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttry {\n\t\t\tif (makeItSourceName) {\n\n\t\t\t\tif (selectedLayers[i] instanceof AVLayer) {\n\t\t\t\t\tselectedLayers[i].source.name = renameSerialized;\n\t\t\t\t\tif (selectedLayers[i].isNameFromSource === false) {\n\t\t\t\t\t\tselectedLayers[i].name = \"\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\"Not a valid AVLayer for: \" + selectedLayers[i].name)\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif (selectedLayers[i] instanceof AVLayer) {\n\t\t\t\t\tselectedLayers[i].name = renameSerialized;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\"Not a valid AVLayer for: \" + selectedLayers[i].name)\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (e) {\n\t\t\treport += \"\\n Error renaming Comp :\" + selectedLayers[i].name;\n\t\t}\n\t\t\n\t\t// increment starts\n\t\tnum++;\n\t}\n\tif (report.length > 0) {\n\t\talert(\"ERROR!\" + report);\n\t}\n}","name":"Rename Composition Layer","last_update":1611549611876},{"_id":"Text-Background-1588114280542","code":"app.beginUndoGroup(\"Add Background Text\");\n\nfunction truncateString(str, num) {\n  if (str.length <= num) {\n    return str\n  }\n  return str.slice(0, num) + ' ...'\n}\n\nvar curComp = app.project.activeItem;\n\n// Text Layer\nvar addTextBool = _ bool: Create Text? _;\nvar curText = _ layer: Text Layer _;\n\nif(curComp && addTextBool) {\n  curText = curComp.layers.addText(_ string: Your Text _);\n}\n\n// Padding\nvar paddingTopBottom = _ number: Padding Top & Bottom _;\nvar paddingLeftRight = _ number: Padding Left & Right _;\n\n// Color\nvar fillColor = _ color: Fill Color _;\nvar strokeColor = _ color: Stroke Color _;\n\nvar sliderControl = \"ADBE Slider Control\";\n\nvar groupName = \"Rectangle Box\";\nvar effectsName = \"Effects\";\nvar rectanglePathName = \"Rectangle Path 1\";\n\nif (curComp && curText) {\n\tvar shapeLayer = curComp.layers.addShape();\n\tshapeLayer.name = \"Text Box\";\n\tvar shapeGroup = shapeLayer.property(\"Contents\").addProperty(\"ADBE Vector Group\");\n\tshapeGroup.name = groupName;\n  shapeGroup.property(\"Contents\").addProperty(\"ADBE Vector Shape - Rect\");\n\n\tvar fill = shapeGroup.property(\"Contents\").addProperty(\"ADBE Vector Graphic - Fill\");\n\tfill.Color.setValue(fillColor);\n\tvar stroke = shapeGroup.property(\"Contents\").addProperty(\"ADBE Vector Graphic - Stroke\");\n\tstroke.Color.setValue(strokeColor);\n\t\n\t// Slider Control\n\tvar controllerTotalPad = shapeLayer.Effects.addProperty(sliderControl);\n  controllerTotalPad.name = \"Total Padding\";\n  shapeLayer.property(effectsName).property(controllerTotalPad.name)(1).expression = \"effect(\\\"Padding Top & Bottom\\\")(1) + effect(\\\"Padding Left & Right\\\")(1)\";\n  \n  var controllerPadTopBottom = shapeLayer.Effects.addProperty(sliderControl);\n  controllerPadTopBottom.name = \"Padding Top & Bottom\";\n  controllerPadTopBottom.Slider.setValue(paddingTopBottom);\n  \n  var controllerPadLeftRight = shapeLayer.Effects.addProperty(sliderControl);\n  controllerPadLeftRight.name = \"Padding Left & Right\";\n  controllerPadLeftRight.Slider.setValue(paddingLeftRight);\n  \n  var totalPaddingHeight = \"effect(\\\"Padding Top & Bottom\\\")(1)\";\n  var totalPaddingWidth = \"effect(\\\"Padding Left & Right\\\")(1)\";\n\t\n\t\n\t// Expression Sizes & Position\n\tvar expressionSize = \"x = thisComp.layer(\\\"\" + curText.name + \"\\\").sourceRectAtTime().width\" + \n\t\";y = thisComp.layer(\\\"\" + curText.name + \"\\\").sourceRectAtTime().height;\" + \n\t\"[x + \" + totalPaddingWidth + \", y + \" + totalPaddingHeight + \"];\";\n\t\n\tvar expressionPos = \"s=thisComp.layer(\\\"\" + curText.name + \"\\\");\" +\n                      \"w=s.sourceRectAtTime().width/2;\" +\n                      \"h=s.sourceRectAtTime().height/2;\" + \n                      \"l=s.sourceRectAtTime().left;\" +\n                      \"t=s.sourceRectAtTime().top;\" +\n                      \"[w+l,h+t];\";\n\t\n\t// Set expression to shapeLayer\n\tshapeLayer.content(groupName).content(rectanglePathName).size.expression = expressionSize;\n\tshapeLayer.content(groupName).content(rectanglePathName).position.expression = expressionPos;\n\t\n\t\n\t// If Using existing text layer\n\tif(!addTextBool){\n\t  var posText = curComp.layer(curText.name).property(\"Position\").value;\n\t  shapeLayer.property(\"Position\").setValue([posText[0], posText[1]]);\n\t}\n\t\n\t// Name Shape layer based on text\n\tshapeLayer.name += \" - \" + truncateString(curText.name, 10);\n\t\t\n\t// Set parent shape layer to text layer\n\tcurComp.layer(shapeLayer.name).parent = curText;\n\t\n\t// Set Position of Text to be center of comp\n\tcurText.property(\"position\").setValue([curComp.width/2, curComp.height/2]);\n\t\n\t// Move to last index\n\tshapeLayer.moveToEnd();\n}\n\n// Deselect All Layers\napp.executeCommand(2004);\n\napp.endUndoGroup();","name":"Text Background","documentation":"Text Background that always expand with the sourceText.\n\nIf you have your existing text layer, **uncheck \"Create Text\"** to use your own text layer. And **make sure your text layer is selected**.","tags":["Text","Background","Layer","Button"],"last_update":1588139172725}]},{"_id":"Useful-Expression-1588219431839","name":"Useful Expression","type":"expression","expressions":[{"_id":"Automatic-Fade-1588224794770","code":"var transition = _ slider: Transition Value _;       \r\nif (marker.numKeys<2){\r\n  tSecs = transition / ( 1 / thisComp.frameDuration); \r\n  linear(time, inPoint, inPoint + tSecs, 0, 100) - linear(time, outPoint - tSecs, outPoint, 0, 100)\r\n}else{\r\n  linear(time, inPoint, marker.key(1).time, 0, 100) - linear(time, marker.key(2).time, outPoint, 0, 100)\r\n}","name":"Automatic Fade","documentation":"The automatic fade expression is useful when you don’t want to bother a create keyframes for a fade animation. TARGET: **Opacity**","property_types":["1d"],"tags":["Fade","Transition","Automatic"],"last_update":1588226154709},{"_id":"Blink-1588227811718","code":"blinkSpeed = _ angle: Blink Speed _;\r\nn = Math.sin(time * blinkSpeed);\r\nif (n < 0) 0\r\nelse 100;","name":"Blink","documentation":"The blinking expression become super handy when you don’t want to repeat a bunch of opacity keyframes over and over or want to animate a cursor quickly.\nSimply add this expression below to your opacity properties.\nTARGET: **Opacity**","property_types":["other"],"tags":["Opacity","Blink"],"last_update":1588228205977},{"_id":"Bounce-Expression-1588219438498","code":"amp = _ slider: Amplitude _;\r\nfreq = _ slider: Frequency _;\r\ndecay = _ slider: Decay _;\r\nn = 0;\r\nif (numKeys > 0){\r\n  n = nearestKey(time).index;\r\nif (key(n).time > time){\r\n  n--;\r\n}}\r\nif (n == 0){\r\n  t = 0;\r\n}else{\r\n  t = time - key(n).time;\r\n}\r\nif (n > 0 && t < 1){\r\n  v = velocityAtTime(key(n).time - thisComp.frameDuration/10);\r\n  value + v*amp*Math.sin(freq*t*2*Math.PI)/Math.exp(decay*t);\r\n}else{\r\n  value\r\n  \r\n}","name":"Bounce Expression","documentation":"The bounce expression is very useful to make your animations and titles look dynamic with a nice elastic movement, just **make 2 keyframes position** and past the code below. TARGET: **Position**","property_types":["1d","2d"],"tags":["Bounce","Position"],"snippet_prefix":"","is_snippet":false,"last_update":1588226173559},{"_id":"Constant-Rotation-per-Second-1588226578681","code":"veloc = _ angle: Degree Rotation _; //360 Degree Rotation per Second\r\nr = rotation + (time - inPoint) *veloc;\r\n[r]","name":"Constant Rotation per Second","documentation":"Here is another After Effects rotation expression, no key frames needed to make a simple 360 rotation on a layer. TARGET: **Rotation**","property_types":["other"],"tags":["Rotation","Loop"],"last_update":1588226780120},{"_id":"Looping-Wiggle-1588226203602","code":"freq = _ slider: Frequency (Try 1.0) _;\r\namp = _ slider: Amplitude _;\r\nloopTime = _ slider: Num of Loop _;\r\nt = time % loopTime;\r\nwiggle1 = wiggle(freq, amp, 1, 0.5, t);\r\nwiggle2 = wiggle(freq, amp, 1, 0.5, t - loopTime);\r\nlinear(t, 0, loopTime, wiggle1, wiggle2)","name":"Looping Wiggle","documentation":"The looping [Wiggle Expression](https://blog.motionisland.com/wiggle-expression-after-effects-tutorial/) become handy when you want an object to move randomly in your composition. Looping wiggle should be seamless and you shouldn’t see a cut, this expression is also used for background animation. TARGET: **Position**","property_types":["1d","other"],"tags":["Loop","Wiggle"],"last_update":1588226498353},{"_id":"Squash---Stretch-1588225343333","code":"maxDev = _ slider: Max Deviation in Pixels _; // max deviation in pixels\r\nspd = _ slider: Speed of Oscillation _; //speed of oscillation\r\ndecay = _ slider: How Fast it Slows Down (Try 1.0) _; //how fast it slows down\r\n\r\nt = time - inPoint;\r\nx = scale[0] + maxDev*Math.sin(spd*t)/Math.exp(decay*t);\r\ny = scale[0]*scale[1]/x;\r\n[x,y]","name":"Squash & Stretch","documentation":"This bouncing squash and stretch expression should make your animation a bit more alive by adding a proportional scale to your shapes or images. TARGET: **Scale**","property_types":["2d","2d_spatial"],"tags":["Squash","Stretch"],"last_update":1588225711828}]}]